
build/routing.elf:     file format elf64-littleaarch64


Disassembly of section .text:

0000000000200000 <_start>:
  200000:	140004c8 	b	201320 <main>
	...

0000000000200010 <hash>:
#include <sddf/timer/client.h>
#include <sddf/timer/config.h>
#include <string.h>

#include "routing.h"
#include "firewall_arp.h"
  200010:	12002400 	and	w0, w0, #0x3ff
  200014:	d65f03c0 	ret
  200018:	d503201f 	nop
  20001c:	d503201f 	nop

0000000000200020 <hashtable_init>:
#include "hashmap.h"
#include "config.h"

__attribute__((__section__(".router_config"))) router_config_t router_config;
  200020:	91401003 	add	x3, x0, #0x4, lsl #12
  200024:	cb0303e1 	neg	x1, x3
  200028:	f2400c24 	ands	x4, x1, #0xf
  20002c:	54001360 	b.eq	200298 <hashtable_init+0x278>  // b.none
// Net1_client config will be for the rx of NIC1
  200030:	3900007f 	strb	wzr, [x3]
__attribute__((__section__(".router_config"))) router_config_t router_config;
  200034:	f27f083f 	tst	x1, #0xe
  200038:	54001240 	b.eq	200280 <hashtable_init+0x260>  // b.none
// Net1_client config will be for the rx of NIC1
  20003c:	3900047f 	strb	wzr, [x3, #1]
__attribute__((__section__(".router_config"))) router_config_t router_config;
  200040:	f100089f 	cmp	x4, #0x2
  200044:	54001249 	b.ls	20028c <hashtable_init+0x26c>  // b.plast
// Net1_client config will be for the rx of NIC1
  200048:	3900087f 	strb	wzr, [x3, #2]
__attribute__((__section__(".router_config"))) router_config_t router_config;
  20004c:	f27e043f 	tst	x1, #0xc
  200050:	540012a0 	b.eq	2002a4 <hashtable_init+0x284>  // b.none
// Net1_client config will be for the rx of NIC1
  200054:	39000c7f 	strb	wzr, [x3, #3]
__attribute__((__section__(".router_config"))) router_config_t router_config;
  200058:	f100109f 	cmp	x4, #0x4
  20005c:	540012a9 	b.ls	2002b0 <hashtable_init+0x290>  // b.plast
// Net1_client config will be for the rx of NIC1
  200060:	3900107f 	strb	wzr, [x3, #4]
__attribute__((__section__(".router_config"))) router_config_t router_config;
  200064:	f100149f 	cmp	x4, #0x5
  200068:	54001300 	b.eq	2002c8 <hashtable_init+0x2a8>  // b.none
// Net1_client config will be for the rx of NIC1
  20006c:	3900147f 	strb	wzr, [x3, #5]
__attribute__((__section__(".router_config"))) router_config_t router_config;
  200070:	f100189f 	cmp	x4, #0x6
  200074:	54001360 	b.eq	2002e0 <hashtable_init+0x2c0>  // b.none
// Net1_client config will be for the rx of NIC1
  200078:	3900187f 	strb	wzr, [x3, #6]
__attribute__((__section__(".router_config"))) router_config_t router_config;
  20007c:	361812c1 	tbz	w1, #3, 2002d4 <hashtable_init+0x2b4>
// Net1_client config will be for the rx of NIC1
  200080:	39001c7f 	strb	wzr, [x3, #7]
__attribute__((__section__(".router_config"))) router_config_t router_config;
  200084:	f100209f 	cmp	x4, #0x8
  200088:	54001329 	b.ls	2002ec <hashtable_init+0x2cc>  // b.plast
// Net1_client config will be for the rx of NIC1
  20008c:	3900207f 	strb	wzr, [x3, #8]
__attribute__((__section__(".router_config"))) router_config_t router_config;
  200090:	f100249f 	cmp	x4, #0x9
  200094:	54001320 	b.eq	2002f8 <hashtable_init+0x2d8>  // b.none
// Net1_client config will be for the rx of NIC1
  200098:	3900247f 	strb	wzr, [x3, #9]
__attribute__((__section__(".router_config"))) router_config_t router_config;
  20009c:	f100289f 	cmp	x4, #0xa
  2000a0:	540010e0 	b.eq	2002bc <hashtable_init+0x29c>  // b.none
// Net1_client config will be for the rx of NIC1
  2000a4:	3900287f 	strb	wzr, [x3, #10]
__attribute__((__section__(".router_config"))) router_config_t router_config;
  2000a8:	f1002c9f 	cmp	x4, #0xb
  2000ac:	540012c0 	b.eq	200304 <hashtable_init+0x2e4>  // b.none
// Net1_client config will be for the rx of NIC1
  2000b0:	39002c7f 	strb	wzr, [x3, #11]
__attribute__((__section__(".router_config"))) router_config_t router_config;
  2000b4:	f100309f 	cmp	x4, #0xc
  2000b8:	54001320 	b.eq	20031c <hashtable_init+0x2fc>  // b.none
// Net1_client config will be for the rx of NIC1
  2000bc:	3900307f 	strb	wzr, [x3, #12]
__attribute__((__section__(".router_config"))) router_config_t router_config;
  2000c0:	f100349f 	cmp	x4, #0xd
  2000c4:	54001320 	b.eq	200328 <hashtable_init+0x308>  // b.none
// Net1_client config will be for the rx of NIC1
  2000c8:	3900347f 	strb	wzr, [x3, #13]
__attribute__((__section__(".router_config"))) router_config_t router_config;
  2000cc:	f1003c9f 	cmp	x4, #0xf
  2000d0:	54001201 	b.ne	200310 <hashtable_init+0x2f0>  // b.any
  2000d4:	aa0403e5 	mov	x5, x4
  2000d8:	d2807e22 	mov	x2, #0x3f1                 	// #1009
// Net1_client config will be for the rx of NIC1
  2000dc:	3900387f 	strb	wzr, [x3, #14]
__attribute__((__section__(".router_config"))) router_config_t router_config;
  2000e0:	91401081 	add	x1, x4, #0x4, lsl #12
  2000e4:	d2808003 	mov	x3, #0x400                 	// #1024
  2000e8:	cb040064 	sub	x4, x3, x4
  2000ec:	8b010001 	add	x1, x0, x1
// Net1_client config will be for the rx of NIC1
  2000f0:	4f000400 	movi	v0.4s, #0x0
  2000f4:	927cec83 	and	x3, x4, #0xfffffffffffffff0
  2000f8:	8b010063 	add	x3, x3, x1
  2000fc:	d503201f 	nop
  200100:	3c810420 	str	q0, [x1], #16
__attribute__((__section__(".router_config"))) router_config_t router_config;
  200104:	eb03003f 	cmp	x1, x3
  200108:	54ffffc1 	b.ne	200100 <hashtable_init+0xe0>  // b.any
  20010c:	927cec83 	and	x3, x4, #0xfffffffffffffff0
  200110:	f2400c9f 	tst	x4, #0xf
  200114:	8b0300a1 	add	x1, x5, x3
  200118:	cb030042 	sub	x2, x2, x3
  20011c:	54000b00 	b.eq	20027c <hashtable_init+0x25c>  // b.none
// Net1_client config will be for the rx of NIC1
  200120:	8b010003 	add	x3, x0, x1
__attribute__((__section__(".router_config"))) router_config_t router_config;
  200124:	f100045f 	cmp	x2, #0x1
// Net1_client config will be for the rx of NIC1
  200128:	91401063 	add	x3, x3, #0x4, lsl #12
__attribute__((__section__(".router_config"))) router_config_t router_config;
  20012c:	91000424 	add	x4, x1, #0x1
// Net1_client config will be for the rx of NIC1
  200130:	3900007f 	strb	wzr, [x3]
__attribute__((__section__(".router_config"))) router_config_t router_config;
  200134:	54000a40 	b.eq	20027c <hashtable_init+0x25c>  // b.none
// Net1_client config will be for the rx of NIC1
  200138:	8b040004 	add	x4, x0, x4
__attribute__((__section__(".router_config"))) router_config_t router_config;
  20013c:	f100085f 	cmp	x2, #0x2
// Net1_client config will be for the rx of NIC1
  200140:	91401084 	add	x4, x4, #0x4, lsl #12
__attribute__((__section__(".router_config"))) router_config_t router_config;
  200144:	91000823 	add	x3, x1, #0x2
// Net1_client config will be for the rx of NIC1
  200148:	3900009f 	strb	wzr, [x4]
__attribute__((__section__(".router_config"))) router_config_t router_config;
  20014c:	54000980 	b.eq	20027c <hashtable_init+0x25c>  // b.none
// Net1_client config will be for the rx of NIC1
  200150:	8b030003 	add	x3, x0, x3
__attribute__((__section__(".router_config"))) router_config_t router_config;
  200154:	f1000c5f 	cmp	x2, #0x3
// Net1_client config will be for the rx of NIC1
  200158:	91401063 	add	x3, x3, #0x4, lsl #12
__attribute__((__section__(".router_config"))) router_config_t router_config;
  20015c:	91000c24 	add	x4, x1, #0x3
// Net1_client config will be for the rx of NIC1
  200160:	3900007f 	strb	wzr, [x3]
__attribute__((__section__(".router_config"))) router_config_t router_config;
  200164:	540008c0 	b.eq	20027c <hashtable_init+0x25c>  // b.none
// Net1_client config will be for the rx of NIC1
  200168:	8b040004 	add	x4, x0, x4
__attribute__((__section__(".router_config"))) router_config_t router_config;
  20016c:	f100105f 	cmp	x2, #0x4
// Net1_client config will be for the rx of NIC1
  200170:	91401084 	add	x4, x4, #0x4, lsl #12
__attribute__((__section__(".router_config"))) router_config_t router_config;
  200174:	91001023 	add	x3, x1, #0x4
// Net1_client config will be for the rx of NIC1
  200178:	3900009f 	strb	wzr, [x4]
__attribute__((__section__(".router_config"))) router_config_t router_config;
  20017c:	54000800 	b.eq	20027c <hashtable_init+0x25c>  // b.none
// Net1_client config will be for the rx of NIC1
  200180:	8b030003 	add	x3, x0, x3
__attribute__((__section__(".router_config"))) router_config_t router_config;
  200184:	f100145f 	cmp	x2, #0x5
// Net1_client config will be for the rx of NIC1
  200188:	91401063 	add	x3, x3, #0x4, lsl #12
__attribute__((__section__(".router_config"))) router_config_t router_config;
  20018c:	91001424 	add	x4, x1, #0x5
// Net1_client config will be for the rx of NIC1
  200190:	3900007f 	strb	wzr, [x3]
__attribute__((__section__(".router_config"))) router_config_t router_config;
  200194:	54000740 	b.eq	20027c <hashtable_init+0x25c>  // b.none
// Net1_client config will be for the rx of NIC1
  200198:	8b040003 	add	x3, x0, x4
__attribute__((__section__(".router_config"))) router_config_t router_config;
  20019c:	f100185f 	cmp	x2, #0x6
// Net1_client config will be for the rx of NIC1
  2001a0:	91401063 	add	x3, x3, #0x4, lsl #12
__attribute__((__section__(".router_config"))) router_config_t router_config;
  2001a4:	91001824 	add	x4, x1, #0x6
// Net1_client config will be for the rx of NIC1
  2001a8:	3900007f 	strb	wzr, [x3]
__attribute__((__section__(".router_config"))) router_config_t router_config;
  2001ac:	54000680 	b.eq	20027c <hashtable_init+0x25c>  // b.none
// Net1_client config will be for the rx of NIC1
  2001b0:	8b040004 	add	x4, x0, x4
__attribute__((__section__(".router_config"))) router_config_t router_config;
  2001b4:	f1001c5f 	cmp	x2, #0x7
// Net1_client config will be for the rx of NIC1
  2001b8:	91401084 	add	x4, x4, #0x4, lsl #12
__attribute__((__section__(".router_config"))) router_config_t router_config;
  2001bc:	91001c23 	add	x3, x1, #0x7
// Net1_client config will be for the rx of NIC1
  2001c0:	3900009f 	strb	wzr, [x4]
__attribute__((__section__(".router_config"))) router_config_t router_config;
  2001c4:	540005c0 	b.eq	20027c <hashtable_init+0x25c>  // b.none
// Net1_client config will be for the rx of NIC1
  2001c8:	8b030003 	add	x3, x0, x3
__attribute__((__section__(".router_config"))) router_config_t router_config;
  2001cc:	f100205f 	cmp	x2, #0x8
// Net1_client config will be for the rx of NIC1
  2001d0:	91401063 	add	x3, x3, #0x4, lsl #12
__attribute__((__section__(".router_config"))) router_config_t router_config;
  2001d4:	91002024 	add	x4, x1, #0x8
// Net1_client config will be for the rx of NIC1
  2001d8:	3900007f 	strb	wzr, [x3]
__attribute__((__section__(".router_config"))) router_config_t router_config;
  2001dc:	54000500 	b.eq	20027c <hashtable_init+0x25c>  // b.none
// Net1_client config will be for the rx of NIC1
  2001e0:	8b040004 	add	x4, x0, x4
__attribute__((__section__(".router_config"))) router_config_t router_config;
  2001e4:	f100245f 	cmp	x2, #0x9
// Net1_client config will be for the rx of NIC1
  2001e8:	91401084 	add	x4, x4, #0x4, lsl #12
__attribute__((__section__(".router_config"))) router_config_t router_config;
  2001ec:	91002423 	add	x3, x1, #0x9
// Net1_client config will be for the rx of NIC1
  2001f0:	3900009f 	strb	wzr, [x4]
__attribute__((__section__(".router_config"))) router_config_t router_config;
  2001f4:	54000440 	b.eq	20027c <hashtable_init+0x25c>  // b.none
// Net1_client config will be for the rx of NIC1
  2001f8:	8b030003 	add	x3, x0, x3
__attribute__((__section__(".router_config"))) router_config_t router_config;
  2001fc:	f100285f 	cmp	x2, #0xa
// Net1_client config will be for the rx of NIC1
  200200:	91401063 	add	x3, x3, #0x4, lsl #12
__attribute__((__section__(".router_config"))) router_config_t router_config;
  200204:	91002824 	add	x4, x1, #0xa
// Net1_client config will be for the rx of NIC1
  200208:	3900007f 	strb	wzr, [x3]
__attribute__((__section__(".router_config"))) router_config_t router_config;
  20020c:	54000380 	b.eq	20027c <hashtable_init+0x25c>  // b.none
// Net1_client config will be for the rx of NIC1
  200210:	8b040004 	add	x4, x0, x4
__attribute__((__section__(".router_config"))) router_config_t router_config;
  200214:	f1002c5f 	cmp	x2, #0xb
// Net1_client config will be for the rx of NIC1
  200218:	91401084 	add	x4, x4, #0x4, lsl #12
__attribute__((__section__(".router_config"))) router_config_t router_config;
  20021c:	91002c23 	add	x3, x1, #0xb
// Net1_client config will be for the rx of NIC1
  200220:	3900009f 	strb	wzr, [x4]
__attribute__((__section__(".router_config"))) router_config_t router_config;
  200224:	540002c0 	b.eq	20027c <hashtable_init+0x25c>  // b.none
// Net1_client config will be for the rx of NIC1
  200228:	8b030003 	add	x3, x0, x3
__attribute__((__section__(".router_config"))) router_config_t router_config;
  20022c:	f100305f 	cmp	x2, #0xc
// Net1_client config will be for the rx of NIC1
  200230:	91401063 	add	x3, x3, #0x4, lsl #12
__attribute__((__section__(".router_config"))) router_config_t router_config;
  200234:	91003024 	add	x4, x1, #0xc
// Net1_client config will be for the rx of NIC1
  200238:	3900007f 	strb	wzr, [x3]
__attribute__((__section__(".router_config"))) router_config_t router_config;
  20023c:	54000200 	b.eq	20027c <hashtable_init+0x25c>  // b.none
// Net1_client config will be for the rx of NIC1
  200240:	8b040004 	add	x4, x0, x4
__attribute__((__section__(".router_config"))) router_config_t router_config;
  200244:	f100345f 	cmp	x2, #0xd
// Net1_client config will be for the rx of NIC1
  200248:	91401084 	add	x4, x4, #0x4, lsl #12
__attribute__((__section__(".router_config"))) router_config_t router_config;
  20024c:	91003423 	add	x3, x1, #0xd
// Net1_client config will be for the rx of NIC1
  200250:	3900009f 	strb	wzr, [x4]
__attribute__((__section__(".router_config"))) router_config_t router_config;
  200254:	54000140 	b.eq	20027c <hashtable_init+0x25c>  // b.none
// Net1_client config will be for the rx of NIC1
  200258:	8b030003 	add	x3, x0, x3
__attribute__((__section__(".router_config"))) router_config_t router_config;
  20025c:	91003821 	add	x1, x1, #0xe
// Net1_client config will be for the rx of NIC1
  200260:	91401063 	add	x3, x3, #0x4, lsl #12
__attribute__((__section__(".router_config"))) router_config_t router_config;
  200264:	f100385f 	cmp	x2, #0xe
// Net1_client config will be for the rx of NIC1
  200268:	3900007f 	strb	wzr, [x3]
__attribute__((__section__(".router_config"))) router_config_t router_config;
  20026c:	54000080 	b.eq	20027c <hashtable_init+0x25c>  // b.none
// Net1_client config will be for the rx of NIC1
  200270:	8b010000 	add	x0, x0, x1
  200274:	91401000 	add	x0, x0, #0x4, lsl #12
  200278:	3900001f 	strb	wzr, [x0]
__attribute__((__section__(".net1_client_config"))) net_client_config_t net1_config;
// Net2_client config will be for the tx out of NIC2
  20027c:	d65f03c0 	ret
__attribute__((__section__(".router_config"))) router_config_t router_config;
  200280:	d2807fe2 	mov	x2, #0x3ff                 	// #1023
  200284:	d2800025 	mov	x5, #0x1                   	// #1
  200288:	17ffff96 	b	2000e0 <hashtable_init+0xc0>
  20028c:	d2807fc2 	mov	x2, #0x3fe                 	// #1022
  200290:	d2800045 	mov	x5, #0x2                   	// #2
  200294:	17ffff93 	b	2000e0 <hashtable_init+0xc0>
  200298:	d2800005 	mov	x5, #0x0                   	// #0
  20029c:	d2808002 	mov	x2, #0x400                 	// #1024
  2002a0:	17ffff90 	b	2000e0 <hashtable_init+0xc0>
  2002a4:	d2807fa2 	mov	x2, #0x3fd                 	// #1021
  2002a8:	d2800065 	mov	x5, #0x3                   	// #3
  2002ac:	17ffff8d 	b	2000e0 <hashtable_init+0xc0>
  2002b0:	d2807f82 	mov	x2, #0x3fc                 	// #1020
  2002b4:	d2800085 	mov	x5, #0x4                   	// #4
  2002b8:	17ffff8a 	b	2000e0 <hashtable_init+0xc0>
  2002bc:	aa0403e5 	mov	x5, x4
  2002c0:	d2807ec2 	mov	x2, #0x3f6                 	// #1014
  2002c4:	17ffff87 	b	2000e0 <hashtable_init+0xc0>
  2002c8:	aa0403e5 	mov	x5, x4
  2002cc:	d2807f62 	mov	x2, #0x3fb                 	// #1019
  2002d0:	17ffff84 	b	2000e0 <hashtable_init+0xc0>
  2002d4:	d2807f22 	mov	x2, #0x3f9                 	// #1017
  2002d8:	d28000e5 	mov	x5, #0x7                   	// #7
  2002dc:	17ffff81 	b	2000e0 <hashtable_init+0xc0>
  2002e0:	aa0403e5 	mov	x5, x4
  2002e4:	d2807f42 	mov	x2, #0x3fa                 	// #1018
  2002e8:	17ffff7e 	b	2000e0 <hashtable_init+0xc0>
  2002ec:	d2807f02 	mov	x2, #0x3f8                 	// #1016
  2002f0:	d2800105 	mov	x5, #0x8                   	// #8
  2002f4:	17ffff7b 	b	2000e0 <hashtable_init+0xc0>
  2002f8:	d2800125 	mov	x5, #0x9                   	// #9
  2002fc:	d2807ee2 	mov	x2, #0x3f7                 	// #1015
  200300:	17ffff78 	b	2000e0 <hashtable_init+0xc0>
  200304:	aa0403e5 	mov	x5, x4
  200308:	d2807ea2 	mov	x2, #0x3f5                 	// #1013
  20030c:	17ffff75 	b	2000e0 <hashtable_init+0xc0>
  200310:	d2807e42 	mov	x2, #0x3f2                 	// #1010
  200314:	d28001c5 	mov	x5, #0xe                   	// #14
  200318:	17ffff72 	b	2000e0 <hashtable_init+0xc0>
  20031c:	aa0403e5 	mov	x5, x4
  200320:	d2807e82 	mov	x2, #0x3f4                 	// #1012
  200324:	17ffff6f 	b	2000e0 <hashtable_init+0xc0>
  200328:	aa0403e5 	mov	x5, x4
  20032c:	d2807e62 	mov	x2, #0x3f3                 	// #1011
  200330:	17ffff6c 	b	2000e0 <hashtable_init+0xc0>
  200334:	d503201f 	nop
  200338:	d503201f 	nop
  20033c:	d503201f 	nop

0000000000200340 <hashtable_insert>:
#include "routing.h"
  200340:	12002428 	and	w8, w1, #0x3ff
__attribute__((__section__(".net2_client_config"))) net_client_config_t net2_config;

uintptr_t arp_region;
hashtable_t arp_table;
  200344:	2a0803e3 	mov	w3, w8
uintptr_t routing_region;
routing_entry_t *routing_table;

/* Booleans to indicate whether packets have been enqueued during notification handling */
  200348:	14000007 	b	200364 <hashtable_insert+0x24>
static bool notify_tx;
  20034c:	b8666804 	ldr	w4, [x0, x6]
  200350:	6b01009f 	cmp	w4, w1
  200354:	540003a0 	b.eq	2003c8 <hashtable_insert+0x88>  // b.none
static bool notify_rx;

net_queue_handle_t virt_rx_queue;
net_queue_handle_t virt_tx_queue;

  200358:	120024e3 	and	w3, w7, #0x3ff
/* This queue will hold packets that we need to generate an ARP request for. */
  20035c:	6b03011f 	cmp	w8, w3
  200360:	54000320 	b.eq	2003c4 <hashtable_insert+0x84>  // b.none
/* Booleans to indicate whether packets have been enqueued during notification handling */
  200364:	2a0303e5 	mov	w5, w3

  200368:	11000467 	add	w7, w3, #0x1
/* Booleans to indicate whether packets have been enqueued during notification handling */
  20036c:	8b050004 	add	x4, x0, x5
  200370:	91401084 	add	x4, x4, #0x4, lsl #12
static bool notify_tx;
  200374:	d37ceca6 	lsl	x6, x5, #4
/* Booleans to indicate whether packets have been enqueued during notification handling */
  200378:	39400084 	ldrb	w4, [x4]
  20037c:	35fffe84 	cbnz	w4, 20034c <hashtable_insert+0xc>
packets in the arp_waiting queue. */
arp_queue_handle_t arp_queries;

/* @kwinter: For now, we are just going to have one packet waiting on an ARP reply for this
    PoC. */
routing_queue_node_t waiting_packet = {0};
  200380:	d2800084 	mov	x4, #0x4                   	// #4
    PoC. */
  200384:	aa0603e7 	mov	x7, x6
routing_queue_node_t waiting_packet = {0};
  200388:	8b235083 	add	x3, x4, w3, uxtw #4
  20038c:	91000444 	add	x4, x2, #0x1
  200390:	8b030006 	add	x6, x0, x3
  200394:	aa0200c8 	orr	x8, x6, x2
    PoC. */
  200398:	b8276801 	str	w1, [x0, x7]

static inline void *sddf_memcpy(void *dest, const void *src, size_t n)
{
    unsigned char *to = dest;
    const unsigned char *from = src;
    while (n-- > 0) {
  20039c:	cb0400c1 	sub	x1, x6, x4
  2003a0:	f2400d1f 	tst	x8, #0xf
  2003a4:	fa4e0820 	ccmp	x1, #0xe, #0x0, eq	// eq = none
  2003a8:	54000289 	b.ls	2003f8 <hashtable_insert+0xb8>  // b.plast
        *to++ = *from++;
  2003ac:	3dc00040 	ldr	q0, [x2]
  2003b0:	3ca36800 	str	q0, [x0, x3]
    }

    // Insert the new entry
    table->entries[index].key = key;
    sddf_memcpy(&table->entries[index].value, value, sizeof(entry_t));
    table->used[index] = 1;  // Mark this slot as used
  2003b4:	8b050000 	add	x0, x0, x5
  2003b8:	91401000 	add	x0, x0, #0x4, lsl #12
  2003bc:	52800021 	mov	w1, #0x1                   	// #1
  2003c0:	39000001 	strb	w1, [x0]
}
  2003c4:	d65f03c0 	ret
            sddf_memcpy(&table->entries[index].value, value, sizeof(entry_t));
  2003c8:	d2800081 	mov	x1, #0x4                   	// #4
  2003cc:	91000444 	add	x4, x2, #0x1
  2003d0:	8b235023 	add	x3, x1, w3, uxtw #4
  2003d4:	8b030001 	add	x1, x0, x3
    while (n-- > 0) {
  2003d8:	aa020025 	orr	x5, x1, x2
  2003dc:	cb040024 	sub	x4, x1, x4
  2003e0:	f2400cbf 	tst	x5, #0xf
  2003e4:	fa4e0880 	ccmp	x4, #0xe, #0x0, eq	// eq = none
  2003e8:	540004a9 	b.ls	20047c <hashtable_insert+0x13c>  // b.plast
        *to++ = *from++;
  2003ec:	3dc00040 	ldr	q0, [x2]
  2003f0:	3ca36800 	str	q0, [x0, x3]
}
  2003f4:	d65f03c0 	ret
  2003f8:	39400041 	ldrb	w1, [x2]
  2003fc:	38236801 	strb	w1, [x0, x3]
  200400:	39400441 	ldrb	w1, [x2, #1]
  200404:	390004c1 	strb	w1, [x6, #1]
  200408:	39400841 	ldrb	w1, [x2, #2]
  20040c:	390008c1 	strb	w1, [x6, #2]
  200410:	39400c41 	ldrb	w1, [x2, #3]
  200414:	39000cc1 	strb	w1, [x6, #3]
  200418:	39401041 	ldrb	w1, [x2, #4]
  20041c:	390010c1 	strb	w1, [x6, #4]
  200420:	39401441 	ldrb	w1, [x2, #5]
  200424:	390014c1 	strb	w1, [x6, #5]
  200428:	39401841 	ldrb	w1, [x2, #6]
  20042c:	390018c1 	strb	w1, [x6, #6]
  200430:	39401c41 	ldrb	w1, [x2, #7]
  200434:	39001cc1 	strb	w1, [x6, #7]
  200438:	39402041 	ldrb	w1, [x2, #8]
  20043c:	390020c1 	strb	w1, [x6, #8]
  200440:	39402441 	ldrb	w1, [x2, #9]
  200444:	390024c1 	strb	w1, [x6, #9]
  200448:	39402841 	ldrb	w1, [x2, #10]
  20044c:	390028c1 	strb	w1, [x6, #10]
  200450:	39402c41 	ldrb	w1, [x2, #11]
  200454:	39002cc1 	strb	w1, [x6, #11]
  200458:	39403041 	ldrb	w1, [x2, #12]
  20045c:	390030c1 	strb	w1, [x6, #12]
  200460:	39403441 	ldrb	w1, [x2, #13]
  200464:	390034c1 	strb	w1, [x6, #13]
  200468:	39403841 	ldrb	w1, [x2, #14]
  20046c:	390038c1 	strb	w1, [x6, #14]
  200470:	39403c41 	ldrb	w1, [x2, #15]
  200474:	39003cc1 	strb	w1, [x6, #15]
    while (n-- > 0) {
  200478:	17ffffcf 	b	2003b4 <hashtable_insert+0x74>
        *to++ = *from++;
  20047c:	39400044 	ldrb	w4, [x2]
  200480:	38236804 	strb	w4, [x0, x3]
  200484:	39400440 	ldrb	w0, [x2, #1]
  200488:	39000420 	strb	w0, [x1, #1]
  20048c:	39400840 	ldrb	w0, [x2, #2]
  200490:	39000820 	strb	w0, [x1, #2]
  200494:	39400c40 	ldrb	w0, [x2, #3]
  200498:	39000c20 	strb	w0, [x1, #3]
  20049c:	39401040 	ldrb	w0, [x2, #4]
  2004a0:	39001020 	strb	w0, [x1, #4]
  2004a4:	39401440 	ldrb	w0, [x2, #5]
  2004a8:	39001420 	strb	w0, [x1, #5]
  2004ac:	39401840 	ldrb	w0, [x2, #6]
  2004b0:	39001820 	strb	w0, [x1, #6]
  2004b4:	39401c40 	ldrb	w0, [x2, #7]
  2004b8:	39001c20 	strb	w0, [x1, #7]
  2004bc:	39402040 	ldrb	w0, [x2, #8]
  2004c0:	39002020 	strb	w0, [x1, #8]
  2004c4:	39402440 	ldrb	w0, [x2, #9]
  2004c8:	39002420 	strb	w0, [x1, #9]
  2004cc:	39402840 	ldrb	w0, [x2, #10]
  2004d0:	39002820 	strb	w0, [x1, #10]
  2004d4:	39402c40 	ldrb	w0, [x2, #11]
  2004d8:	39002c20 	strb	w0, [x1, #11]
  2004dc:	39403040 	ldrb	w0, [x2, #12]
  2004e0:	39003020 	strb	w0, [x1, #12]
  2004e4:	39403440 	ldrb	w0, [x2, #13]
  2004e8:	39003420 	strb	w0, [x1, #13]
  2004ec:	39403840 	ldrb	w0, [x2, #14]
  2004f0:	39003820 	strb	w0, [x1, #14]
  2004f4:	39403c40 	ldrb	w0, [x2, #15]
  2004f8:	39003c20 	strb	w0, [x1, #15]
  2004fc:	d65f03c0 	ret

0000000000200500 <hashtable_search>:
    return key % TABLE_SIZE;
  200500:	12002427 	and	w7, w1, #0x3ff
    uint32_t index = hash(key);
    uint32_t original_index = index;

    while (table->used[index]) {
        if (table->entries[index].key == key) {
            sddf_memcpy(value, &table->entries[index].value, sizeof(entry_t));
  200504:	d2800088 	mov	x8, #0x4                   	// #4
    uint32_t index = hash(key);
  200508:	2a0703e4 	mov	w4, w7
    while (table->used[index]) {
  20050c:	14000004 	b	20051c <hashtable_search+0x1c>
        }
        index = (index + 1) % TABLE_SIZE;
  200510:	120024c4 	and	w4, w6, #0x3ff
        if (index == original_index) {
  200514:	6b0400ff 	cmp	w7, w4
  200518:	54000600 	b.eq	2005d8 <hashtable_search+0xd8>  // b.none
    while (table->used[index]) {
  20051c:	2a0403e3 	mov	w3, w4
        index = (index + 1) % TABLE_SIZE;
  200520:	11000486 	add	w6, w4, #0x1
    while (table->used[index]) {
  200524:	8b030005 	add	x5, x0, x3
  200528:	914010a5 	add	x5, x5, #0x4, lsl #12
        if (table->entries[index].key == key) {
  20052c:	d37cec63 	lsl	x3, x3, #4
    while (table->used[index]) {
  200530:	394000a5 	ldrb	w5, [x5]
  200534:	34000525 	cbz	w5, 2005d8 <hashtable_search+0xd8>
        if (table->entries[index].key == key) {
  200538:	b8636803 	ldr	w3, [x0, x3]
  20053c:	6b01007f 	cmp	w3, w1
  200540:	54fffe81 	b.ne	200510 <hashtable_search+0x10>  // b.any
            sddf_memcpy(value, &table->entries[index].value, sizeof(entry_t));
  200544:	8b245104 	add	x4, x8, w4, uxtw #4
  200548:	8b040003 	add	x3, x0, x4
  20054c:	38646804 	ldrb	w4, [x0, x4]
  200550:	39000044 	strb	w4, [x2]
  200554:	39400464 	ldrb	w4, [x3, #1]
  200558:	39000444 	strb	w4, [x2, #1]
  20055c:	39400864 	ldrb	w4, [x3, #2]
  200560:	39000844 	strb	w4, [x2, #2]
  200564:	39400c64 	ldrb	w4, [x3, #3]
  200568:	39000c44 	strb	w4, [x2, #3]
  20056c:	39401064 	ldrb	w4, [x3, #4]
  200570:	39001044 	strb	w4, [x2, #4]
  200574:	39401464 	ldrb	w4, [x3, #5]
  200578:	39001444 	strb	w4, [x2, #5]
  20057c:	39401864 	ldrb	w4, [x3, #6]
  200580:	39001844 	strb	w4, [x2, #6]
  200584:	39401c64 	ldrb	w4, [x3, #7]
  200588:	39001c44 	strb	w4, [x2, #7]
  20058c:	39402064 	ldrb	w4, [x3, #8]
  200590:	39002044 	strb	w4, [x2, #8]
  200594:	39402464 	ldrb	w4, [x3, #9]
  200598:	39002444 	strb	w4, [x2, #9]
  20059c:	39402864 	ldrb	w4, [x3, #10]
  2005a0:	39002844 	strb	w4, [x2, #10]
  2005a4:	39402c64 	ldrb	w4, [x3, #11]
  2005a8:	39002c44 	strb	w4, [x2, #11]
  2005ac:	39403064 	ldrb	w4, [x3, #12]
  2005b0:	39003044 	strb	w4, [x2, #12]
  2005b4:	39403464 	ldrb	w4, [x3, #13]
  2005b8:	39003444 	strb	w4, [x2, #13]
  2005bc:	39403864 	ldrb	w4, [x3, #14]
  2005c0:	39003844 	strb	w4, [x2, #14]
        index = (index + 1) % TABLE_SIZE;
  2005c4:	120024c4 	and	w4, w6, #0x3ff
        if (index == original_index) {
  2005c8:	6b0400ff 	cmp	w7, w4
  2005cc:	39403c63 	ldrb	w3, [x3, #15]
  2005d0:	39003c43 	strb	w3, [x2, #15]
  2005d4:	54fffa41 	b.ne	20051c <hashtable_search+0x1c>  // b.any
            // Full cycle completed, element not found
            break;
        }
    }
    value = NULL;  // Not found
}
  2005d8:	d65f03c0 	ret
  2005dc:	d503201f 	nop

00000000002005e0 <hashtable_remove>:
    return key % TABLE_SIZE;
  2005e0:	12002426 	and	w6, w1, #0x3ff

// Remove a key-value pair from the hash table
void hashtable_remove(hashtable_t *table, uint32_t key) {
    uint32_t index = hash(key);
  2005e4:	2a0603e2 	mov	w2, w6
    uint32_t original_index = index;

    while (table->used[index]) {
  2005e8:	14000006 	b	200600 <hashtable_remove+0x20>
        if (table->entries[index].key == key) {
  2005ec:	b8636803 	ldr	w3, [x0, x3]
  2005f0:	6b01007f 	cmp	w3, w1
  2005f4:	54000180 	b.eq	200624 <hashtable_remove+0x44>  // b.none
            // Mark the slot as unused and clear the entry
            table->used[index] = 0;
            return;
        }
        index = (index + 1) % TABLE_SIZE;
        if (index == original_index) {
  2005f8:	6b0200df 	cmp	w6, w2
  2005fc:	54000120 	b.eq	200620 <hashtable_remove+0x40>  // b.none
    while (table->used[index]) {
  200600:	2a0203e3 	mov	w3, w2
        index = (index + 1) % TABLE_SIZE;
  200604:	11000442 	add	w2, w2, #0x1
    while (table->used[index]) {
  200608:	8b030004 	add	x4, x0, x3
        index = (index + 1) % TABLE_SIZE;
  20060c:	12002442 	and	w2, w2, #0x3ff
    while (table->used[index]) {
  200610:	91401084 	add	x4, x4, #0x4, lsl #12
        if (table->entries[index].key == key) {
  200614:	d37cec63 	lsl	x3, x3, #4
    while (table->used[index]) {
  200618:	39400085 	ldrb	w5, [x4]
  20061c:	35fffe85 	cbnz	w5, 2005ec <hashtable_remove+0xc>
            // Full cycle completed, element not found
            break;
        }
    }
  200620:	d65f03c0 	ret
            table->used[index] = 0;
  200624:	3900009f 	strb	wzr, [x4]
  200628:	d65f03c0 	ret
  20062c:	d503201f 	nop

0000000000200630 <process_arp_waiting>:
}

// @kwinter: Want a better way of doing this process. We seem to be doing alot of duplicate
// work.
void process_arp_waiting()
{
  200630:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  200634:	910003fd 	mov	x29, sp
  200638:	a90153f3 	stp	x19, x20, [sp, #16]
 *
 * @return true indicates the queue is empty, false otherwise.
 */
static inline bool arp_queue_empty_response(arp_queue_handle_t *queue)
{
    return queue->response.tail - queue->response.head == 0;
  20063c:	90000033 	adrp	x19, 204000 <__sel4_ipc_buffer>
  200640:	91064273 	add	x19, x19, #0x190
  200644:	79700a66 	ldrh	w6, [x19, #6148]
  200648:	79700e61 	ldrh	w1, [x19, #6150]
    /* Loop through all of the ARP responses. If there are any invalid
    responses we will drop the packets associated with the IP address. Otherwise
    we will substitute the MAC address in, and then send the packet out of the NIC. */

    while (!arp_queue_empty_response(&arp_queries)) {
  20064c:	6b0100df 	cmp	w6, w1
  200650:	54000780 	b.eq	200740 <process_arp_waiting+0x110>  // b.none
  200654:	90000034 	adrp	x20, 204000 <__sel4_ipc_buffer>
  200658:	91050294 	add	x20, x20, #0x140
  20065c:	a9025bf5 	stp	x21, x22, [sp, #32]
                net_buff_desc_t *buffer = waiting_packet.buffer;
                if (buffer->io_or_offset == 0) {
                    sddf_dprintf("ROUTING|Error restoring buffer in process_arp_waiting()\n");
                    return;
                }
                struct ipv4_packet *pkt = (struct ipv4_packet *)(net1_config.rx_data.vaddr + buffer->io_or_offset);
  200660:	90000036 	adrp	x22, 204000 <__sel4_ipc_buffer>
  200664:	910022d6 	add	x22, x22, #0x8
            sddf_dprintf("ROUTING|No packet waiting on ARP reply!\n");
  200668:	f0000015 	adrp	x21, 203000 <_vsnprintf+0xc00>
  20066c:	911742b5 	add	x21, x21, #0x5d0
  200670:	f9001bf7 	str	x23, [sp, #48]
{
    if (arp_queue_empty_response(queue)) {
        return -1;
    }

    arp_request_t resp = queue->response.queue[queue->response.head % queue->capacity];
  200674:	52800197 	mov	w23, #0xc                   	// #12
  200678:	14000014 	b	2006c8 <process_arp_waiting+0x98>
 *
 * @return true indicates the queue is full, false otherwise.
 */
static inline bool net_queue_full_free(net_queue_handle_t *queue)
{
    return queue->free->tail - queue->free->head == queue->capacity;
  20067c:	a9408a85 	ldp	x5, x2, [x20, #8]
  200680:	b9402284 	ldr	w4, [x20, #32]
  200684:	79400043 	ldrh	w3, [x2]
  200688:	79400440 	ldrh	w0, [x2, #2]
            buffer->len = 0;
  20068c:	790010bf 	strh	wzr, [x5, #8]

    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
#ifdef CONFIG_ENABLE_SMP_SUPPORT
    THREAD_MEMORY_RELEASE();
#endif
    queue->free->tail++;
  200690:	11000467 	add	w7, w3, #0x1
    return queue->free->tail - queue->free->head == queue->capacity;
  200694:	4b000060 	sub	w0, w3, w0
  200698:	f94000a5 	ldr	x5, [x5]
    if (net_queue_full_free(queue)) {
  20069c:	6b04001f 	cmp	w0, w4
  2006a0:	540006e0 	b.eq	20077c <process_arp_waiting+0x14c>  // b.none
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  2006a4:	1ac40860 	udiv	w0, w3, w4
    return queue->response.tail - queue->response.head == 0;
  2006a8:	79700a66 	ldrh	w6, [x19, #6148]
  2006ac:	1b048c00 	msub	w0, w0, w4, w3
  2006b0:	8b001040 	add	x0, x2, x0, lsl #4
  2006b4:	f9000405 	str	x5, [x0, #8]
  2006b8:	7900201f 	strh	wzr, [x0, #16]
    queue->free->tail++;
  2006bc:	79000047 	strh	w7, [x2]
    while (!arp_queue_empty_response(&arp_queries)) {
  2006c0:	6b0100df 	cmp	w6, w1
  2006c4:	540003a0 	b.eq	200738 <process_arp_waiting+0x108>  // b.none
    arp_request_t resp = queue->response.queue[queue->response.head % queue->capacity];
  2006c8:	b9700a62 	ldr	w2, [x19, #12296]
  2006cc:	d2830104 	mov	x4, #0x1808                	// #6152
        if (!waiting_packet.valid) {
  2006d0:	39401283 	ldrb	w3, [x20, #4]
    sddf_memcpy(response, &resp, sizeof(arp_request_t));

    queue->response.head++;
  2006d4:	11000425 	add	w5, w1, #0x1
    arp_request_t resp = queue->response.queue[queue->response.head % queue->capacity];
  2006d8:	1ac20820 	udiv	w0, w1, w2
  2006dc:	1b028400 	msub	w0, w0, w2, w1
    queue->response.head++;
  2006e0:	12003ca1 	and	w1, w5, #0xffff
    arp_request_t resp = queue->response.queue[queue->response.head % queue->capacity];
  2006e4:	9bb71000 	umaddl	x0, w0, w23, x4
  2006e8:	8b000262 	add	x2, x19, x0
  2006ec:	b8606a64 	ldr	w4, [x19, x0]
  2006f0:	79401045 	ldrh	w5, [x2, #8]
  2006f4:	39402840 	ldrb	w0, [x2, #10]
  2006f8:	b9400447 	ldr	w7, [x2, #4]
    queue->response.head++;
  2006fc:	79300e61 	strh	w1, [x19, #6150]
  200700:	34000263 	cbz	w3, 20074c <process_arp_waiting+0x11c>
        if (!response.valid) {
  200704:	34fffbc0 	cbz	w0, 20067c <process_arp_waiting+0x4c>
            if (response.ip_addr == waiting_packet.ip) {
  200708:	b9400280 	ldr	w0, [x20]
  20070c:	6b04001f 	cmp	w0, w4
  200710:	54fffd81 	b.ne	2006c0 <process_arp_waiting+0x90>  // b.any
                if (buffer->io_or_offset == 0) {
  200714:	f9400680 	ldr	x0, [x20, #8]
  200718:	f9400000 	ldr	x0, [x0]
  20071c:	b4000220 	cbz	x0, 200760 <process_arp_waiting+0x130>
                struct ipv4_packet *pkt = (struct ipv4_packet *)(net1_config.rx_data.vaddr + buffer->io_or_offset);
  200720:	f9401ac2 	ldr	x2, [x22, #48]
    while (!arp_queue_empty_response(&arp_queries)) {
  200724:	6b0100df 	cmp	w6, w1
                struct ipv4_packet *pkt = (struct ipv4_packet *)(net1_config.rx_data.vaddr + buffer->io_or_offset);
  200728:	8b000043 	add	x3, x2, x0
                    // We should have the mac address. Replace the dest in the ethernet header.
                    for (int i = 0; i < ETH_HWADDR_LEN; i++) {
                        pkt->ethdst_addr[i] = response.mac_addr[i];
  20072c:	b8206847 	str	w7, [x2, x0]
  200730:	79000865 	strh	w5, [x3, #4]
    while (!arp_queue_empty_response(&arp_queries)) {
  200734:	54fffca1 	b.ne	2006c8 <process_arp_waiting+0x98>  // b.any
  200738:	a9425bf5 	ldp	x21, x22, [sp, #32]
  20073c:	f9401bf7 	ldr	x23, [sp, #48]

            }
        }
    }

}
  200740:	a94153f3 	ldp	x19, x20, [sp, #16]
  200744:	a8c47bfd 	ldp	x29, x30, [sp], #64
  200748:	d65f03c0 	ret
            sddf_dprintf("ROUTING|No packet waiting on ARP reply!\n");
  20074c:	aa1503e0 	mov	x0, x21
  200750:	94000a7c 	bl	203140 <sddf_printf_>
    return queue->response.tail - queue->response.head == 0;
  200754:	79700a66 	ldrh	w6, [x19, #6148]
  200758:	79700e61 	ldrh	w1, [x19, #6150]
  20075c:	17ffffd9 	b	2006c0 <process_arp_waiting+0x90>
}
  200760:	a94153f3 	ldp	x19, x20, [sp, #16]
                    sddf_dprintf("ROUTING|Error restoring buffer in process_arp_waiting()\n");
  200764:	f0000000 	adrp	x0, 203000 <_vsnprintf+0xc00>
  200768:	91192000 	add	x0, x0, #0x648
  20076c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  200770:	f9401bf7 	ldr	x23, [sp, #48]
}
  200774:	a8c47bfd 	ldp	x29, x30, [sp], #64
                    sddf_dprintf("ROUTING|Error restoring buffer in process_arp_waiting()\n");
  200778:	14000a72 	b	203140 <sddf_printf_>
            assert(!err);
  20077c:	f0000003 	adrp	x3, 203000 <_vsnprintf+0xc00>
  200780:	f0000001 	adrp	x1, 203000 <_vsnprintf+0xc00>
  200784:	9112e063 	add	x3, x3, #0x4b8
  200788:	91180021 	add	x1, x1, #0x600
  20078c:	f0000000 	adrp	x0, 203000 <_vsnprintf+0xc00>
  200790:	52800d82 	mov	w2, #0x6c                  	// #108
  200794:	91190000 	add	x0, x0, #0x640
  200798:	94000b26 	bl	203430 <_assert_fail>
  20079c:	79700a66 	ldrh	w6, [x19, #6148]
  2007a0:	79700e61 	ldrh	w1, [x19, #6150]
  2007a4:	17ffffc7 	b	2006c0 <process_arp_waiting+0x90>
  2007a8:	d503201f 	nop
  2007ac:	d503201f 	nop

00000000002007b0 <find_route>:
uint32_t find_route(uint32_t ip)
{
    // TODO: extend this function to match with the longest subnet mask,
    // and if tied in this step, find the route with the least hops.
    for (int i = 0; i < NUM_ROUTES; i++) {
        if ((ip & routing_table[i].subnet_mask) == (routing_table[i].network_id & routing_table[i].subnet_mask)) {
  2007b0:	90000021 	adrp	x1, 204000 <__sel4_ipc_buffer>
  2007b4:	f940b421 	ldr	x1, [x1, #360]
{
  2007b8:	2a0003e2 	mov	w2, w0
        if ((ip & routing_table[i].subnet_mask) == (routing_table[i].network_id & routing_table[i].subnet_mask)) {
  2007bc:	29400c20 	ldp	w0, w3, [x1]
  2007c0:	4a000040 	eor	w0, w2, w0
  2007c4:	6a03001f 	tst	w0, w3
  2007c8:	54000640 	b.eq	200890 <find_route+0xe0>  // b.none
  2007cc:	29419020 	ldp	w0, w4, [x1, #12]
  2007d0:	91003023 	add	x3, x1, #0xc
  2007d4:	4a000040 	eor	w0, w2, w0
  2007d8:	6a04001f 	tst	w0, w4
  2007dc:	54000580 	b.eq	20088c <find_route+0xdc>  // b.none
  2007e0:	29431020 	ldp	w0, w4, [x1, #24]
  2007e4:	91006023 	add	x3, x1, #0x18
  2007e8:	4a000040 	eor	w0, w2, w0
  2007ec:	6a04001f 	tst	w0, w4
  2007f0:	540004e0 	b.eq	20088c <find_route+0xdc>  // b.none
  2007f4:	29449020 	ldp	w0, w4, [x1, #36]
  2007f8:	91009023 	add	x3, x1, #0x24
  2007fc:	4a000040 	eor	w0, w2, w0
  200800:	6a04001f 	tst	w0, w4
  200804:	54000440 	b.eq	20088c <find_route+0xdc>  // b.none
  200808:	29461020 	ldp	w0, w4, [x1, #48]
  20080c:	9100c023 	add	x3, x1, #0x30
  200810:	4a000040 	eor	w0, w2, w0
  200814:	6a04001f 	tst	w0, w4
  200818:	540003a0 	b.eq	20088c <find_route+0xdc>  // b.none
  20081c:	29479020 	ldp	w0, w4, [x1, #60]
  200820:	9100f023 	add	x3, x1, #0x3c
  200824:	4a000040 	eor	w0, w2, w0
  200828:	6a04001f 	tst	w0, w4
  20082c:	54000300 	b.eq	20088c <find_route+0xdc>  // b.none
  200830:	29491020 	ldp	w0, w4, [x1, #72]
  200834:	91012023 	add	x3, x1, #0x48
  200838:	4a000040 	eor	w0, w2, w0
  20083c:	6a04001f 	tst	w0, w4
  200840:	54000260 	b.eq	20088c <find_route+0xdc>  // b.none
  200844:	294a9020 	ldp	w0, w4, [x1, #84]
  200848:	91015023 	add	x3, x1, #0x54
  20084c:	4a000040 	eor	w0, w2, w0
  200850:	6a04001f 	tst	w0, w4
  200854:	540001c0 	b.eq	20088c <find_route+0xdc>  // b.none
  200858:	294c1020 	ldp	w0, w4, [x1, #96]
  20085c:	91018023 	add	x3, x1, #0x60
  200860:	4a000040 	eor	w0, w2, w0
  200864:	6a04001f 	tst	w0, w4
  200868:	54000120 	b.eq	20088c <find_route+0xdc>  // b.none
  20086c:	9101b023 	add	x3, x1, #0x6c
  200870:	b9406c21 	ldr	w1, [x1, #108]
            return routing_table[i].next_hop;
        }
    }

    // If we have gotten here, assume on the default gateway.
    return 0;
  200874:	52800000 	mov	w0, #0x0                   	// #0
        if ((ip & routing_table[i].subnet_mask) == (routing_table[i].network_id & routing_table[i].subnet_mask)) {
  200878:	4a010042 	eor	w2, w2, w1
  20087c:	b9400461 	ldr	w1, [x3, #4]
  200880:	6a01005f 	tst	w2, w1
  200884:	54000040 	b.eq	20088c <find_route+0xdc>  // b.none
}
  200888:	d65f03c0 	ret
        if ((ip & routing_table[i].subnet_mask) == (routing_table[i].network_id & routing_table[i].subnet_mask)) {
  20088c:	aa0303e1 	mov	x1, x3
            return routing_table[i].next_hop;
  200890:	b9400820 	ldr	w0, [x1, #8]
}
  200894:	d65f03c0 	ret
  200898:	d503201f 	nop
  20089c:	d503201f 	nop

00000000002008a0 <route>:

void route()
{
  2008a0:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  2008a4:	52800000 	mov	w0, #0x0                   	// #0
  2008a8:	910003fd 	mov	x29, sp
  2008ac:	a90153f3 	stp	x19, x20, [sp, #16]
    return queue->active->tail - queue->active->head == 0;
  2008b0:	90000033 	adrp	x19, 204000 <__sel4_ipc_buffer>
  2008b4:	91050273 	add	x19, x19, #0x140
  2008b8:	a9025bf5 	stp	x21, x22, [sp, #32]
  2008bc:	52800016 	mov	w22, #0x0                   	// #0
  2008c0:	33001c16 	bfxil	w22, w0, #0, #8
  2008c4:	f9400e63 	ldr	x3, [x19, #24]
  2008c8:	33181c16 	bfi	w22, w0, #8, #8
  2008cc:	79400462 	ldrh	w2, [x3, #2]
    // Check the IP address of the packet.
    bool transmitted = false;
    bool reprocess = true;
    while (reprocess) {
        while (!net_queue_empty_active(&virt_rx_queue)) {
  2008d0:	79400060 	ldrh	w0, [x3]
  2008d4:	6b02001f 	cmp	w0, w2
  2008d8:	54000560 	b.eq	200984 <route+0xe4>  // b.none
  2008dc:	90000034 	adrp	x20, 204000 <__sel4_ipc_buffer>
  2008e0:	91002294 	add	x20, x20, #0x8
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  2008e4:	d2800115 	mov	x21, #0x8                   	// #8
  2008e8:	a90363f7 	stp	x23, x24, [sp, #48]
  2008ec:	d503201f 	nop
{
    if (net_queue_empty_active(queue)) {
        return -1;
    }

    *buffer = queue->active->buffers[queue->active->head % queue->capacity];
  2008f0:	b9402261 	ldr	w1, [x19, #32]
            net_buff_desc_t buffer;
            int err = net_dequeue_active(&virt_rx_queue, &buffer);
            assert(!err);

            struct ipv4_packet *pkt = (struct ethernet_header *)(net1_config.rx_data.vaddr + buffer.io_or_offset);
  2008f4:	f9401a85 	ldr	x5, [x20, #48]
#ifdef CONFIG_ENABLE_SMP_SUPPORT
    THREAD_MEMORY_RELEASE();
#endif
    queue->active->head++;
  2008f8:	11000446 	add	w6, w2, #0x1
    *buffer = queue->active->buffers[queue->active->head % queue->capacity];
  2008fc:	1ac10840 	udiv	w0, w2, w1
  200900:	1b018800 	msub	w0, w0, w1, w2
  200904:	8b001060 	add	x0, x3, x0, lsl #4
  200908:	f9400417 	ldr	x23, [x0, #8]
  20090c:	79402018 	ldrh	w24, [x0, #16]
  200910:	8b1700a4 	add	x4, x5, x23
    queue->active->head++;
  200914:	79000466 	strh	w6, [x3, #2]
             * the packet in this router.
             *
             * NOTE: We assume that if we get a packet other than an IPv4 packet, we drop.buffer
             * This edge case should be handled by a new protocol virtualiser.
             */
            if (pkt->ttl > 1 && pkt->type == ETH_TYPE_IP) {
  200918:	39405880 	ldrb	w0, [x4, #22]
  20091c:	7100041f 	cmp	w0, #0x1
  200920:	54000089 	b.ls	200930 <route+0x90>  // b.plast
  200924:	79401882 	ldrh	w2, [x4, #12]
  200928:	7120005f 	cmp	w2, #0x800
  20092c:	54000360 	b.eq	200998 <route+0xf8>  // b.none
    return queue->free->tail - queue->free->head == queue->capacity;
  200930:	f9400a62 	ldr	x2, [x19, #16]
  200934:	91004278 	add	x24, x19, #0x10
  200938:	79400044 	ldrh	w4, [x2]
  20093c:	79400440 	ldrh	w0, [x2, #2]
  200940:	4b000080 	sub	w0, w4, w0
    if (net_queue_full_free(queue)) {
  200944:	6b01001f 	cmp	w0, w1
  200948:	54001e80 	b.eq	200d18 <route+0x478>  // b.none
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  20094c:	1ac10880 	udiv	w0, w4, w1
    queue->free->tail++;
  200950:	11000485 	add	w5, w4, #0x1
    return queue->active->tail - queue->active->head == 0;
  200954:	f9400703 	ldr	x3, [x24, #8]
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  200958:	1b019000 	msub	w0, w0, w1, w4
  20095c:	8b2052a0 	add	x0, x21, w0, uxtw #4
  200960:	8b000041 	add	x1, x2, x0
  200964:	f8206857 	str	x23, [x2, x0]
  200968:	7900103f 	strh	wzr, [x1, #8]
    queue->free->tail++;
  20096c:	79000045 	strh	w5, [x2]
    return queue->active->tail - queue->active->head == 0;
  200970:	79400462 	ldrh	w2, [x3, #2]
        while (!net_queue_empty_active(&virt_rx_queue)) {
  200974:	79400060 	ldrh	w0, [x3]
  200978:	6b02001f 	cmp	w0, w2
  20097c:	54fffba1 	b.ne	2008f0 <route+0x50>  // b.any
  200980:	a94363f7 	ldp	x23, x24, [sp, #48]
    if (transmitted && net_require_signal_active(&virt_tx_queue)) {
        net_cancel_signal_active(&virt_tx_queue);
        microkit_deferred_notify(net2_config.tx.id);
    }

}
  200984:	a94153f3 	ldp	x19, x20, [sp, #16]
  200988:	a9425bf5 	ldp	x21, x22, [sp, #32]
 *
 * @param queue queue handle of active queue that requires signalling upon enqueuing.
 */
static inline void net_request_signal_active(net_queue_handle_t *queue)
{
    queue->active->consumer_signalled = 0;
  20098c:	b900047f 	str	wzr, [x3, #4]
  200990:	a8c67bfd 	ldp	x29, x30, [sp], #96
  200994:	d65f03c0 	ret
        if ((ip & routing_table[i].subnet_mask) == (routing_table[i].network_id & routing_table[i].subnet_mask)) {
  200998:	f9401661 	ldr	x1, [x19, #40]
                pkt->ttl -= 1;
  20099c:	51000400 	sub	w0, w0, #0x1
  2009a0:	39005880 	strb	w0, [x4, #22]
                uint32_t destIP = pkt->dst_ip;
  2009a4:	b9402086 	ldr	w6, [x4, #32]
        if ((ip & routing_table[i].subnet_mask) == (routing_table[i].network_id & routing_table[i].subnet_mask)) {
  2009a8:	29400820 	ldp	w0, w2, [x1]
  2009ac:	4a0000c0 	eor	w0, w6, w0
  2009b0:	6a02001f 	tst	w0, w2
  2009b4:	54001120 	b.eq	200bd8 <route+0x338>  // b.none
  2009b8:	29418c20 	ldp	w0, w3, [x1, #12]
  2009bc:	91003022 	add	x2, x1, #0xc
  2009c0:	4a0000c0 	eor	w0, w6, w0
  2009c4:	6a03001f 	tst	w0, w3
  2009c8:	54001060 	b.eq	200bd4 <route+0x334>  // b.none
  2009cc:	29430c20 	ldp	w0, w3, [x1, #24]
  2009d0:	91006022 	add	x2, x1, #0x18
  2009d4:	4a0000c0 	eor	w0, w6, w0
  2009d8:	6a03001f 	tst	w0, w3
  2009dc:	54000fc0 	b.eq	200bd4 <route+0x334>  // b.none
  2009e0:	29448c20 	ldp	w0, w3, [x1, #36]
  2009e4:	91009022 	add	x2, x1, #0x24
  2009e8:	4a0000c0 	eor	w0, w6, w0
  2009ec:	6a03001f 	tst	w0, w3
  2009f0:	54000f20 	b.eq	200bd4 <route+0x334>  // b.none
  2009f4:	29460c20 	ldp	w0, w3, [x1, #48]
  2009f8:	9100c022 	add	x2, x1, #0x30
  2009fc:	4a0000c0 	eor	w0, w6, w0
  200a00:	6a03001f 	tst	w0, w3
  200a04:	54000e80 	b.eq	200bd4 <route+0x334>  // b.none
  200a08:	29478c20 	ldp	w0, w3, [x1, #60]
  200a0c:	9100f022 	add	x2, x1, #0x3c
  200a10:	4a0000c0 	eor	w0, w6, w0
  200a14:	6a03001f 	tst	w0, w3
  200a18:	54000de0 	b.eq	200bd4 <route+0x334>  // b.none
  200a1c:	29490c20 	ldp	w0, w3, [x1, #72]
  200a20:	91012022 	add	x2, x1, #0x48
  200a24:	4a0000c0 	eor	w0, w6, w0
  200a28:	6a03001f 	tst	w0, w3
  200a2c:	54000d40 	b.eq	200bd4 <route+0x334>  // b.none
  200a30:	294a8c20 	ldp	w0, w3, [x1, #84]
  200a34:	91015022 	add	x2, x1, #0x54
  200a38:	4a0000c0 	eor	w0, w6, w0
  200a3c:	6a03001f 	tst	w0, w3
  200a40:	54000ca0 	b.eq	200bd4 <route+0x334>  // b.none
  200a44:	294c0c20 	ldp	w0, w3, [x1, #96]
  200a48:	91018022 	add	x2, x1, #0x60
  200a4c:	4a0000c0 	eor	w0, w6, w0
  200a50:	6a03001f 	tst	w0, w3
  200a54:	54000c00 	b.eq	200bd4 <route+0x334>  // b.none
  200a58:	9101b022 	add	x2, x1, #0x6c
  200a5c:	294d8420 	ldp	w0, w1, [x1, #108]
  200a60:	4a0000c0 	eor	w0, w6, w0
  200a64:	6a01001f 	tst	w0, w1
  200a68:	54000b60 	b.eq	200bd4 <route+0x334>  // b.none
    return key % TABLE_SIZE;
  200a6c:	120024c8 	and	w8, w6, #0x3ff
    while (table->used[index]) {
  200a70:	f0000023 	adrp	x3, 207000 <__global_pointer$+0x27f8>
  200a74:	91070063 	add	x3, x3, #0x1c0
    uint32_t index = hash(key);
  200a78:	2a0803e1 	mov	w1, w8
    while (table->used[index]) {
  200a7c:	2a1603e9 	mov	w9, w22
  200a80:	5280000a 	mov	w10, #0x0                   	// #0
  200a84:	5280000b 	mov	w11, #0x0                   	// #0
            sddf_memcpy(value, &table->entries[index].value, sizeof(entry_t));
  200a88:	d280008c 	mov	x12, #0x4                   	// #4
    while (table->used[index]) {
  200a8c:	14000004 	b	200a9c <route+0x1fc>
        index = (index + 1) % TABLE_SIZE;
  200a90:	120024e1 	and	w1, w7, #0x3ff
        if (index == original_index) {
  200a94:	6b01011f 	cmp	w8, w1
  200a98:	54000280 	b.eq	200ae8 <route+0x248>  // b.none
    while (table->used[index]) {
  200a9c:	2a0103e0 	mov	w0, w1
        index = (index + 1) % TABLE_SIZE;
  200aa0:	11000427 	add	w7, w1, #0x1
    while (table->used[index]) {
  200aa4:	8b000062 	add	x2, x3, x0
  200aa8:	91401042 	add	x2, x2, #0x4, lsl #12
        if (table->entries[index].key == key) {
  200aac:	d37cec00 	lsl	x0, x0, #4
    while (table->used[index]) {
  200ab0:	39400042 	ldrb	w2, [x2]
  200ab4:	340001a2 	cbz	w2, 200ae8 <route+0x248>
        if (table->entries[index].key == key) {
  200ab8:	b8606860 	ldr	w0, [x3, x0]
  200abc:	6b0000df 	cmp	w6, w0
  200ac0:	54fffe81 	b.ne	200a90 <route+0x1f0>  // b.any
            sddf_memcpy(value, &table->entries[index].value, sizeof(entry_t));
  200ac4:	8b215181 	add	x1, x12, w1, uxtw #4
  200ac8:	5280002b 	mov	w11, #0x1                   	// #1
  200acc:	8b010061 	add	x1, x3, x1
  200ad0:	79401029 	ldrh	w9, [x1, #8]
  200ad4:	b940042a 	ldr	w10, [x1, #4]
        index = (index + 1) % TABLE_SIZE;
  200ad8:	120024e1 	and	w1, w7, #0x3ff
        if (index == original_index) {
  200adc:	6b01011f 	cmp	w8, w1
  200ae0:	54fffde1 	b.ne	200a9c <route+0x1fc>  // b.any
  200ae4:	d503201f 	nop
  200ae8:	3500006b 	cbnz	w11, 200af4 <route+0x254>
                        pkt->ethdst_addr[i] = hash_res.mac_addr[i];
  200aec:	794093e9 	ldrh	w9, [sp, #72]
  200af0:	b94047ea 	ldr	w10, [sp, #68]
  200af4:	b900008a 	str	w10, [x4]
  200af8:	79000889 	strh	w9, [x4, #4]
    return queue->free->tail - queue->free->head == 0;
  200afc:	f9401a61 	ldr	x1, [x19, #48]
  200b00:	79400422 	ldrh	w2, [x1, #2]
    if (net_queue_empty_free(queue)) {
  200b04:	79400023 	ldrh	w3, [x1]
  200b08:	6b02007f 	cmp	w3, w2
  200b0c:	54001240 	b.eq	200d54 <route+0x4b4>  // b.none
    *buffer = queue->free->buffers[queue->free->head % queue->capacity];
  200b10:	b9404263 	ldr	w3, [x19, #64]
    queue->free->head++;
  200b14:	11000444 	add	w4, w2, #0x1
    *buffer = queue->free->buffers[queue->free->head % queue->capacity];
  200b18:	1ac30840 	udiv	w0, w2, w3
  200b1c:	1b038800 	msub	w0, w0, w3, w2
  200b20:	8b001020 	add	x0, x1, x0, lsl #4
  200b24:	f9400417 	ldr	x23, [x0, #8]
  200b28:	79402018 	ldrh	w24, [x0, #16]
    queue->free->head++;
  200b2c:	79000424 	strh	w4, [x1, #2]
                    sddf_memcpy((net2_config.tx_data.vaddr + buffer_tx.io_or_offset), (net1_config.rx_data.vaddr + buffer.io_or_offset), buffer.len);
  200b30:	90000020 	adrp	x0, 204000 <__sel4_ipc_buffer>
  200b34:	f9407801 	ldr	x1, [x0, #240]
  200b38:	2a1803e4 	mov	w4, w24
  200b3c:	f9402be0 	ldr	x0, [sp, #80]
    while (n-- > 0) {
  200b40:	d1000486 	sub	x6, x4, #0x1
  200b44:	8b1700a2 	add	x2, x5, x23
  200b48:	8b000021 	add	x1, x1, x0
  200b4c:	b4000204 	cbz	x4, 200b8c <route+0x2ec>
  200b50:	f10038df 	cmp	x6, #0xe
  200b54:	54000de9 	b.ls	200d10 <route+0x470>  // b.plast
  200b58:	910006e0 	add	x0, x23, #0x1
  200b5c:	aa020023 	orr	x3, x1, x2
  200b60:	8b0000a5 	add	x5, x5, x0
  200b64:	d2800000 	mov	x0, #0x0                   	// #0
  200b68:	cb050025 	sub	x5, x1, x5
  200b6c:	f2400c7f 	tst	x3, #0xf
  200b70:	fa4e08a0 	ccmp	x5, #0xe, #0x0, eq	// eq = none
  200b74:	540003a8 	b.hi	200be8 <route+0x348>  // b.pmore
        *to++ = *from++;
  200b78:	38606843 	ldrb	w3, [x2, x0]
  200b7c:	38206823 	strb	w3, [x1, x0]
    while (n-- > 0) {
  200b80:	91000400 	add	x0, x0, #0x1
  200b84:	eb00009f 	cmp	x4, x0
  200b88:	54ffff81 	b.ne	200b78 <route+0x2d8>  // b.any
    return queue->active->tail - queue->active->head == queue->capacity;
  200b8c:	f9401e61 	ldr	x1, [x19, #56]
  200b90:	b9404263 	ldr	w3, [x19, #64]
  200b94:	79400022 	ldrh	w2, [x1]
  200b98:	79400420 	ldrh	w0, [x1, #2]
  200b9c:	4b000040 	sub	w0, w2, w0
    if (net_queue_full_active(queue)) {
  200ba0:	6b03001f 	cmp	w0, w3
  200ba4:	54000ee0 	b.eq	200d80 <route+0x4e0>  // b.none
    queue->active->buffers[queue->active->tail % queue->capacity] = buffer;
  200ba8:	1ac30840 	udiv	w0, w2, w3
  200bac:	d2800105 	mov	x5, #0x8                   	// #8
    queue->active->tail++;
  200bb0:	11000444 	add	w4, w2, #0x1
    queue->active->buffers[queue->active->tail % queue->capacity] = buffer;
  200bb4:	1b038800 	msub	w0, w0, w3, w2
  200bb8:	8b2050a0 	add	x0, x5, w0, uxtw #4
  200bbc:	8b000022 	add	x2, x1, x0
  200bc0:	f8206837 	str	x23, [x1, x0]
  200bc4:	79001058 	strh	w24, [x2, #8]
    queue->active->tail++;
  200bc8:	79000024 	strh	w4, [x1]
    return queue->free->tail - queue->free->head == queue->capacity;
  200bcc:	b9402261 	ldr	w1, [x19, #32]
  200bd0:	17ffff58 	b	200930 <route+0x90>
        if ((ip & routing_table[i].subnet_mask) == (routing_table[i].network_id & routing_table[i].subnet_mask)) {
  200bd4:	aa0203e1 	mov	x1, x2
            return routing_table[i].next_hop;
  200bd8:	b9400820 	ldr	w0, [x1, #8]
                if (nextIP == 0) {
  200bdc:	7100001f 	cmp	w0, #0x0
  200be0:	1a8000c6 	csel	w6, w6, w0, eq	// eq = none
  200be4:	17ffffa2 	b	200a6c <route+0x1cc>
  200be8:	d1004083 	sub	x3, x4, #0x10
  200bec:	d2800005 	mov	x5, #0x0                   	// #0
  200bf0:	d344fc63 	lsr	x3, x3, #4
  200bf4:	91000463 	add	x3, x3, #0x1
        *to++ = *from++;
  200bf8:	3ce06840 	ldr	q0, [x2, x0]
  200bfc:	910004a5 	add	x5, x5, #0x1
  200c00:	eb0300bf 	cmp	x5, x3
  200c04:	3ca06820 	str	q0, [x1, x0]
    while (n-- > 0) {
  200c08:	91004000 	add	x0, x0, #0x10
  200c0c:	54ffff63 	b.cc	200bf8 <route+0x358>  // b.lo, b.ul, b.last
  200c10:	d37cec63 	lsl	x3, x3, #4
  200c14:	eb03009f 	cmp	x4, x3
  200c18:	cb0300c0 	sub	x0, x6, x3
  200c1c:	8b030045 	add	x5, x2, x3
  200c20:	8b030024 	add	x4, x1, x3
  200c24:	54fffb40 	b.eq	200b8c <route+0x2ec>  // b.none
        *to++ = *from++;
  200c28:	38636842 	ldrb	w2, [x2, x3]
  200c2c:	38236822 	strb	w2, [x1, x3]
    while (n-- > 0) {
  200c30:	b4fffae0 	cbz	x0, 200b8c <route+0x2ec>
        *to++ = *from++;
  200c34:	394004a1 	ldrb	w1, [x5, #1]
    while (n-- > 0) {
  200c38:	f100041f 	cmp	x0, #0x1
        *to++ = *from++;
  200c3c:	39000481 	strb	w1, [x4, #1]
    while (n-- > 0) {
  200c40:	54fffa60 	b.eq	200b8c <route+0x2ec>  // b.none
        *to++ = *from++;
  200c44:	394008a1 	ldrb	w1, [x5, #2]
    while (n-- > 0) {
  200c48:	f100081f 	cmp	x0, #0x2
        *to++ = *from++;
  200c4c:	39000881 	strb	w1, [x4, #2]
    while (n-- > 0) {
  200c50:	54fff9e0 	b.eq	200b8c <route+0x2ec>  // b.none
        *to++ = *from++;
  200c54:	39400ca1 	ldrb	w1, [x5, #3]
    while (n-- > 0) {
  200c58:	f1000c1f 	cmp	x0, #0x3
        *to++ = *from++;
  200c5c:	39000c81 	strb	w1, [x4, #3]
    while (n-- > 0) {
  200c60:	54fff960 	b.eq	200b8c <route+0x2ec>  // b.none
        *to++ = *from++;
  200c64:	394010a1 	ldrb	w1, [x5, #4]
    while (n-- > 0) {
  200c68:	f100101f 	cmp	x0, #0x4
        *to++ = *from++;
  200c6c:	39001081 	strb	w1, [x4, #4]
    while (n-- > 0) {
  200c70:	54fff8e0 	b.eq	200b8c <route+0x2ec>  // b.none
        *to++ = *from++;
  200c74:	394014a1 	ldrb	w1, [x5, #5]
    while (n-- > 0) {
  200c78:	f100141f 	cmp	x0, #0x5
        *to++ = *from++;
  200c7c:	39001481 	strb	w1, [x4, #5]
    while (n-- > 0) {
  200c80:	54fff860 	b.eq	200b8c <route+0x2ec>  // b.none
        *to++ = *from++;
  200c84:	394018a1 	ldrb	w1, [x5, #6]
    while (n-- > 0) {
  200c88:	f100181f 	cmp	x0, #0x6
        *to++ = *from++;
  200c8c:	39001881 	strb	w1, [x4, #6]
    while (n-- > 0) {
  200c90:	54fff7e0 	b.eq	200b8c <route+0x2ec>  // b.none
        *to++ = *from++;
  200c94:	39401ca1 	ldrb	w1, [x5, #7]
    while (n-- > 0) {
  200c98:	f1001c1f 	cmp	x0, #0x7
        *to++ = *from++;
  200c9c:	39001c81 	strb	w1, [x4, #7]
    while (n-- > 0) {
  200ca0:	54fff760 	b.eq	200b8c <route+0x2ec>  // b.none
        *to++ = *from++;
  200ca4:	394020a1 	ldrb	w1, [x5, #8]
    while (n-- > 0) {
  200ca8:	f100201f 	cmp	x0, #0x8
        *to++ = *from++;
  200cac:	39002081 	strb	w1, [x4, #8]
    while (n-- > 0) {
  200cb0:	54fff6e0 	b.eq	200b8c <route+0x2ec>  // b.none
        *to++ = *from++;
  200cb4:	394024a1 	ldrb	w1, [x5, #9]
    while (n-- > 0) {
  200cb8:	f100241f 	cmp	x0, #0x9
        *to++ = *from++;
  200cbc:	39002481 	strb	w1, [x4, #9]
    while (n-- > 0) {
  200cc0:	54fff660 	b.eq	200b8c <route+0x2ec>  // b.none
        *to++ = *from++;
  200cc4:	394028a1 	ldrb	w1, [x5, #10]
    while (n-- > 0) {
  200cc8:	f100281f 	cmp	x0, #0xa
        *to++ = *from++;
  200ccc:	39002881 	strb	w1, [x4, #10]
    while (n-- > 0) {
  200cd0:	54fff5e0 	b.eq	200b8c <route+0x2ec>  // b.none
        *to++ = *from++;
  200cd4:	39402ca1 	ldrb	w1, [x5, #11]
    while (n-- > 0) {
  200cd8:	f1002c1f 	cmp	x0, #0xb
        *to++ = *from++;
  200cdc:	39002c81 	strb	w1, [x4, #11]
    while (n-- > 0) {
  200ce0:	54fff560 	b.eq	200b8c <route+0x2ec>  // b.none
        *to++ = *from++;
  200ce4:	394030a1 	ldrb	w1, [x5, #12]
    while (n-- > 0) {
  200ce8:	f100301f 	cmp	x0, #0xc
        *to++ = *from++;
  200cec:	39003081 	strb	w1, [x4, #12]
    while (n-- > 0) {
  200cf0:	54fff4e0 	b.eq	200b8c <route+0x2ec>  // b.none
        *to++ = *from++;
  200cf4:	394034a1 	ldrb	w1, [x5, #13]
    while (n-- > 0) {
  200cf8:	f100341f 	cmp	x0, #0xd
        *to++ = *from++;
  200cfc:	39003481 	strb	w1, [x4, #13]
    while (n-- > 0) {
  200d00:	54fff460 	b.eq	200b8c <route+0x2ec>  // b.none
        *to++ = *from++;
  200d04:	394038a0 	ldrb	w0, [x5, #14]
  200d08:	39003880 	strb	w0, [x4, #14]
    while (n-- > 0) {
  200d0c:	17ffffa0 	b	200b8c <route+0x2ec>
  200d10:	d2800000 	mov	x0, #0x0                   	// #0
  200d14:	17ffff99 	b	200b78 <route+0x2d8>
            assert(!err);
  200d18:	f0000003 	adrp	x3, 203000 <_vsnprintf+0xc00>
  200d1c:	9112e063 	add	x3, x3, #0x4b8
  200d20:	91006063 	add	x3, x3, #0x18
  200d24:	52801d02 	mov	w2, #0xe8                  	// #232
  200d28:	f0000001 	adrp	x1, 203000 <_vsnprintf+0xc00>
  200d2c:	f0000000 	adrp	x0, 203000 <_vsnprintf+0xc00>
  200d30:	91180021 	add	x1, x1, #0x600
  200d34:	91190000 	add	x0, x0, #0x640
  200d38:	940009be 	bl	203430 <_assert_fail>
    return queue->active->tail - queue->active->head == 0;
  200d3c:	f9400703 	ldr	x3, [x24, #8]
  200d40:	79400462 	ldrh	w2, [x3, #2]
        while (!net_queue_empty_active(&virt_rx_queue)) {
  200d44:	79400060 	ldrh	w0, [x3]
  200d48:	6b02001f 	cmp	w0, w2
  200d4c:	54ffdd21 	b.ne	2008f0 <route+0x50>  // b.any
  200d50:	17ffff0c 	b	200980 <route+0xe0>
                    assert(!err);
  200d54:	f0000003 	adrp	x3, 203000 <_vsnprintf+0xc00>
  200d58:	9112e063 	add	x3, x3, #0x4b8
  200d5c:	91006063 	add	x3, x3, #0x18
  200d60:	f0000001 	adrp	x1, 203000 <_vsnprintf+0xc00>
  200d64:	f0000000 	adrp	x0, 203000 <_vsnprintf+0xc00>
  200d68:	91180021 	add	x1, x1, #0x600
  200d6c:	91190000 	add	x0, x0, #0x640
  200d70:	52801b22 	mov	w2, #0xd9                  	// #217
  200d74:	940009af 	bl	203430 <_assert_fail>
                    sddf_memcpy((net2_config.tx_data.vaddr + buffer_tx.io_or_offset), (net1_config.rx_data.vaddr + buffer.io_or_offset), buffer.len);
  200d78:	f9401a85 	ldr	x5, [x20, #48]
  200d7c:	17ffff6d 	b	200b30 <route+0x290>
                    assert(!err);
  200d80:	f0000003 	adrp	x3, 203000 <_vsnprintf+0xc00>
  200d84:	9112e063 	add	x3, x3, #0x4b8
  200d88:	91006063 	add	x3, x3, #0x18
  200d8c:	f0000001 	adrp	x1, 203000 <_vsnprintf+0xc00>
  200d90:	f0000000 	adrp	x0, 203000 <_vsnprintf+0xc00>
  200d94:	91180021 	add	x1, x1, #0x600
  200d98:	91190000 	add	x0, x0, #0x640
  200d9c:	52801c22 	mov	w2, #0xe1                  	// #225
  200da0:	940009a4 	bl	203430 <_assert_fail>
    return queue->free->tail - queue->free->head == queue->capacity;
  200da4:	b9402261 	ldr	w1, [x19, #32]
  200da8:	17fffee2 	b	200930 <route+0x90>
  200dac:	d503201f 	nop

0000000000200db0 <init>:

void init(void)
{
  200db0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    sddf_dprintf("Initialising our routing component\n");
  200db4:	f0000000 	adrp	x0, 203000 <_vsnprintf+0xc00>
  200db8:	911a2000 	add	x0, x0, #0x688
{
  200dbc:	910003fd 	mov	x29, sp
  200dc0:	a9025bf5 	stp	x21, x22, [sp, #32]
    // Initialise the shared routing tables and zero them out.
    routing_table =  (routing_entry_t *) routing_region;
  200dc4:	90000035 	adrp	x21, 204000 <__sel4_ipc_buffer>
  200dc8:	910502b5 	add	x21, x21, #0x140
{
  200dcc:	a90153f3 	stp	x19, x20, [sp, #16]
    sddf_dprintf("Initialising our routing component\n");
  200dd0:	940008dc 	bl	203140 <sddf_printf_>
    sddf_dprintf("Router: attempting memset\n");
  200dd4:	f0000000 	adrp	x0, 203000 <_vsnprintf+0xc00>
  200dd8:	911ac000 	add	x0, x0, #0x6b0
    routing_table =  (routing_entry_t *) routing_region;
  200ddc:	f94026a1 	ldr	x1, [x21, #72]
  200de0:	f90016a1 	str	x1, [x21, #40]
    sddf_dprintf("Router: attempting memset\n");
  200de4:	940008d7 	bl	203140 <sddf_printf_>
    sddf_memset((void *) routing_region, 0, (sizeof(routing_entry_t) * NUM_ROUTES));
  200de8:	f94026a0 	ldr	x0, [x21, #72]
  200dec:	cb0003e1 	neg	x1, x0
    while (n-- > 0) {
  200df0:	f2400c23 	ands	x3, x1, #0xf
  200df4:	54001c60 	b.eq	201180 <init+0x3d0>  // b.none
        *p++ = c;
  200df8:	3900001f 	strb	wzr, [x0]
    while (n-- > 0) {
  200dfc:	aa0003e6 	mov	x6, x0
  200e00:	f27f083f 	tst	x1, #0xe
  200e04:	540018e0 	b.eq	201120 <init+0x370>  // b.none
        *p++ = c;
  200e08:	3900041f 	strb	wzr, [x0, #1]
    while (n-- > 0) {
  200e0c:	f100087f 	cmp	x3, #0x2
  200e10:	540018e9 	b.ls	20112c <init+0x37c>  // b.plast
        *p++ = c;
  200e14:	3900081f 	strb	wzr, [x0, #2]
    while (n-- > 0) {
  200e18:	f27e043f 	tst	x1, #0xc
  200e1c:	540019a0 	b.eq	201150 <init+0x3a0>  // b.none
        *p++ = c;
  200e20:	39000c1f 	strb	wzr, [x0, #3]
    while (n-- > 0) {
  200e24:	f100107f 	cmp	x3, #0x4
  200e28:	540019a9 	b.ls	20115c <init+0x3ac>  // b.plast
        *p++ = c;
  200e2c:	3900101f 	strb	wzr, [x0, #4]
    while (n-- > 0) {
  200e30:	f100147f 	cmp	x3, #0x5
  200e34:	54001b40 	b.eq	20119c <init+0x3ec>  // b.none
        *p++ = c;
  200e38:	3900141f 	strb	wzr, [x0, #5]
    while (n-- > 0) {
  200e3c:	f100187f 	cmp	x3, #0x6
  200e40:	54001500 	b.eq	2010e0 <init+0x330>  // b.none
        *p++ = c;
  200e44:	3900181f 	strb	wzr, [x0, #6]
    while (n-- > 0) {
  200e48:	36181b01 	tbz	w1, #3, 2011a8 <init+0x3f8>
        *p++ = c;
  200e4c:	39001c1f 	strb	wzr, [x0, #7]
    while (n-- > 0) {
  200e50:	f100207f 	cmp	x3, #0x8
  200e54:	54001c29 	b.ls	2011d8 <init+0x428>  // b.plast
        *p++ = c;
  200e58:	3900201f 	strb	wzr, [x0, #8]
    while (n-- > 0) {
  200e5c:	f100247f 	cmp	x3, #0x9
  200e60:	54001e00 	b.eq	201220 <init+0x470>  // b.none
        *p++ = c;
  200e64:	3900241f 	strb	wzr, [x0, #9]
    while (n-- > 0) {
  200e68:	f100287f 	cmp	x3, #0xa
  200e6c:	54001c80 	b.eq	2011fc <init+0x44c>  // b.none
        *p++ = c;
  200e70:	3900281f 	strb	wzr, [x0, #10]
    while (n-- > 0) {
  200e74:	f1002c7f 	cmp	x3, #0xb
  200e78:	54001f80 	b.eq	201268 <init+0x4b8>  // b.none
        *p++ = c;
  200e7c:	39002c1f 	strb	wzr, [x0, #11]
    while (n-- > 0) {
  200e80:	f100307f 	cmp	x3, #0xc
  200e84:	54002040 	b.eq	20128c <init+0x4dc>  // b.none
        *p++ = c;
  200e88:	3900301f 	strb	wzr, [x0, #12]
    while (n-- > 0) {
  200e8c:	f100347f 	cmp	x3, #0xd
  200e90:	54001da0 	b.eq	201244 <init+0x494>  // b.none
        *p++ = c;
  200e94:	3900341f 	strb	wzr, [x0, #13]
    while (n-- > 0) {
  200e98:	f1003c7f 	cmp	x3, #0xf
  200e9c:	540018c1 	b.ne	2011b4 <init+0x404>  // b.any
        *p++ = c;
  200ea0:	91003c01 	add	x1, x0, #0xf
    while (n-- > 0) {
  200ea4:	d2800d22 	mov	x2, #0x69                  	// #105
        *p++ = c;
  200ea8:	3900381f 	strb	wzr, [x0, #14]
    while (n-- > 0) {
  200eac:	8b030000 	add	x0, x0, x3
        *p++ = c;
  200eb0:	d2800f04 	mov	x4, #0x78                  	// #120
  200eb4:	cb030084 	sub	x4, x4, x3
  200eb8:	8b0300c3 	add	x3, x6, x3
    while (n-- > 0) {
  200ebc:	91004005 	add	x5, x0, #0x10
  200ec0:	d344fc87 	lsr	x7, x4, #4
        *p++ = c;
  200ec4:	a9007c7f 	stp	xzr, xzr, [x3]
  200ec8:	f1001cff 	cmp	x7, #0x7
  200ecc:	4f000400 	movi	v0.4s, #0x0
  200ed0:	3d8000a0 	str	q0, [x5]
  200ed4:	ad010000 	stp	q0, q0, [x0, #32]
  200ed8:	ad020000 	stp	q0, q0, [x0, #64]
    while (n-- > 0) {
  200edc:	540011c1 	b.ne	201114 <init+0x364>  // b.any
        *p++ = c;
  200ee0:	3d801800 	str	q0, [x0, #96]
    while (n-- > 0) {
  200ee4:	f101c09f 	cmp	x4, #0x70
  200ee8:	9101c020 	add	x0, x1, #0x70
  200eec:	d101c041 	sub	x1, x2, #0x70
  200ef0:	54000580 	b.eq	200fa0 <init+0x1f0>  // b.none
        *p++ = c;
  200ef4:	3900001f 	strb	wzr, [x0]
    while (n-- > 0) {
  200ef8:	f100043f 	cmp	x1, #0x1
  200efc:	54000520 	b.eq	200fa0 <init+0x1f0>  // b.none
        *p++ = c;
  200f00:	3900041f 	strb	wzr, [x0, #1]
    while (n-- > 0) {
  200f04:	f100083f 	cmp	x1, #0x2
  200f08:	540004c0 	b.eq	200fa0 <init+0x1f0>  // b.none
        *p++ = c;
  200f0c:	3900081f 	strb	wzr, [x0, #2]
    while (n-- > 0) {
  200f10:	f1000c3f 	cmp	x1, #0x3
  200f14:	54000460 	b.eq	200fa0 <init+0x1f0>  // b.none
        *p++ = c;
  200f18:	39000c1f 	strb	wzr, [x0, #3]
    while (n-- > 0) {
  200f1c:	f100103f 	cmp	x1, #0x4
  200f20:	54000400 	b.eq	200fa0 <init+0x1f0>  // b.none
        *p++ = c;
  200f24:	3900101f 	strb	wzr, [x0, #4]
    while (n-- > 0) {
  200f28:	f100143f 	cmp	x1, #0x5
  200f2c:	540003a0 	b.eq	200fa0 <init+0x1f0>  // b.none
        *p++ = c;
  200f30:	3900141f 	strb	wzr, [x0, #5]
    while (n-- > 0) {
  200f34:	f100183f 	cmp	x1, #0x6
  200f38:	54000340 	b.eq	200fa0 <init+0x1f0>  // b.none
        *p++ = c;
  200f3c:	3900181f 	strb	wzr, [x0, #6]
    while (n-- > 0) {
  200f40:	f1001c3f 	cmp	x1, #0x7
  200f44:	540002e0 	b.eq	200fa0 <init+0x1f0>  // b.none
        *p++ = c;
  200f48:	39001c1f 	strb	wzr, [x0, #7]
    while (n-- > 0) {
  200f4c:	f100203f 	cmp	x1, #0x8
  200f50:	54000280 	b.eq	200fa0 <init+0x1f0>  // b.none
        *p++ = c;
  200f54:	3900201f 	strb	wzr, [x0, #8]
    while (n-- > 0) {
  200f58:	f100243f 	cmp	x1, #0x9
  200f5c:	54000220 	b.eq	200fa0 <init+0x1f0>  // b.none
        *p++ = c;
  200f60:	3900241f 	strb	wzr, [x0, #9]
    while (n-- > 0) {
  200f64:	f100283f 	cmp	x1, #0xa
  200f68:	540001c0 	b.eq	200fa0 <init+0x1f0>  // b.none
        *p++ = c;
  200f6c:	3900281f 	strb	wzr, [x0, #10]
    while (n-- > 0) {
  200f70:	f1002c3f 	cmp	x1, #0xb
  200f74:	54000160 	b.eq	200fa0 <init+0x1f0>  // b.none
        *p++ = c;
  200f78:	39002c1f 	strb	wzr, [x0, #11]
    while (n-- > 0) {
  200f7c:	f100303f 	cmp	x1, #0xc
  200f80:	54000100 	b.eq	200fa0 <init+0x1f0>  // b.none
        *p++ = c;
  200f84:	3900301f 	strb	wzr, [x0, #12]
    while (n-- > 0) {
  200f88:	f100343f 	cmp	x1, #0xd
  200f8c:	540000a0 	b.eq	200fa0 <init+0x1f0>  // b.none
        *p++ = c;
  200f90:	3900341f 	strb	wzr, [x0, #13]
    while (n-- > 0) {
  200f94:	f100383f 	cmp	x1, #0xe
  200f98:	54000040 	b.eq	200fa0 <init+0x1f0>  // b.none
        *p++ = c;
  200f9c:	3900381f 	strb	wzr, [x0, #14]
    // The internal ARP component should initialise this region.
    sddf_dprintf("Router: Finished memseting\n");
  200fa0:	f0000000 	adrp	x0, 203000 <_vsnprintf+0xc00>
  200fa4:	911b4000 	add	x0, x0, #0x6d0
  200fa8:	94000866 	bl	203140 <sddf_printf_>
    // Init the hashtable here.
    hashtable_t *arp_table_vaddr = (hashtable_t*) router_config.router.arp_cache.vaddr;
  200fac:	90000020 	adrp	x0, 204000 <__sel4_ipc_buffer>
    arp_table = *arp_table_vaddr;
  200fb0:	f0000021 	adrp	x1, 207000 <__global_pointer$+0x27f8>
  200fb4:	91070023 	add	x3, x1, #0x1c0
  200fb8:	d2888002 	mov	x2, #0x4400                	// #17408
  200fbc:	f9409001 	ldr	x1, [x0, #288]
  200fc0:	aa0303e0 	mov	x0, x3
  200fc4:	9400019f 	bl	201640 <memcpy>
  200fc8:	aa0003e3 	mov	x3, x0
        table->used[i] = 0;  // Mark all slots as unused
  200fcc:	4f000400 	movi	v0.4s, #0x0
  200fd0:	d2888000 	mov	x0, #0x4400                	// #17408
  200fd4:	8b000061 	add	x1, x3, x0
  200fd8:	f0000040 	adrp	x0, 20b000 <arp_table+0x3e40>
  200fdc:	91070000 	add	x0, x0, #0x1c0
  200fe0:	3c810400 	str	q0, [x0], #16
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  200fe4:	eb01001f 	cmp	x0, x1
  200fe8:	54ffffc1 	b.ne	200fe0 <init+0x230>  // b.any
    hashtable_init(&arp_table);
    // Init all net queues here as well as zero out the arp cache.
    /* @kwinter: Need to add a struct to meta.py defining all the regions our routing
        component might want to have access to. */
    sddf_dprintf("Routing, intialise virt queues\n");
  200fec:	f0000000 	adrp	x0, 203000 <_vsnprintf+0xc00>
  200ff0:	911bc000 	add	x0, x0, #0x6f0
  200ff4:	94000853 	bl	203140 <sddf_printf_>
    net_queue_init(&virt_rx_queue, net1_config.rx.free_queue.vaddr, net1_config.rx.active_queue.vaddr,
                   net1_config.rx.num_buffers);
    net_queue_init(&virt_tx_queue, net2_config.tx.free_queue.vaddr, net2_config.tx.active_queue.vaddr,
  200ff8:	90000022 	adrp	x2, 204000 <__sel4_ipc_buffer>
  200ffc:	91022042 	add	x2, x2, #0x88
    net_queue_init(&virt_rx_queue, net1_config.rx.free_queue.vaddr, net1_config.rx.active_queue.vaddr,
  201000:	f0000000 	adrp	x0, 204000 <__sel4_ipc_buffer>
  201004:	91002000 	add	x0, x0, #0x8
    net_queue_init(&virt_tx_queue, net2_config.tx.free_queue.vaddr, net2_config.tx.active_queue.vaddr,
  201008:	7940c043 	ldrh	w3, [x2, #96]
    queue->free = free;
  20100c:	f9400406 	ldr	x6, [x0, #8]
    queue->capacity = capacity;
  201010:	b90042a3 	str	w3, [x21, #64]
    net_queue_init(&virt_rx_queue, net1_config.rx.free_queue.vaddr, net1_config.rx.active_queue.vaddr,
  201014:	f9400c01 	ldr	x1, [x0, #24]
    queue->active = active;
  201018:	a90106a6 	stp	x6, x1, [x21, #16]
  20101c:	79405000 	ldrh	w0, [x0, #40]
    net_queue_init(&virt_tx_queue, net2_config.tx.free_queue.vaddr, net2_config.tx.active_queue.vaddr,
  201020:	f9402041 	ldr	x1, [x2, #64]
    queue->capacity = capacity;
  201024:	b90022a0 	str	w0, [x21, #32]
  201028:	f9402842 	ldr	x2, [x2, #80]
    queue->active = active;
  20102c:	a9030aa1 	stp	x1, x2, [x21, #48]
    for (uint32_t i = 0; i < queue->capacity; i++) {
  201030:	340004c3 	cbz	w3, 2010c8 <init+0x318>
  201034:	52800014 	mov	w20, #0x0                   	// #0
  201038:	52800013 	mov	w19, #0x0                   	// #0
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  20103c:	d2800116 	mov	x22, #0x8                   	// #8
    return queue->free->tail - queue->free->head == queue->capacity;
  201040:	79400022 	ldrh	w2, [x1]
        net_buff_desc_t buffer = {(NET_BUFFER_SIZE * i) + base_addr, 0};
  201044:	2a1403e5 	mov	w5, w20
    return queue->free->tail - queue->free->head == queue->capacity;
  201048:	79400420 	ldrh	w0, [x1, #2]
    queue->free->tail++;
  20104c:	11000444 	add	w4, w2, #0x1
    return queue->free->tail - queue->free->head == queue->capacity;
  201050:	4b000040 	sub	w0, w2, w0
    if (net_queue_full_free(queue)) {
  201054:	6b03001f 	cmp	w0, w3
  201058:	540001c0 	b.eq	201090 <init+0x2e0>  // b.none
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  20105c:	1ac30840 	udiv	w0, w2, w3
    for (uint32_t i = 0; i < queue->capacity; i++) {
  201060:	11000673 	add	w19, w19, #0x1
  201064:	6b03027f 	cmp	w19, w3
  201068:	11200294 	add	w20, w20, #0x800
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  20106c:	1b038800 	msub	w0, w0, w3, w2
  201070:	8b2052c0 	add	x0, x22, w0, uxtw #4
  201074:	8b000022 	add	x2, x1, x0
  201078:	f8206825 	str	x5, [x1, x0]
  20107c:	7900105f 	strh	wzr, [x2, #8]
    queue->free->tail++;
  201080:	79000024 	strh	w4, [x1]
    for (uint32_t i = 0; i < queue->capacity; i++) {
  201084:	54000222 	b.cs	2010c8 <init+0x318>  // b.hs, b.nlast
    return queue->free->tail - queue->free->head == queue->capacity;
  201088:	f9401aa1 	ldr	x1, [x21, #48]
  20108c:	17ffffed 	b	201040 <init+0x290>
        assert(!err);
  201090:	d0000003 	adrp	x3, 203000 <_vsnprintf+0xc00>
  201094:	9112e063 	add	x3, x3, #0x4b8
  201098:	91008063 	add	x3, x3, #0x20
  20109c:	d0000001 	adrp	x1, 203000 <_vsnprintf+0xc00>
  2010a0:	d0000000 	adrp	x0, 203000 <_vsnprintf+0xc00>
  2010a4:	911c4021 	add	x1, x1, #0x710
  2010a8:	91190000 	add	x0, x0, #0x640
  2010ac:	52801ba2 	mov	w2, #0xdd                  	// #221
  2010b0:	940008e0 	bl	203430 <_assert_fail>
    for (uint32_t i = 0; i < queue->capacity; i++) {
  2010b4:	11000673 	add	w19, w19, #0x1
  2010b8:	b94042a3 	ldr	w3, [x21, #64]
  2010bc:	11200294 	add	w20, w20, #0x800
  2010c0:	6b03027f 	cmp	w19, w3
  2010c4:	54fffe23 	b.cc	201088 <init+0x2d8>  // b.lo, b.ul, b.last
    // arp_queue_init(&arp_queue, net_config.tx.free_queue.vaddr, net_config.tx.active_queue.vaddr,
    //                net_config.tx.num_buffers);
    // net_buffers_init(&arp_queue, 0);
    sddf_dprintf("Finished init in the routing component.\n");

}
  2010c8:	a94153f3 	ldp	x19, x20, [sp, #16]
    sddf_dprintf("Finished init in the routing component.\n");
  2010cc:	d0000000 	adrp	x0, 203000 <_vsnprintf+0xc00>
  2010d0:	911d4000 	add	x0, x0, #0x750
}
  2010d4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  2010d8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    sddf_dprintf("Finished init in the routing component.\n");
  2010dc:	14000819 	b	203140 <sddf_printf_>
  2010e0:	91001800 	add	x0, x0, #0x6
    while (n-- > 0) {
  2010e4:	d2800e44 	mov	x4, #0x72                  	// #114
        *p++ = c;
  2010e8:	aa0003e5 	mov	x5, x0
    while (n-- > 0) {
  2010ec:	d28000e7 	mov	x7, #0x7                   	// #7
        *p++ = c;
  2010f0:	4f000400 	movi	v0.4s, #0x0
  2010f4:	aa0003e1 	mov	x1, x0
    while (n-- > 0) {
  2010f8:	aa0403e2 	mov	x2, x4
  2010fc:	f1001cff 	cmp	x7, #0x7
        *p++ = c;
  201100:	a8817cbf 	stp	xzr, xzr, [x5], #16
  201104:	3d8000a0 	str	q0, [x5]
  201108:	ad010000 	stp	q0, q0, [x0, #32]
  20110c:	ad020000 	stp	q0, q0, [x0, #64]
    while (n-- > 0) {
  201110:	54ffee80 	b.eq	200ee0 <init+0x130>  // b.none
  201114:	91018020 	add	x0, x1, #0x60
  201118:	d1018041 	sub	x1, x2, #0x60
  20111c:	17ffff76 	b	200ef4 <init+0x144>
        *p++ = c;
  201120:	91000401 	add	x1, x0, #0x1
    while (n-- > 0) {
  201124:	d2800ee2 	mov	x2, #0x77                  	// #119
  201128:	17ffff61 	b	200eac <init+0xfc>
        *p++ = c;
  20112c:	91000801 	add	x1, x0, #0x2
  201130:	8b030000 	add	x0, x0, x3
  201134:	aa0003e5 	mov	x5, x0
  201138:	d2800f04 	mov	x4, #0x78                  	// #120
    while (n-- > 0) {
  20113c:	d28000e7 	mov	x7, #0x7                   	// #7
  201140:	cb030084 	sub	x4, x4, x3
  201144:	d2800ec2 	mov	x2, #0x76                  	// #118
        *p++ = c;
  201148:	a8817cbf 	stp	xzr, xzr, [x5], #16
    while (n-- > 0) {
  20114c:	17ffff5f 	b	200ec8 <init+0x118>
        *p++ = c;
  201150:	91000c01 	add	x1, x0, #0x3
    while (n-- > 0) {
  201154:	d2800ea2 	mov	x2, #0x75                  	// #117
  201158:	17ffff55 	b	200eac <init+0xfc>
        *p++ = c;
  20115c:	91001001 	add	x1, x0, #0x4
  201160:	8b030000 	add	x0, x0, x3
  201164:	aa0003e5 	mov	x5, x0
  201168:	d2800f04 	mov	x4, #0x78                  	// #120
    while (n-- > 0) {
  20116c:	d28000e7 	mov	x7, #0x7                   	// #7
  201170:	cb030084 	sub	x4, x4, x3
  201174:	d2800e82 	mov	x2, #0x74                  	// #116
        *p++ = c;
  201178:	a8817cbf 	stp	xzr, xzr, [x5], #16
    while (n-- > 0) {
  20117c:	17ffff53 	b	200ec8 <init+0x118>
        *p++ = c;
  201180:	aa0003e5 	mov	x5, x0
    while (n-- > 0) {
  201184:	d2800f04 	mov	x4, #0x78                  	// #120
    unsigned char *p = s;
  201188:	aa0003e1 	mov	x1, x0
    while (n-- > 0) {
  20118c:	aa0403e2 	mov	x2, x4
  201190:	d28000e7 	mov	x7, #0x7                   	// #7
        *p++ = c;
  201194:	a8817cbf 	stp	xzr, xzr, [x5], #16
    while (n-- > 0) {
  201198:	17ffff4c 	b	200ec8 <init+0x118>
        *p++ = c;
  20119c:	91001400 	add	x0, x0, #0x5
    while (n-- > 0) {
  2011a0:	d2800e64 	mov	x4, #0x73                  	// #115
  2011a4:	17ffffd1 	b	2010e8 <init+0x338>
        *p++ = c;
  2011a8:	91001c01 	add	x1, x0, #0x7
    while (n-- > 0) {
  2011ac:	d2800e22 	mov	x2, #0x71                  	// #113
  2011b0:	17ffff3f 	b	200eac <init+0xfc>
        *p++ = c;
  2011b4:	910038c3 	add	x3, x6, #0xe
  2011b8:	91003800 	add	x0, x0, #0xe
    while (n-- > 0) {
  2011bc:	d2800d44 	mov	x4, #0x6a                  	// #106
  2011c0:	910078c5 	add	x5, x6, #0x1e
  2011c4:	aa0003e1 	mov	x1, x0
  2011c8:	aa0403e2 	mov	x2, x4
  2011cc:	d28000c7 	mov	x7, #0x6                   	// #6
        *p++ = c;
  2011d0:	a9007c7f 	stp	xzr, xzr, [x3]
    while (n-- > 0) {
  2011d4:	17ffff3d 	b	200ec8 <init+0x118>
        *p++ = c;
  2011d8:	91002001 	add	x1, x0, #0x8
  2011dc:	8b030000 	add	x0, x0, x3
  2011e0:	aa0003e5 	mov	x5, x0
  2011e4:	d2800f04 	mov	x4, #0x78                  	// #120
    while (n-- > 0) {
  2011e8:	d28000e7 	mov	x7, #0x7                   	// #7
  2011ec:	cb030084 	sub	x4, x4, x3
  2011f0:	d2800e02 	mov	x2, #0x70                  	// #112
        *p++ = c;
  2011f4:	a8817cbf 	stp	xzr, xzr, [x5], #16
    while (n-- > 0) {
  2011f8:	17ffff34 	b	200ec8 <init+0x118>
        *p++ = c;
  2011fc:	910028c3 	add	x3, x6, #0xa
  201200:	91002800 	add	x0, x0, #0xa
    while (n-- > 0) {
  201204:	d2800dc4 	mov	x4, #0x6e                  	// #110
  201208:	910068c5 	add	x5, x6, #0x1a
  20120c:	aa0003e1 	mov	x1, x0
  201210:	aa0403e2 	mov	x2, x4
  201214:	d28000c7 	mov	x7, #0x6                   	// #6
        *p++ = c;
  201218:	a9007c7f 	stp	xzr, xzr, [x3]
    while (n-- > 0) {
  20121c:	17ffff2b 	b	200ec8 <init+0x118>
        *p++ = c;
  201220:	910024c3 	add	x3, x6, #0x9
  201224:	91002400 	add	x0, x0, #0x9
    while (n-- > 0) {
  201228:	d2800de4 	mov	x4, #0x6f                  	// #111
  20122c:	910064c5 	add	x5, x6, #0x19
  201230:	aa0003e1 	mov	x1, x0
  201234:	aa0403e2 	mov	x2, x4
  201238:	d28000c7 	mov	x7, #0x6                   	// #6
        *p++ = c;
  20123c:	a9007c7f 	stp	xzr, xzr, [x3]
    while (n-- > 0) {
  201240:	17ffff22 	b	200ec8 <init+0x118>
        *p++ = c;
  201244:	910034c3 	add	x3, x6, #0xd
  201248:	91003400 	add	x0, x0, #0xd
    while (n-- > 0) {
  20124c:	d2800d64 	mov	x4, #0x6b                  	// #107
  201250:	910074c5 	add	x5, x6, #0x1d
  201254:	aa0003e1 	mov	x1, x0
  201258:	aa0403e2 	mov	x2, x4
  20125c:	d28000c7 	mov	x7, #0x6                   	// #6
        *p++ = c;
  201260:	a9007c7f 	stp	xzr, xzr, [x3]
    while (n-- > 0) {
  201264:	17ffff19 	b	200ec8 <init+0x118>
        *p++ = c;
  201268:	91002cc3 	add	x3, x6, #0xb
  20126c:	91002c00 	add	x0, x0, #0xb
    while (n-- > 0) {
  201270:	d2800da4 	mov	x4, #0x6d                  	// #109
  201274:	91006cc5 	add	x5, x6, #0x1b
  201278:	aa0003e1 	mov	x1, x0
  20127c:	aa0403e2 	mov	x2, x4
  201280:	d28000c7 	mov	x7, #0x6                   	// #6
        *p++ = c;
  201284:	a9007c7f 	stp	xzr, xzr, [x3]
    while (n-- > 0) {
  201288:	17ffff10 	b	200ec8 <init+0x118>
        *p++ = c;
  20128c:	910030c3 	add	x3, x6, #0xc
  201290:	91003000 	add	x0, x0, #0xc
    while (n-- > 0) {
  201294:	d2800d84 	mov	x4, #0x6c                  	// #108
  201298:	910070c5 	add	x5, x6, #0x1c
  20129c:	aa0003e1 	mov	x1, x0
  2012a0:	aa0403e2 	mov	x2, x4
  2012a4:	d28000c7 	mov	x7, #0x6                   	// #6
        *p++ = c;
  2012a8:	a9007c7f 	stp	xzr, xzr, [x3]
    while (n-- > 0) {
  2012ac:	17ffff07 	b	200ec8 <init+0x118>

00000000002012b0 <notified>:
    // Popualate with the rx ch number
    if (0) {
        route();
    } else if (1) {
        /* This is the channel between the ARP component and the routing component. */
        process_arp_waiting();
  2012b0:	17fffce0 	b	200630 <process_arp_waiting>
	...

00000000002012c0 <protected>:
  2012c0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  2012c4:	d0000040 	adrp	x0, 20b000 <arp_table+0x3e40>
  2012c8:	91174000 	add	x0, x0, #0x5d0
  2012cc:	910003fd 	mov	x29, sp
  2012d0:	94000078 	bl	2014b0 <microkit_dbg_puts>
  2012d4:	d0000000 	adrp	x0, 203000 <_vsnprintf+0xc00>
  2012d8:	911e0000 	add	x0, x0, #0x780
  2012dc:	94000075 	bl	2014b0 <microkit_dbg_puts>
  2012e0:	d2800000 	mov	x0, #0x0                   	// #0
  2012e4:	b900001f 	str	wzr, [x0]
  2012e8:	d4207d00 	brk	#0x3e8
  2012ec:	d503201f 	nop

00000000002012f0 <fault>:
  2012f0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  2012f4:	d0000040 	adrp	x0, 20b000 <arp_table+0x3e40>
  2012f8:	91174000 	add	x0, x0, #0x5d0
  2012fc:	910003fd 	mov	x29, sp
  201300:	9400006c 	bl	2014b0 <microkit_dbg_puts>
  201304:	d0000000 	adrp	x0, 203000 <_vsnprintf+0xc00>
  201308:	911ec000 	add	x0, x0, #0x7b0
  20130c:	94000069 	bl	2014b0 <microkit_dbg_puts>
  201310:	d2800000 	mov	x0, #0x0                   	// #0
  201314:	b900001f 	str	wzr, [x0]
  201318:	d4207d00 	brk	#0x3e8
  20131c:	00000000 	udf	#0

0000000000201320 <main>:
  201320:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  201324:	f0000000 	adrp	x0, 204000 <__sel4_ipc_buffer>
  201328:	91000000 	add	x0, x0, #0x0
  20132c:	910003fd 	mov	x29, sp
  201330:	a90153f3 	stp	x19, x20, [sp, #16]
  201334:	f0000014 	adrp	x20, 204000 <__sel4_ipc_buffer>
  201338:	91000294 	add	x20, x20, #0x0
  20133c:	a9025bf5 	stp	x21, x22, [sp, #32]
  201340:	eb140015 	subs	x21, x0, x20
  201344:	54000100 	b.eq	201364 <main+0x44>  // b.none
  201348:	9343feb5 	asr	x21, x21, #3
  20134c:	d2800013 	mov	x19, #0x0                   	// #0
  201350:	f8737a80 	ldr	x0, [x20, x19, lsl #3]
  201354:	91000673 	add	x19, x19, #0x1
  201358:	d63f0000 	blr	x0
  20135c:	eb1302bf 	cmp	x21, x19
  201360:	54ffff88 	b.hi	201350 <main+0x30>  // b.pmore
  201364:	d0000056 	adrp	x22, 20b000 <arp_table+0x3e40>
  201368:	911742d6 	add	x22, x22, #0x5d0
  20136c:	97fffe91 	bl	200db0 <init>
  201370:	394102c0 	ldrb	w0, [x22, #64]
  201374:	340000a0 	cbz	w0, 201388 <main+0x68>
  201378:	52800021 	mov	w1, #0x1                   	// #1
  20137c:	d28000a0 	mov	x0, #0x5                   	// #5
  201380:	390106c1 	strb	w1, [x22, #65]
  201384:	a90482df 	stp	xzr, x0, [x22, #72]
  201388:	f0000015 	adrp	x21, 204000 <__sel4_ipc_buffer>
  20138c:	910002b5 	add	x21, x21, #0x0
  201390:	52800000 	mov	w0, #0x0                   	// #0
  201394:	d503201f 	nop
  201398:	35000220 	cbnz	w0, 2013dc <main+0xbc>
  20139c:	39c106c0 	ldrsb	w0, [x22, #65]
  2013a0:	350004e0 	cbnz	w0, 20143c <main+0x11c>
  2013a4:	d2800020 	mov	x0, #0x1                   	// #1
  2013a8:	d2800086 	mov	x6, #0x4                   	// #4
  2013ac:	928000c7 	mov	x7, #0xfffffffffffffff9    	// #-7
  2013b0:	d4000001 	svc	#0x0
  2013b4:	f94002a6 	ldr	x6, [x21]
  2013b8:	aa0003f3 	mov	x19, x0
  2013bc:	a9008cc2 	stp	x2, x3, [x6, #8]
  2013c0:	a90194c4 	stp	x4, x5, [x6, #24]
  2013c4:	b7f00313 	tbnz	x19, #62, 201424 <main+0x104>
  2013c8:	52800014 	mov	w20, #0x0                   	// #0
  2013cc:	b6f801b3 	tbz	x19, #63, 201400 <main+0xe0>
  2013d0:	12001660 	and	w0, w19, #0x3f
  2013d4:	97ffffbb 	bl	2012c0 <protected>
  2013d8:	f9001fe0 	str	x0, [sp, #56]
  2013dc:	f94002a5 	ldr	x5, [x21]
  2013e0:	d2800020 	mov	x0, #0x1                   	// #1
  2013e4:	f9401fe1 	ldr	x1, [sp, #56]
  2013e8:	d2800086 	mov	x6, #0x4                   	// #4
  2013ec:	a9408ca2 	ldp	x2, x3, [x5, #8]
  2013f0:	92800027 	mov	x7, #0xfffffffffffffffe    	// #-2
  2013f4:	a94194a4 	ldp	x4, x5, [x5, #24]
  2013f8:	d4000001 	svc	#0x0
  2013fc:	17ffffee 	b	2013b4 <main+0x94>
  201400:	370000d3 	tbnz	w19, #0, 201418 <main+0xf8>
  201404:	d503201f 	nop
  201408:	d341fe73 	lsr	x19, x19, #1
  20140c:	11000694 	add	w20, w20, #0x1
  201410:	b4fffc73 	cbz	x19, 20139c <main+0x7c>
  201414:	3607ffb3 	tbz	w19, #0, 201408 <main+0xe8>
  201418:	2a1403e0 	mov	w0, w20
  20141c:	97ffffa5 	bl	2012b0 <notified>
  201420:	17fffffa 	b	201408 <main+0xe8>
  201424:	12001e60 	and	w0, w19, #0xff
  201428:	9100e3e2 	add	x2, sp, #0x38
  20142c:	97ffffb1 	bl	2012f0 <fault>
  201430:	72001c1f 	tst	w0, #0xff
  201434:	1a9f07e0 	cset	w0, ne	// ne = any
  201438:	17ffffd8 	b	201398 <main+0x78>
  20143c:	f94002a5 	ldr	x5, [x21]
  201440:	d2800020 	mov	x0, #0x1                   	// #1
  201444:	a944a2c1 	ldp	x1, x8, [x22, #72]
  201448:	d2800086 	mov	x6, #0x4                   	// #4
  20144c:	a9408ca2 	ldp	x2, x3, [x5, #8]
  201450:	92800047 	mov	x7, #0xfffffffffffffffd    	// #-3
  201454:	a94194a4 	ldp	x4, x5, [x5, #24]
  201458:	d4000001 	svc	#0x0
  20145c:	f94002a6 	ldr	x6, [x21]
  201460:	aa0003f3 	mov	x19, x0
  201464:	390106df 	strb	wzr, [x22, #65]
  201468:	a9008cc2 	stp	x2, x3, [x6, #8]
  20146c:	a90194c4 	stp	x4, x5, [x6, #24]
  201470:	17ffffd5 	b	2013c4 <main+0xa4>
	...

0000000000201480 <microkit_dbg_putc>:
  201480:	d2800001 	mov	x1, #0x0                   	// #0
  201484:	92401c00 	and	x0, x0, #0xff
  201488:	d2800002 	mov	x2, #0x0                   	// #0
  20148c:	d2800003 	mov	x3, #0x0                   	// #0
  201490:	d2800004 	mov	x4, #0x0                   	// #0
  201494:	d2800005 	mov	x5, #0x0                   	// #0
  201498:	d2800006 	mov	x6, #0x0                   	// #0
  20149c:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  2014a0:	d4000001 	svc	#0x0
  2014a4:	d65f03c0 	ret
  2014a8:	d503201f 	nop
  2014ac:	d503201f 	nop

00000000002014b0 <microkit_dbg_puts>:
  2014b0:	aa0003e8 	mov	x8, x0
  2014b4:	39400000 	ldrb	w0, [x0]
  2014b8:	34000180 	cbz	w0, 2014e8 <microkit_dbg_puts+0x38>
  2014bc:	d503201f 	nop
  2014c0:	d2800001 	mov	x1, #0x0                   	// #0
  2014c4:	d2800002 	mov	x2, #0x0                   	// #0
  2014c8:	d2800003 	mov	x3, #0x0                   	// #0
  2014cc:	d2800004 	mov	x4, #0x0                   	// #0
  2014d0:	d2800005 	mov	x5, #0x0                   	// #0
  2014d4:	d2800006 	mov	x6, #0x0                   	// #0
  2014d8:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  2014dc:	d4000001 	svc	#0x0
  2014e0:	38401d00 	ldrb	w0, [x8, #1]!
  2014e4:	35fffee0 	cbnz	w0, 2014c0 <microkit_dbg_puts+0x10>
  2014e8:	d65f03c0 	ret
  2014ec:	d503201f 	nop

00000000002014f0 <__assert_fail>:
  2014f0:	d000000b 	adrp	x11, 203000 <_vsnprintf+0xc00>
  2014f4:	911f616b 	add	x11, x11, #0x7d8
  2014f8:	aa0103e9 	mov	x9, x1
  2014fc:	aa0303e8 	mov	x8, x3
  201500:	aa0003ea 	mov	x10, x0
  201504:	d2800c20 	mov	x0, #0x61                  	// #97
  201508:	d2800001 	mov	x1, #0x0                   	// #0
  20150c:	d2800002 	mov	x2, #0x0                   	// #0
  201510:	d2800003 	mov	x3, #0x0                   	// #0
  201514:	d2800004 	mov	x4, #0x0                   	// #0
  201518:	d2800005 	mov	x5, #0x0                   	// #0
  20151c:	d2800006 	mov	x6, #0x0                   	// #0
  201520:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  201524:	d4000001 	svc	#0x0
  201528:	38401d60 	ldrb	w0, [x11, #1]!
  20152c:	35fffee0 	cbnz	w0, 201508 <__assert_fail+0x18>
  201530:	39400140 	ldrb	w0, [x10]
  201534:	34000160 	cbz	w0, 201560 <__assert_fail+0x70>
  201538:	d2800001 	mov	x1, #0x0                   	// #0
  20153c:	d2800002 	mov	x2, #0x0                   	// #0
  201540:	d2800003 	mov	x3, #0x0                   	// #0
  201544:	d2800004 	mov	x4, #0x0                   	// #0
  201548:	d2800005 	mov	x5, #0x0                   	// #0
  20154c:	d2800006 	mov	x6, #0x0                   	// #0
  201550:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  201554:	d4000001 	svc	#0x0
  201558:	38401d40 	ldrb	w0, [x10, #1]!
  20155c:	35fffee0 	cbnz	w0, 201538 <__assert_fail+0x48>
  201560:	d2800400 	mov	x0, #0x20                  	// #32
  201564:	d2800001 	mov	x1, #0x0                   	// #0
  201568:	d2800002 	mov	x2, #0x0                   	// #0
  20156c:	d2800003 	mov	x3, #0x0                   	// #0
  201570:	d2800004 	mov	x4, #0x0                   	// #0
  201574:	d2800005 	mov	x5, #0x0                   	// #0
  201578:	d2800006 	mov	x6, #0x0                   	// #0
  20157c:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  201580:	d4000001 	svc	#0x0
  201584:	39400120 	ldrb	w0, [x9]
  201588:	34000180 	cbz	w0, 2015b8 <__assert_fail+0xc8>
  20158c:	d503201f 	nop
  201590:	d2800001 	mov	x1, #0x0                   	// #0
  201594:	d2800002 	mov	x2, #0x0                   	// #0
  201598:	d2800003 	mov	x3, #0x0                   	// #0
  20159c:	d2800004 	mov	x4, #0x0                   	// #0
  2015a0:	d2800005 	mov	x5, #0x0                   	// #0
  2015a4:	d2800006 	mov	x6, #0x0                   	// #0
  2015a8:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  2015ac:	d4000001 	svc	#0x0
  2015b0:	38401d20 	ldrb	w0, [x9, #1]!
  2015b4:	35fffee0 	cbnz	w0, 201590 <__assert_fail+0xa0>
  2015b8:	d2800400 	mov	x0, #0x20                  	// #32
  2015bc:	d2800001 	mov	x1, #0x0                   	// #0
  2015c0:	d2800002 	mov	x2, #0x0                   	// #0
  2015c4:	d2800003 	mov	x3, #0x0                   	// #0
  2015c8:	d2800004 	mov	x4, #0x0                   	// #0
  2015cc:	d2800005 	mov	x5, #0x0                   	// #0
  2015d0:	d2800006 	mov	x6, #0x0                   	// #0
  2015d4:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  2015d8:	d4000001 	svc	#0x0
  2015dc:	39400100 	ldrb	w0, [x8]
  2015e0:	34000180 	cbz	w0, 201610 <__assert_fail+0x120>
  2015e4:	d503201f 	nop
  2015e8:	d2800001 	mov	x1, #0x0                   	// #0
  2015ec:	d2800002 	mov	x2, #0x0                   	// #0
  2015f0:	d2800003 	mov	x3, #0x0                   	// #0
  2015f4:	d2800004 	mov	x4, #0x0                   	// #0
  2015f8:	d2800005 	mov	x5, #0x0                   	// #0
  2015fc:	d2800006 	mov	x6, #0x0                   	// #0
  201600:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  201604:	d4000001 	svc	#0x0
  201608:	38401d00 	ldrb	w0, [x8, #1]!
  20160c:	35fffee0 	cbnz	w0, 2015e8 <__assert_fail+0xf8>
  201610:	d2800140 	mov	x0, #0xa                   	// #10
  201614:	d2800001 	mov	x1, #0x0                   	// #0
  201618:	d2800002 	mov	x2, #0x0                   	// #0
  20161c:	d2800003 	mov	x3, #0x0                   	// #0
  201620:	d2800004 	mov	x4, #0x0                   	// #0
  201624:	d2800005 	mov	x5, #0x0                   	// #0
  201628:	d2800006 	mov	x6, #0x0                   	// #0
  20162c:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  201630:	d4000001 	svc	#0x0
  201634:	d65f03c0 	ret
	...

0000000000201640 <memcpy>:
  201640:	f9800020 	prfm	pldl1keep, [x1]
  201644:	8b020024 	add	x4, x1, x2
  201648:	8b020005 	add	x5, x0, x2
  20164c:	f100405f 	cmp	x2, #0x10
  201650:	54000209 	b.ls	201690 <memcpy+0x50>  // b.plast
  201654:	f101805f 	cmp	x2, #0x60
  201658:	54000648 	b.hi	201720 <memcpy+0xe0>  // b.pmore
  20165c:	d1000449 	sub	x9, x2, #0x1
  201660:	a9401c26 	ldp	x6, x7, [x1]
  201664:	37300469 	tbnz	w9, #6, 2016f0 <memcpy+0xb0>
  201668:	a97f348c 	ldp	x12, x13, [x4, #-16]
  20166c:	362800a9 	tbz	w9, #5, 201680 <memcpy+0x40>
  201670:	a9412428 	ldp	x8, x9, [x1, #16]
  201674:	a97e2c8a 	ldp	x10, x11, [x4, #-32]
  201678:	a9012408 	stp	x8, x9, [x0, #16]
  20167c:	a93e2caa 	stp	x10, x11, [x5, #-32]
  201680:	a9001c06 	stp	x6, x7, [x0]
  201684:	a93f34ac 	stp	x12, x13, [x5, #-16]
  201688:	d65f03c0 	ret
  20168c:	d503201f 	nop
  201690:	f100205f 	cmp	x2, #0x8
  201694:	540000e3 	b.cc	2016b0 <memcpy+0x70>  // b.lo, b.ul, b.last
  201698:	f9400026 	ldr	x6, [x1]
  20169c:	f85f8087 	ldur	x7, [x4, #-8]
  2016a0:	f9000006 	str	x6, [x0]
  2016a4:	f81f80a7 	stur	x7, [x5, #-8]
  2016a8:	d65f03c0 	ret
  2016ac:	d503201f 	nop
  2016b0:	361000c2 	tbz	w2, #2, 2016c8 <memcpy+0x88>
  2016b4:	b9400026 	ldr	w6, [x1]
  2016b8:	b85fc087 	ldur	w7, [x4, #-4]
  2016bc:	b9000006 	str	w6, [x0]
  2016c0:	b81fc0a7 	stur	w7, [x5, #-4]
  2016c4:	d65f03c0 	ret
  2016c8:	b4000102 	cbz	x2, 2016e8 <memcpy+0xa8>
  2016cc:	d341fc49 	lsr	x9, x2, #1
  2016d0:	39400026 	ldrb	w6, [x1]
  2016d4:	385ff087 	ldurb	w7, [x4, #-1]
  2016d8:	38696828 	ldrb	w8, [x1, x9]
  2016dc:	39000006 	strb	w6, [x0]
  2016e0:	38296808 	strb	w8, [x0, x9]
  2016e4:	381ff0a7 	sturb	w7, [x5, #-1]
  2016e8:	d65f03c0 	ret
  2016ec:	d503201f 	nop
  2016f0:	a9412428 	ldp	x8, x9, [x1, #16]
  2016f4:	a9422c2a 	ldp	x10, x11, [x1, #32]
  2016f8:	a943342c 	ldp	x12, x13, [x1, #48]
  2016fc:	a97e0881 	ldp	x1, x2, [x4, #-32]
  201700:	a97f0c84 	ldp	x4, x3, [x4, #-16]
  201704:	a9001c06 	stp	x6, x7, [x0]
  201708:	a9012408 	stp	x8, x9, [x0, #16]
  20170c:	a9022c0a 	stp	x10, x11, [x0, #32]
  201710:	a903340c 	stp	x12, x13, [x0, #48]
  201714:	a93e08a1 	stp	x1, x2, [x5, #-32]
  201718:	a93f0ca4 	stp	x4, x3, [x5, #-16]
  20171c:	d65f03c0 	ret
  201720:	92400c09 	and	x9, x0, #0xf
  201724:	927cec03 	and	x3, x0, #0xfffffffffffffff0
  201728:	a940342c 	ldp	x12, x13, [x1]
  20172c:	cb090021 	sub	x1, x1, x9
  201730:	8b090042 	add	x2, x2, x9
  201734:	a9411c26 	ldp	x6, x7, [x1, #16]
  201738:	a900340c 	stp	x12, x13, [x0]
  20173c:	a9422428 	ldp	x8, x9, [x1, #32]
  201740:	a9432c2a 	ldp	x10, x11, [x1, #48]
  201744:	a9c4342c 	ldp	x12, x13, [x1, #64]!
  201748:	f1024042 	subs	x2, x2, #0x90
  20174c:	54000169 	b.ls	201778 <memcpy+0x138>  // b.plast
  201750:	a9011c66 	stp	x6, x7, [x3, #16]
  201754:	a9411c26 	ldp	x6, x7, [x1, #16]
  201758:	a9022468 	stp	x8, x9, [x3, #32]
  20175c:	a9422428 	ldp	x8, x9, [x1, #32]
  201760:	a9032c6a 	stp	x10, x11, [x3, #48]
  201764:	a9432c2a 	ldp	x10, x11, [x1, #48]
  201768:	a984346c 	stp	x12, x13, [x3, #64]!
  20176c:	a9c4342c 	ldp	x12, x13, [x1, #64]!
  201770:	f1010042 	subs	x2, x2, #0x40
  201774:	54fffee8 	b.hi	201750 <memcpy+0x110>  // b.pmore
  201778:	a97c0881 	ldp	x1, x2, [x4, #-64]
  20177c:	a9011c66 	stp	x6, x7, [x3, #16]
  201780:	a97d1c86 	ldp	x6, x7, [x4, #-48]
  201784:	a9022468 	stp	x8, x9, [x3, #32]
  201788:	a97e2488 	ldp	x8, x9, [x4, #-32]
  20178c:	a9032c6a 	stp	x10, x11, [x3, #48]
  201790:	a97f2c8a 	ldp	x10, x11, [x4, #-16]
  201794:	a904346c 	stp	x12, x13, [x3, #64]
  201798:	a93c08a1 	stp	x1, x2, [x5, #-64]
  20179c:	a93d1ca6 	stp	x6, x7, [x5, #-48]
  2017a0:	a93e24a8 	stp	x8, x9, [x5, #-32]
  2017a4:	a93f2caa 	stp	x10, x11, [x5, #-16]
  2017a8:	d65f03c0 	ret
  2017ac:	00000000 	udf	#0

00000000002017b0 <_out_buffer>:


// internal buffer output
static inline void _out_buffer(char character, void* buffer, size_t idx, size_t maxlen)
{
  if (idx < maxlen) {
  2017b0:	eb03005f 	cmp	x2, x3
{
  2017b4:	12001c00 	and	w0, w0, #0xff
  if (idx < maxlen) {
  2017b8:	54000042 	b.cs	2017c0 <_out_buffer+0x10>  // b.hs, b.nlast
    ((char*)buffer)[idx] = character;
  2017bc:	38226820 	strb	w0, [x1, x2]
  }
}
  2017c0:	d65f03c0 	ret
  2017c4:	d503201f 	nop
  2017c8:	d503201f 	nop
  2017cc:	d503201f 	nop

00000000002017d0 <_out_null>:

// internal null output
static inline void _out_null(char character, void* buffer, size_t idx, size_t maxlen)
{
  (void)character; (void)buffer; (void)idx; (void)maxlen;
}
  2017d0:	d65f03c0 	ret
  2017d4:	d503201f 	nop
  2017d8:	d503201f 	nop
  2017dc:	d503201f 	nop

00000000002017e0 <_out_rev>:
}


// output the specified string in reverse, taking care of any zero-padding
static size_t _out_rev(out_fct_type out, char* buffer, size_t idx, size_t maxlen, const char* buf, size_t len, unsigned int width, unsigned int flags)
{
  2017e0:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  2017e4:	910003fd 	mov	x29, sp
  2017e8:	a90153f3 	stp	x19, x20, [sp, #16]
  2017ec:	aa0503f3 	mov	x19, x5
  2017f0:	aa0203f4 	mov	x20, x2
  2017f4:	a9025bf5 	stp	x21, x22, [sp, #32]
  2017f8:	aa0003f5 	mov	x21, x0
  2017fc:	aa0103f6 	mov	x22, x1
  201800:	a90363f7 	stp	x23, x24, [sp, #48]
  201804:	aa0203f8 	mov	x24, x2
  201808:	aa0303f7 	mov	x23, x3
  20180c:	a9046bf9 	stp	x25, x26, [sp, #64]
  201810:	aa0403f9 	mov	x25, x4
  201814:	2a0603fa 	mov	w26, w6
  201818:	a90573fb 	stp	x27, x28, [sp, #80]
  20181c:	2a0703fb 	mov	w27, w7
  const size_t start_idx = idx;

  // pad spaces up to given width
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
  201820:	f240077f 	tst	x27, #0x3
  201824:	540001e1 	b.ne	201860 <_out_rev+0x80>  // b.any
    for (size_t i = len; i < width; i++) {
  201828:	2a1a03e0 	mov	w0, w26
  20182c:	aa0203fc 	mov	x28, x2
  201830:	cb050014 	sub	x20, x0, x5
  201834:	eb0000bf 	cmp	x5, x0
  201838:	8b020294 	add	x20, x20, x2
  20183c:	54000502 	b.cs	2018dc <_out_rev+0xfc>  // b.hs, b.nlast
      out(' ', buffer, idx++, maxlen);
  201840:	aa1c03e2 	mov	x2, x28
  201844:	aa1703e3 	mov	x3, x23
  201848:	9100079c 	add	x28, x28, #0x1
  20184c:	aa1603e1 	mov	x1, x22
  201850:	52800400 	mov	w0, #0x20                  	// #32
  201854:	d63f02a0 	blr	x21
    for (size_t i = len; i < width; i++) {
  201858:	eb1c029f 	cmp	x20, x28
  20185c:	54ffff21 	b.ne	201840 <_out_rev+0x60>  // b.any
    }
  }

  // reverse string
  while (len) {
  201860:	8b14027c 	add	x28, x19, x20
  201864:	b4000133 	cbz	x19, 201888 <_out_rev+0xa8>
  201868:	cb130382 	sub	x2, x28, x19
    out(buf[--len], buffer, idx++, maxlen);
  20186c:	d1000673 	sub	x19, x19, #0x1
  201870:	aa1c03f4 	mov	x20, x28
  201874:	aa1703e3 	mov	x3, x23
  201878:	aa1603e1 	mov	x1, x22
  20187c:	38736b20 	ldrb	w0, [x25, x19]
  201880:	d63f02a0 	blr	x21
  while (len) {
  201884:	b5ffff33 	cbnz	x19, 201868 <_out_rev+0x88>
  }

  // append pad spaces up to given width
  if (flags & FLAGS_LEFT) {
  201888:	360801bb 	tbz	w27, #1, 2018bc <_out_rev+0xdc>
    while (idx - start_idx < width) {
  20188c:	cb180298 	sub	x24, x20, x24
  201890:	eb1a031f 	cmp	x24, x26
  201894:	54000142 	b.cs	2018bc <_out_rev+0xdc>  // b.hs, b.nlast
      out(' ', buffer, idx++, maxlen);
  201898:	aa1403e2 	mov	x2, x20
    while (idx - start_idx < width) {
  20189c:	91000718 	add	x24, x24, #0x1
      out(' ', buffer, idx++, maxlen);
  2018a0:	aa1703e3 	mov	x3, x23
  2018a4:	aa1603e1 	mov	x1, x22
  2018a8:	52800400 	mov	w0, #0x20                  	// #32
  2018ac:	d63f02a0 	blr	x21
  2018b0:	91000694 	add	x20, x20, #0x1
    while (idx - start_idx < width) {
  2018b4:	eb1a031f 	cmp	x24, x26
  2018b8:	54ffff03 	b.cc	201898 <_out_rev+0xb8>  // b.lo, b.ul, b.last
    }
  }

  return idx;
}
  2018bc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  2018c0:	aa1403e0 	mov	x0, x20
  2018c4:	a94153f3 	ldp	x19, x20, [sp, #16]
  2018c8:	a94363f7 	ldp	x23, x24, [sp, #48]
  2018cc:	a9446bf9 	ldp	x25, x26, [sp, #64]
  2018d0:	a94573fb 	ldp	x27, x28, [sp, #80]
  2018d4:	a8c67bfd 	ldp	x29, x30, [sp], #96
  2018d8:	d65f03c0 	ret
    for (size_t i = len; i < width; i++) {
  2018dc:	aa0203f4 	mov	x20, x2
  2018e0:	17ffffe0 	b	201860 <_out_rev+0x80>
  2018e4:	d503201f 	nop
  2018e8:	d503201f 	nop
  2018ec:	d503201f 	nop

00000000002018f0 <_ntoa_long>:
}


// internal itoa for 'long' type
static size_t _ntoa_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long value, bool negative, unsigned long base, unsigned int prec, unsigned int width, unsigned int flags)
{
  2018f0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  2018f4:	aa0603eb 	mov	x11, x6
  2018f8:	aa0403ea 	mov	x10, x4
  2018fc:	910003fd 	mov	x29, sp
  201900:	b9403be8 	ldr	w8, [sp, #56]
  201904:	2a0703ef 	mov	w15, w7
  201908:	b94033e6 	ldr	w6, [sp, #48]
  20190c:	12001cb2 	and	w18, w5, #0xff
  if (!value) {
    flags &= ~FLAGS_HASH;
  }

  // write if precision != 0 and value is != 0
  if (!(flags & FLAGS_PRECISION) || value) {
  201910:	12160110 	and	w16, w8, #0x400
  if (!value) {
  201914:	b4000764 	cbz	x4, 201a00 <_ntoa_long+0x110>
  if (flags & FLAGS_HASH) {
  201918:	121c0111 	and	w17, w8, #0x10
  20191c:	2a0803e7 	mov	w7, w8
    do {
      const char digit = (char)(value % base);
  201920:	9acb094c 	udiv	x12, x10, x11
  201924:	f27b00ff 	tst	x7, #0x20
  201928:	52800c24 	mov	w4, #0x61                  	// #97
  20192c:	5280082d 	mov	w13, #0x41                  	// #65
  201930:	1a8411ad 	csel	w13, w13, w4, ne	// ne = any
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  201934:	d2800005 	mov	x5, #0x0                   	// #0
  201938:	510029ad 	sub	w13, w13, #0xa
  20193c:	910043e4 	add	x4, sp, #0x10
      const char digit = (char)(value % base);
  201940:	9b0ba988 	msub	x8, x12, x11, x10
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  201944:	910004a5 	add	x5, x5, #0x1
  201948:	f100251f 	cmp	x8, #0x9
      const char digit = (char)(value % base);
  20194c:	12001d08 	and	w8, w8, #0xff
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  201950:	1100c10e 	add	w14, w8, #0x30
  201954:	0b0d0108 	add	w8, w8, w13
  201958:	54000248 	b.hi	2019a0 <_ntoa_long+0xb0>  // b.pmore
  20195c:	d503201f 	nop
  201960:	8b050088 	add	x8, x4, x5
      value /= base;
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
  201964:	f1007cbf 	cmp	x5, #0x1f
  201968:	1a9f87e9 	cset	w9, ls	// ls = plast
  20196c:	7100013f 	cmp	w9, #0x0
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  201970:	381ff10e 	sturb	w14, [x8, #-1]
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
  201974:	fa4a1162 	ccmp	x11, x10, #0x2, ne	// ne = any
  201978:	54000228 	b.hi	2019bc <_ntoa_long+0xcc>  // b.pmore
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  20197c:	aa0c03ea 	mov	x10, x12
  201980:	910004a5 	add	x5, x5, #0x1
      const char digit = (char)(value % base);
  201984:	9acb094c 	udiv	x12, x10, x11
  201988:	9b0ba988 	msub	x8, x12, x11, x10
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  20198c:	f100251f 	cmp	x8, #0x9
      const char digit = (char)(value % base);
  201990:	12001d08 	and	w8, w8, #0xff
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  201994:	1100c10e 	add	w14, w8, #0x30
  201998:	0b0d0108 	add	w8, w8, w13
  20199c:	54fffe29 	b.ls	201960 <_ntoa_long+0x70>  // b.plast
  2019a0:	8b05008e 	add	x14, x4, x5
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
  2019a4:	f1007cbf 	cmp	x5, #0x1f
  2019a8:	1a9f87e9 	cset	w9, ls	// ls = plast
  2019ac:	7100013f 	cmp	w9, #0x0
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  2019b0:	381ff1c8 	sturb	w8, [x14, #-1]
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
  2019b4:	fa4a1162 	ccmp	x11, x10, #0x2, ne	// ne = any
  2019b8:	54fffe29 	b.ls	20197c <_ntoa_long+0x8c>  // b.plast
  if (!(flags & FLAGS_LEFT)) {
  2019bc:	36080307 	tbz	w7, #1, 201a1c <_ntoa_long+0x12c>
  if (flags & FLAGS_HASH) {
  2019c0:	34000771 	cbz	w17, 201aac <_ntoa_long+0x1bc>
    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
  2019c4:	34000850 	cbz	w16, 201acc <_ntoa_long+0x1dc>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  2019c8:	f100417f 	cmp	x11, #0x10
  2019cc:	54000de0 	b.eq	201b88 <_ntoa_long+0x298>  // b.none
    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  2019d0:	7100013f 	cmp	w9, #0x0
  2019d4:	7a421960 	ccmp	w11, #0x2, #0x0, ne	// ne = any
  2019d8:	540000a1 	b.ne	2019ec <_ntoa_long+0xfc>  // b.any
      buf[len++] = 'b';
  2019dc:	aa0503e8 	mov	x8, x5
  2019e0:	910004a5 	add	x5, x5, #0x1
  2019e4:	52800c49 	mov	w9, #0x62                  	// #98
  2019e8:	38286889 	strb	w9, [x4, x8]
    if (len < PRINTF_NTOA_BUFFER_SIZE) {
  2019ec:	f10080bf 	cmp	x5, #0x20
  2019f0:	54000881 	b.ne	201b00 <_ntoa_long+0x210>  // b.any
  return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
  2019f4:	97ffff7b 	bl	2017e0 <_out_rev>
  }

  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
}
  2019f8:	a8c37bfd 	ldp	x29, x30, [sp], #48
  2019fc:	d65f03c0 	ret
    flags &= ~FLAGS_HASH;
  201a00:	121b7907 	and	w7, w8, #0xffffffef
  if (!(flags & FLAGS_PRECISION) || value) {
  201a04:	340008d0 	cbz	w16, 201b1c <_ntoa_long+0x22c>
  if (!(flags & FLAGS_LEFT)) {
  201a08:	121f0111 	and	w17, w8, #0x2
  201a0c:	37080a08 	tbnz	w8, #1, 201b4c <_ntoa_long+0x25c>
  201a10:	910043e4 	add	x4, sp, #0x10
  size_t len = 0U;
  201a14:	d2800005 	mov	x5, #0x0                   	// #0
  if (!(flags & FLAGS_LEFT)) {
  201a18:	52800029 	mov	w9, #0x1                   	// #1
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201a1c:	2a0f03ea 	mov	w10, w15
    if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
  201a20:	120000ed 	and	w13, w7, #0x1
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201a24:	eb0a00bf 	cmp	x5, x10
  201a28:	1a9f27e8 	cset	w8, cc	// cc = lo, ul, last
  201a2c:	0a080128 	and	w8, w9, w8
    if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
  201a30:	340007a6 	cbz	w6, 201b24 <_ntoa_long+0x234>
  201a34:	3400088d 	cbz	w13, 201b44 <_ntoa_long+0x254>
  201a38:	35000072 	cbnz	w18, 201a44 <_ntoa_long+0x154>
  201a3c:	721e04ff 	tst	w7, #0xc
  201a40:	54000040 	b.eq	201a48 <_ntoa_long+0x158>  // b.none
      width--;
  201a44:	510004c6 	sub	w6, w6, #0x1
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201a48:	34000168 	cbz	w8, 201a74 <_ntoa_long+0x184>
      buf[len++] = '0';
  201a4c:	5280060c 	mov	w12, #0x30                  	// #48
  201a50:	910004a5 	add	x5, x5, #0x1
  201a54:	8b050088 	add	x8, x4, x5
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201a58:	f1007cbf 	cmp	x5, #0x1f
  201a5c:	1a9f87e9 	cset	w9, ls	// ls = plast
  201a60:	7100013f 	cmp	w9, #0x0
      buf[len++] = '0';
  201a64:	381ff10c 	sturb	w12, [x8, #-1]
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201a68:	fa4a10a2 	ccmp	x5, x10, #0x2, ne	// ne = any
  201a6c:	54ffff23 	b.cc	201a50 <_ntoa_long+0x160>  // b.lo, b.ul, b.last
    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201a70:	34fffa8d 	cbz	w13, 2019c0 <_ntoa_long+0xd0>
  201a74:	7100013f 	cmp	w9, #0x0
  201a78:	2a0603ea 	mov	w10, w6
  201a7c:	fa451140 	ccmp	x10, x5, #0x0, ne	// ne = any
  201a80:	54fffa09 	b.ls	2019c0 <_ntoa_long+0xd0>  // b.plast
      buf[len++] = '0';
  201a84:	5280060c 	mov	w12, #0x30                  	// #48
  201a88:	910004a5 	add	x5, x5, #0x1
  201a8c:	8b050088 	add	x8, x4, x5
    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201a90:	f1007cbf 	cmp	x5, #0x1f
  201a94:	1a9f87e9 	cset	w9, ls	// ls = plast
  201a98:	7100013f 	cmp	w9, #0x0
      buf[len++] = '0';
  201a9c:	381ff10c 	sturb	w12, [x8, #-1]
    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201aa0:	fa4a10a2 	ccmp	x5, x10, #0x2, ne	// ne = any
  201aa4:	54ffff23 	b.cc	201a88 <_ntoa_long+0x198>  // b.lo, b.ul, b.last
  if (flags & FLAGS_HASH) {
  201aa8:	35fff8f1 	cbnz	w17, 2019c4 <_ntoa_long+0xd4>
  if (len < PRINTF_NTOA_BUFFER_SIZE) {
  201aac:	f10080bf 	cmp	x5, #0x20
  201ab0:	54fffa20 	b.eq	2019f4 <_ntoa_long+0x104>  // b.none
    if (negative) {
  201ab4:	350003d2 	cbnz	w18, 201b2c <_ntoa_long+0x23c>
    else if (flags & FLAGS_PLUS) {
  201ab8:	36100787 	tbz	w7, #2, 201ba8 <_ntoa_long+0x2b8>
      buf[len++] = '+';  // ignore the space if the '+' exists
  201abc:	52800568 	mov	w8, #0x2b                  	// #43
  201ac0:	38256888 	strb	w8, [x4, x5]
  201ac4:	910004a5 	add	x5, x5, #0x1
  201ac8:	17ffffcb 	b	2019f4 <_ntoa_long+0x104>
    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
  201acc:	b4000485 	cbz	x5, 201b5c <_ntoa_long+0x26c>
  201ad0:	eb2f40bf 	cmp	x5, w15, uxtw
  201ad4:	54000060 	b.eq	201ae0 <_ntoa_long+0x1f0>  // b.none
  201ad8:	eb2640bf 	cmp	x5, w6, uxtw
  201adc:	54fff761 	b.ne	2019c8 <_ntoa_long+0xd8>  // b.any
      if (len && (base == 16U)) {
  201ae0:	f10004a8 	subs	x8, x5, #0x1
  201ae4:	7a501960 	ccmp	w11, #0x10, #0x0, ne	// ne = any
  201ae8:	54000821 	b.ne	201bec <_ntoa_long+0x2fc>  // b.any
        len--;
  201aec:	d10008a9 	sub	x9, x5, #0x2
      buf[len++] = 'x';
  201af0:	aa0803e5 	mov	x5, x8
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201af4:	36280907 	tbz	w7, #5, 201c14 <_ntoa_long+0x324>
      buf[len++] = 'X';
  201af8:	52800b08 	mov	w8, #0x58                  	// #88
  201afc:	38296888 	strb	w8, [x4, x9]
      buf[len++] = '0';
  201b00:	aa0503e8 	mov	x8, x5
  201b04:	910004a5 	add	x5, x5, #0x1
  201b08:	52800609 	mov	w9, #0x30                  	// #48
  201b0c:	38286889 	strb	w9, [x4, x8]
  if (len < PRINTF_NTOA_BUFFER_SIZE) {
  201b10:	f10080bf 	cmp	x5, #0x20
  201b14:	54fff700 	b.eq	2019f4 <_ntoa_long+0x104>  // b.none
  201b18:	17ffffe7 	b	201ab4 <_ntoa_long+0x1c4>
  if (!(flags & FLAGS_PRECISION) || value) {
  201b1c:	52800011 	mov	w17, #0x0                   	// #0
  201b20:	17ffff80 	b	201920 <_ntoa_long+0x30>
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201b24:	35fff948 	cbnz	w8, 201a4c <_ntoa_long+0x15c>
  201b28:	17ffffd2 	b	201a70 <_ntoa_long+0x180>
      buf[len++] = '-';
  201b2c:	528005a8 	mov	w8, #0x2d                  	// #45
  201b30:	38256888 	strb	w8, [x4, x5]
  201b34:	910004a5 	add	x5, x5, #0x1
  return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
  201b38:	97ffff2a 	bl	2017e0 <_out_rev>
}
  201b3c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  201b40:	d65f03c0 	ret
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201b44:	35fff848 	cbnz	w8, 201a4c <_ntoa_long+0x15c>
  201b48:	17ffff9e 	b	2019c0 <_ntoa_long+0xd0>
  201b4c:	910043e4 	add	x4, sp, #0x10
  size_t len = 0U;
  201b50:	d2800005 	mov	x5, #0x0                   	// #0
    if (negative) {
  201b54:	34fffb32 	cbz	w18, 201ab8 <_ntoa_long+0x1c8>
  201b58:	17fffff5 	b	201b2c <_ntoa_long+0x23c>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201b5c:	f100417f 	cmp	x11, #0x10
  201b60:	54000500 	b.eq	201c00 <_ntoa_long+0x310>  // b.none
    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201b64:	f100097f 	cmp	x11, #0x2
  201b68:	54000381 	b.ne	201bd8 <_ntoa_long+0x2e8>  // b.any
  201b6c:	52800c48 	mov	w8, #0x62                  	// #98
      buf[len++] = '0';
  201b70:	52800609 	mov	w9, #0x30                  	// #48
      buf[len++] = 'x';
  201b74:	390043e8 	strb	w8, [sp, #16]
      buf[len++] = '0';
  201b78:	390047e9 	strb	w9, [sp, #17]
  201b7c:	d2800045 	mov	x5, #0x2                   	// #2
    if (negative) {
  201b80:	34fff9d2 	cbz	w18, 201ab8 <_ntoa_long+0x1c8>
  201b84:	17ffffea 	b	201b2c <_ntoa_long+0x23c>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201b88:	362801a7 	tbz	w7, #5, 201bbc <_ntoa_long+0x2cc>
    else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201b8c:	f10080bf 	cmp	x5, #0x20
  201b90:	54fff320 	b.eq	2019f4 <_ntoa_long+0x104>  // b.none
      buf[len++] = 'b';
  201b94:	910004a9 	add	x9, x5, #0x1
      buf[len++] = 'X';
  201b98:	52800b08 	mov	w8, #0x58                  	// #88
  201b9c:	38256888 	strb	w8, [x4, x5]
  201ba0:	aa0903e5 	mov	x5, x9
  201ba4:	17ffff92 	b	2019ec <_ntoa_long+0xfc>
    else if (flags & FLAGS_SPACE) {
  201ba8:	361ff267 	tbz	w7, #3, 2019f4 <_ntoa_long+0x104>
      buf[len++] = ' ';
  201bac:	52800408 	mov	w8, #0x20                  	// #32
  201bb0:	38256888 	strb	w8, [x4, x5]
  201bb4:	910004a5 	add	x5, x5, #0x1
  201bb8:	17ffff8f 	b	2019f4 <_ntoa_long+0x104>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201bbc:	f10080bf 	cmp	x5, #0x20
  201bc0:	54fff1a0 	b.eq	2019f4 <_ntoa_long+0x104>  // b.none
      buf[len++] = 'b';
  201bc4:	aa0503e8 	mov	x8, x5
  201bc8:	910004a5 	add	x5, x5, #0x1
      buf[len++] = 'x';
  201bcc:	52800f09 	mov	w9, #0x78                  	// #120
  201bd0:	38286889 	strb	w9, [x4, x8]
  201bd4:	17ffff86 	b	2019ec <_ntoa_long+0xfc>
      buf[len++] = '0';
  201bd8:	52800608 	mov	w8, #0x30                  	// #48
  201bdc:	390043e8 	strb	w8, [sp, #16]
  201be0:	d2800025 	mov	x5, #0x1                   	// #1
    if (negative) {
  201be4:	34fff6b2 	cbz	w18, 201ab8 <_ntoa_long+0x1c8>
  201be8:	17ffffd1 	b	201b2c <_ntoa_long+0x23c>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201bec:	f100417f 	cmp	x11, #0x10
  201bf0:	54000180 	b.eq	201c20 <_ntoa_long+0x330>  // b.none
    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201bf4:	f100097f 	cmp	x11, #0x2
  201bf8:	54ffef60 	b.eq	2019e4 <_ntoa_long+0xf4>  // b.none
  201bfc:	17ffffc3 	b	201b08 <_ntoa_long+0x218>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201c00:	f27b00ff 	tst	x7, #0x20
  201c04:	52800f08 	mov	w8, #0x78                  	// #120
  201c08:	52800b05 	mov	w5, #0x58                  	// #88
  201c0c:	1a850108 	csel	w8, w8, w5, eq	// eq = none
  201c10:	17ffffd8 	b	201b70 <_ntoa_long+0x280>
      buf[len++] = 'x';
  201c14:	52800f08 	mov	w8, #0x78                  	// #120
  201c18:	38296888 	strb	w8, [x4, x9]
    if (len < PRINTF_NTOA_BUFFER_SIZE) {
  201c1c:	17ffffb9 	b	201b00 <_ntoa_long+0x210>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201c20:	362ffd67 	tbz	w7, #5, 201bcc <_ntoa_long+0x2dc>
  201c24:	aa0503e9 	mov	x9, x5
      len--;
  201c28:	aa0803e5 	mov	x5, x8
  201c2c:	17ffffdb 	b	201b98 <_ntoa_long+0x2a8>

0000000000201c30 <_out_char>:
  if (character) {
  201c30:	72001c00 	ands	w0, w0, #0xff
  201c34:	54000041 	b.ne	201c3c <_out_char+0xc>  // b.any
}
  201c38:	d65f03c0 	ret
    _sddf_putchar(character);
  201c3c:	14000609 	b	203460 <_sddf_putchar>

0000000000201c40 <_out_fct>:
  if (character) {
  201c40:	72001c00 	ands	w0, w0, #0xff
  201c44:	54000080 	b.eq	201c54 <_out_fct+0x14>  // b.none
    ((out_fct_wrap_type*)buffer)->fct(character, ((out_fct_wrap_type*)buffer)->arg);
  201c48:	a9400422 	ldp	x2, x1, [x1]
  201c4c:	aa0203f0 	mov	x16, x2
  201c50:	d61f0200 	br	x16
}
  201c54:	d65f03c0 	ret
  201c58:	d503201f 	nop
  201c5c:	d503201f 	nop

0000000000201c60 <_ftoa>:

  // powers of 10
  static const double pow10[] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };

  // test for special values
  if (value != value)
  201c60:	1e602000 	fcmp	d0, d0
{
  201c64:	2a0603e7 	mov	w7, w6
  if (value != value)
  201c68:	54000fa1 	b.ne	201e5c <_ftoa+0x1fc>  // b.any
    return _out_rev(out, buffer, idx, maxlen, "nan", 3, width, flags);
  if (value < -DBL_MAX)
  201c6c:	92e00206 	mov	x6, #0xffefffffffffffff    	// #-4503599627370497
  201c70:	9e6700c1 	fmov	d1, x6
  201c74:	1e612010 	fcmpe	d0, d1
  201c78:	54001324 	b.mi	201edc <_ftoa+0x27c>  // b.first
  201c7c:	aa0003ef 	mov	x15, x0
    return _out_rev(out, buffer, idx, maxlen, "fni-", 4, width, flags);
  if (value > DBL_MAX)
  201c80:	92f00200 	mov	x0, #0x7fefffffffffffff    	// #9218868437227405311
  201c84:	9e670001 	fmov	d1, x0
  201c88:	aa0103f0 	mov	x16, x1
  201c8c:	aa0203f1 	mov	x17, x2
  201c90:	aa0303f2 	mov	x18, x3
  201c94:	1e612010 	fcmpe	d0, d1
  201c98:	54000ccc 	b.gt	201e30 <_ftoa+0x1d0>
    return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? "fni+" : "fni", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);

  // test for very large values
  // standard printf behavior is to print EVERY whole number digit -- which could be 100s of characters overflowing your buffers == bad
  if ((value > PRINTF_MAX_FLOAT) || (value < -PRINTF_MAX_FLOAT)) {
  201c9c:	d2d9aca0 	mov	x0, #0xcd6500000000        	// #225833675390976
  201ca0:	f2e839a0 	movk	x0, #0x41cd, lsl #48
  201ca4:	9e670001 	fmov	d1, x0
  201ca8:	1e612010 	fcmpe	d0, d1
  201cac:	540010cc 	b.gt	201ec4 <_ftoa+0x264>
  201cb0:	d2d9aca0 	mov	x0, #0xcd6500000000        	// #225833675390976
  201cb4:	f2f839a0 	movk	x0, #0xc1cd, lsl #48
  201cb8:	9e670001 	fmov	d1, x0
  201cbc:	1e612010 	fcmpe	d0, d1
  201cc0:	54001024 	b.mi	201ec4 <_ftoa+0x264>  // b.first
#endif
  }

  // test for negative
  bool negative = false;
  if (value < 0) {
  201cc4:	1e602018 	fcmpe	d0, #0.0
{
  201cc8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  201ccc:	910003fd 	mov	x29, sp
  if (value < 0) {
  201cd0:	54000e44 	b.mi	201e98 <_ftoa+0x238>  // b.first
  bool negative = false;
  201cd4:	52800003 	mov	w3, #0x0                   	// #0
    negative = true;
    value = 0 - value;
  }

  // set default precision, if not set explicitly
  if (!(flags & FLAGS_PRECISION)) {
  201cd8:	36500e87 	tbz	w7, #10, 201ea8 <_ftoa+0x248>
    prec = PRINTF_DEFAULT_FLOAT_PRECISION;
  }
  // limit precision to 9, cause a prec >= 10 can lead to overflow errors
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
  201cdc:	7100249f 	cmp	w4, #0x9
  201ce0:	54001b49 	b.ls	202048 <_ftoa+0x3e8>  // b.plast
  201ce4:	910043ec 	add	x12, sp, #0x10
  201ce8:	d2800008 	mov	x8, #0x0                   	// #0
    buf[len++] = '0';
  201cec:	52800601 	mov	w1, #0x30                  	// #48
  201cf0:	91000508 	add	x8, x8, #0x1
    prec--;
  201cf4:	51000484 	sub	w4, w4, #0x1
    buf[len++] = '0';
  201cf8:	8b080180 	add	x0, x12, x8
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
  201cfc:	f1007d1f 	cmp	x8, #0x1f
  201d00:	7a499880 	ccmp	w4, #0x9, #0x0, ls	// ls = plast
    buf[len++] = '0';
  201d04:	381ff001 	sturb	w1, [x0, #-1]
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
  201d08:	54ffff48 	b.hi	201cf0 <_ftoa+0x90>  // b.pmore
  201d0c:	d2d9aca0 	mov	x0, #0xcd6500000000        	// #225833675390976
  201d10:	f2e839a0 	movk	x0, #0x41cd, lsl #48
  201d14:	9e670002 	fmov	d2, x0
  }

  int whole = (int)value;
  201d18:	1e78000a 	fcvtzs	w10, d0
  double tmp = (value - whole) * pow10[prec];
  unsigned long frac = (unsigned long)tmp;
  diff = tmp - frac;

  if (diff > 0.5) {
  201d1c:	1e6c1003 	fmov	d3, #5.000000000000000000e-01
  double tmp = (value - whole) * pow10[prec];
  201d20:	1e620141 	scvtf	d1, w10
  201d24:	1e613801 	fsub	d1, d0, d1
  201d28:	1e620821 	fmul	d1, d1, d2
  unsigned long frac = (unsigned long)tmp;
  201d2c:	9e79002e 	fcvtzu	x14, d1
  diff = tmp - frac;
  201d30:	9e6301c4 	ucvtf	d4, x14
  201d34:	1e643821 	fsub	d1, d1, d4
  if (diff > 0.5) {
  201d38:	1e632030 	fcmpe	d1, d3
  201d3c:	5400106c 	b.gt	201f48 <_ftoa+0x2e8>
    if (frac >= pow10[prec]) {
      frac = 0;
      ++whole;
    }
  }
  else if (diff < 0.5) {
  201d40:	54000084 	b.mi	201d50 <_ftoa+0xf0>  // b.first
  }
  else if ((frac == 0U) || (frac & 1U)) {
  201d44:	b500172e 	cbnz	x14, 202028 <_ftoa+0x3c8>
    // if halfway, round up if odd OR if last digit is 0
    ++frac;
  201d48:	910005ce 	add	x14, x14, #0x1
  201d4c:	d503201f 	nop
  }

  if (prec == 0U) {
  201d50:	35000d04 	cbnz	w4, 201ef0 <_ftoa+0x290>
    diff = value - (double)whole;
  201d54:	1e620141 	scvtf	d1, w10
    if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
  201d58:	1e6c1002 	fmov	d2, #5.000000000000000000e-01
    diff = value - (double)whole;
  201d5c:	1e613800 	fsub	d0, d0, d1
    if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
  201d60:	1e622010 	fcmpe	d0, d2
  201d64:	54001564 	b.mi	202010 <_ftoa+0x3b0>  // b.first
      // exactly 0.5 and ODD, then round up
      // 1.5 -> 2, but 2.5 -> 2
      ++whole;
  201d68:	12000140 	and	w0, w10, #0x1
  201d6c:	0b00014a 	add	w10, w10, w0
    }
  }

  // do whole part, number is reversed
  while (len < PRINTF_FTOA_BUFFER_SIZE) {
    buf[len++] = (char)(48 + (whole % 10));
  201d70:	528ccce1 	mov	w1, #0x6667                	// #26215
  201d74:	72acccc1 	movk	w1, #0x6666, lsl #16
  201d78:	52800142 	mov	w2, #0xa                   	// #10
  201d7c:	1400000a 	b	201da4 <_ftoa+0x144>
  201d80:	9362fd29 	asr	x9, x9, #34
  201d84:	91000508 	add	x8, x8, #0x1
  201d88:	4b8a7d29 	sub	w9, w9, w10, asr #31
  201d8c:	8b080180 	add	x0, x12, x8
  201d90:	1b02a92b 	msub	w11, w9, w2, w10
    if (!(whole /= 10)) {
  201d94:	2a0903ea 	mov	w10, w9
    buf[len++] = (char)(48 + (whole % 10));
  201d98:	1100c169 	add	w9, w11, #0x30
  201d9c:	381ff009 	sturb	w9, [x0, #-1]
    if (!(whole /= 10)) {
  201da0:	34000e4a 	cbz	w10, 201f68 <_ftoa+0x308>
    buf[len++] = (char)(48 + (whole % 10));
  201da4:	9b217d49 	smull	x9, w10, w1
  while (len < PRINTF_FTOA_BUFFER_SIZE) {
  201da8:	f100811f 	cmp	x8, #0x20
  201dac:	54fffea1 	b.ne	201d80 <_ftoa+0x120>  // b.any
      break;
    }
  }

  // pad leading zeros
  if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
  201db0:	120004e0 	and	w0, w7, #0x3
  201db4:	7100041f 	cmp	w0, #0x1
  201db8:	54000281 	b.ne	201e08 <_ftoa+0x1a8>  // b.any
    if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
  201dbc:	34000265 	cbz	w5, 201e08 <_ftoa+0x1a8>
  201dc0:	350013a3 	cbnz	w3, 202034 <_ftoa+0x3d4>
  201dc4:	721e04ff 	tst	w7, #0xc
  201dc8:	54001361 	b.ne	202034 <_ftoa+0x3d4>  // b.any
      width--;
    }
    while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
  201dcc:	2a0503e2 	mov	w2, w5
  201dd0:	eb02011f 	cmp	x8, x2
  201dd4:	54001002 	b.cs	201fd4 <_ftoa+0x374>  // b.hs, b.nlast
  201dd8:	f100811f 	cmp	x8, #0x20
      buf[len++] = '0';
  201ddc:	52800601 	mov	w1, #0x30                  	// #48
    while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
  201de0:	54000120 	b.eq	201e04 <_ftoa+0x1a4>  // b.none
  201de4:	d503201f 	nop
      buf[len++] = '0';
  201de8:	91000508 	add	x8, x8, #0x1
  201dec:	8b080180 	add	x0, x12, x8
    while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
  201df0:	eb02011f 	cmp	x8, x2
      buf[len++] = '0';
  201df4:	381ff001 	sturb	w1, [x0, #-1]
    while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
  201df8:	54000be0 	b.eq	201f74 <_ftoa+0x314>  // b.none
  201dfc:	f100811f 	cmp	x8, #0x20
  201e00:	54ffff41 	b.ne	201de8 <_ftoa+0x188>  // b.any
    }
    else if (flags & FLAGS_PLUS) {
      buf[len++] = '+';  // ignore the space if the '+' exists
    }
    else if (flags & FLAGS_SPACE) {
      buf[len++] = ' ';
  201e04:	d2800408 	mov	x8, #0x20                  	// #32
    }
  }

  return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
  201e08:	2a0503e6 	mov	w6, w5
  201e0c:	aa0c03e4 	mov	x4, x12
  201e10:	aa0803e5 	mov	x5, x8
  201e14:	aa1203e3 	mov	x3, x18
  201e18:	aa1103e2 	mov	x2, x17
  201e1c:	aa1003e1 	mov	x1, x16
  201e20:	aa0f03e0 	mov	x0, x15
  201e24:	97fffe6f 	bl	2017e0 <_out_rev>
}
  201e28:	a8c37bfd 	ldp	x29, x30, [sp], #48
  201e2c:	d65f03c0 	ret
    return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? "fni+" : "fni", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);
  201e30:	37100207 	tbnz	w7, #2, 201e70 <_ftoa+0x210>
  201e34:	d2800060 	mov	x0, #0x3                   	// #3
  201e38:	2a0503e6 	mov	w6, w5
  201e3c:	d0000004 	adrp	x4, 203000 <_vsnprintf+0xc00>
  201e40:	911fc084 	add	x4, x4, #0x7f0
  201e44:	aa0003e5 	mov	x5, x0
  201e48:	aa1203e3 	mov	x3, x18
  201e4c:	aa1103e2 	mov	x2, x17
  201e50:	aa1003e1 	mov	x1, x16
  201e54:	aa0f03e0 	mov	x0, x15
  201e58:	17fffe62 	b	2017e0 <_out_rev>
    return _out_rev(out, buffer, idx, maxlen, "nan", 3, width, flags);
  201e5c:	2a0503e6 	mov	w6, w5
  201e60:	d0000004 	adrp	x4, 203000 <_vsnprintf+0xc00>
  201e64:	d2800065 	mov	x5, #0x3                   	// #3
  201e68:	911fe084 	add	x4, x4, #0x7f8
  201e6c:	17fffe5d 	b	2017e0 <_out_rev>
    return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? "fni+" : "fni", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);
  201e70:	d2800080 	mov	x0, #0x4                   	// #4
  201e74:	2a0503e6 	mov	w6, w5
  201e78:	d0000004 	adrp	x4, 203000 <_vsnprintf+0xc00>
  201e7c:	911fa084 	add	x4, x4, #0x7e8
  201e80:	aa0003e5 	mov	x5, x0
  201e84:	aa1203e3 	mov	x3, x18
  201e88:	aa1103e2 	mov	x2, x17
  201e8c:	aa1003e1 	mov	x1, x16
  201e90:	aa0f03e0 	mov	x0, x15
  201e94:	17fffe53 	b	2017e0 <_out_rev>
    value = 0 - value;
  201e98:	2f00e401 	movi	d1, #0x0
    negative = true;
  201e9c:	52800023 	mov	w3, #0x1                   	// #1
    value = 0 - value;
  201ea0:	1e603820 	fsub	d0, d1, d0
  if (!(flags & FLAGS_PRECISION)) {
  201ea4:	3757f1c7 	tbnz	w7, #10, 201cdc <_ftoa+0x7c>
  201ea8:	d2d09000 	mov	x0, #0x848000000000        	// #145685290680320
  201eac:	910043ec 	add	x12, sp, #0x10
  201eb0:	f2e825c0 	movk	x0, #0x412e, lsl #48
    prec = PRINTF_DEFAULT_FLOAT_PRECISION;
  201eb4:	528000c4 	mov	w4, #0x6                   	// #6
  201eb8:	9e670002 	fmov	d2, x0
  201ebc:	d2800008 	mov	x8, #0x0                   	// #0
  201ec0:	17ffff96 	b	201d18 <_ftoa+0xb8>
    return _etoa(out, buffer, idx, maxlen, value, prec, width, flags);
  201ec4:	2a0703e6 	mov	w6, w7
  201ec8:	aa1203e3 	mov	x3, x18
  201ecc:	aa1103e2 	mov	x2, x17
  201ed0:	aa1003e1 	mov	x1, x16
  201ed4:	aa0f03e0 	mov	x0, x15
  201ed8:	14000066 	b	202070 <_etoa>
    return _out_rev(out, buffer, idx, maxlen, "fni-", 4, width, flags);
  201edc:	2a0503e6 	mov	w6, w5
  201ee0:	d0000004 	adrp	x4, 203000 <_vsnprintf+0xc00>
  201ee4:	d2800085 	mov	x5, #0x4                   	// #4
  201ee8:	91200084 	add	x4, x4, #0x800
  201eec:	17fffe3d 	b	2017e0 <_out_rev>
  201ef0:	51008081 	sub	w1, w4, #0x20
      buf[len++] = (char)(48U + (frac % 10U));
  201ef4:	b202e7e2 	mov	x2, #0xcccccccccccccccc    	// #-3689348814741910324
  201ef8:	0b080021 	add	w1, w1, w8
  201efc:	f29999a2 	movk	x2, #0xcccd
  201f00:	1400000d 	b	201f34 <_ftoa+0x2d4>
  201f04:	d343fd6b 	lsr	x11, x11, #3
      if (!(frac /= 10U)) {
  201f08:	f10025df 	cmp	x14, #0x9
      --count;
  201f0c:	51000480 	sub	w0, w4, #0x1
      buf[len++] = (char)(48U + (frac % 10U));
  201f10:	91000509 	add	x9, x8, #0x1
  201f14:	8b0b096d 	add	x13, x11, x11, lsl #2
  201f18:	cb0d05cd 	sub	x13, x14, x13, lsl #1
      if (!(frac /= 10U)) {
  201f1c:	aa0b03ee 	mov	x14, x11
      buf[len++] = (char)(48U + (frac % 10U));
  201f20:	1100c1ab 	add	w11, w13, #0x30
  201f24:	3828698b 	strb	w11, [x12, x8]
      if (!(frac /= 10U)) {
  201f28:	54000349 	b.ls	201f90 <_ftoa+0x330>  // b.plast
      --count;
  201f2c:	2a0003e4 	mov	w4, w0
      buf[len++] = (char)(48U + (frac % 10U));
  201f30:	aa0903e8 	mov	x8, x9
  201f34:	9bc27dcb 	umulh	x11, x14, x2
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
  201f38:	6b01009f 	cmp	w4, w1
  201f3c:	54fffe41 	b.ne	201f04 <_ftoa+0x2a4>  // b.any
      buf[len++] = (char)(48U + (frac % 10U));
  201f40:	d2800408 	mov	x8, #0x20                  	// #32
  201f44:	17ffff8b 	b	201d70 <_ftoa+0x110>
    ++frac;
  201f48:	910005ce 	add	x14, x14, #0x1
    if (frac >= pow10[prec]) {
  201f4c:	9e6301c1 	ucvtf	d1, x14
  201f50:	1e622030 	fcmpe	d1, d2
  201f54:	5400004a 	b.ge	201f5c <_ftoa+0x2fc>  // b.tcont
  201f58:	17ffff7e 	b	201d50 <_ftoa+0xf0>
      ++whole;
  201f5c:	1100054a 	add	w10, w10, #0x1
      frac = 0;
  201f60:	d280000e 	mov	x14, #0x0                   	// #0
  201f64:	17ffff7b 	b	201d50 <_ftoa+0xf0>
  if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
  201f68:	120004e0 	and	w0, w7, #0x3
  201f6c:	7100041f 	cmp	w0, #0x1
  201f70:	54000780 	b.eq	202060 <_ftoa+0x400>  // b.none
  if (len < PRINTF_FTOA_BUFFER_SIZE) {
  201f74:	f100811f 	cmp	x8, #0x20
  201f78:	54fff480 	b.eq	201e08 <_ftoa+0x1a8>  // b.none
    if (negative) {
  201f7c:	34000323 	cbz	w3, 201fe0 <_ftoa+0x380>
      buf[len++] = '-';
  201f80:	528005a0 	mov	w0, #0x2d                  	// #45
  201f84:	38286980 	strb	w0, [x12, x8]
  201f88:	91000508 	add	x8, x8, #0x1
  201f8c:	17ffff9f 	b	201e08 <_ftoa+0x1a8>
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
  201f90:	f100813f 	cmp	x9, #0x20
  201f94:	54fffd60 	b.eq	201f40 <_ftoa+0x2e0>  // b.none
  201f98:	91000901 	add	x1, x8, #0x2
  201f9c:	51000884 	sub	w4, w4, #0x2
  201fa0:	8b040021 	add	x1, x1, x4
      buf[len++] = '0';
  201fa4:	52800602 	mov	w2, #0x30                  	// #48
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
  201fa8:	35000080 	cbnz	w0, 201fb8 <_ftoa+0x358>
  201fac:	14000013 	b	201ff8 <_ftoa+0x398>
  201fb0:	eb01013f 	cmp	x9, x1
  201fb4:	54000260 	b.eq	202000 <_ftoa+0x3a0>  // b.none
      buf[len++] = '0';
  201fb8:	91000529 	add	x9, x9, #0x1
  201fbc:	8b090180 	add	x0, x12, x9
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
  201fc0:	f100813f 	cmp	x9, #0x20
      buf[len++] = '0';
  201fc4:	381ff002 	sturb	w2, [x0, #-1]
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
  201fc8:	54ffff41 	b.ne	201fb0 <_ftoa+0x350>  // b.any
      buf[len++] = (char)(48U + (frac % 10U));
  201fcc:	d2800408 	mov	x8, #0x20                  	// #32
  201fd0:	17ffff68 	b	201d70 <_ftoa+0x110>
  if (len < PRINTF_FTOA_BUFFER_SIZE) {
  201fd4:	f100811f 	cmp	x8, #0x20
  201fd8:	54fff180 	b.eq	201e08 <_ftoa+0x1a8>  // b.none
  201fdc:	d503201f 	nop
    else if (flags & FLAGS_PLUS) {
  201fe0:	371001c7 	tbnz	w7, #2, 202018 <_ftoa+0x3b8>
    else if (flags & FLAGS_SPACE) {
  201fe4:	361ff127 	tbz	w7, #3, 201e08 <_ftoa+0x1a8>
      buf[len++] = ' ';
  201fe8:	52800400 	mov	w0, #0x20                  	// #32
  201fec:	38286980 	strb	w0, [x12, x8]
  201ff0:	91000508 	add	x8, x8, #0x1
  201ff4:	17ffff85 	b	201e08 <_ftoa+0x1a8>
      buf[len++] = (char)(48U + (frac % 10U));
  201ff8:	aa0903e1 	mov	x1, x9
  201ffc:	d503201f 	nop
      buf[len++] = '.';
  202000:	528005c0 	mov	w0, #0x2e                  	// #46
  202004:	91000428 	add	x8, x1, #0x1
  202008:	38216980 	strb	w0, [x12, x1]
  20200c:	17ffff59 	b	201d70 <_ftoa+0x110>
    if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
  202010:	54ffeacc 	b.gt	201d68 <_ftoa+0x108>
  202014:	17ffff57 	b	201d70 <_ftoa+0x110>
      buf[len++] = '+';  // ignore the space if the '+' exists
  202018:	52800560 	mov	w0, #0x2b                  	// #43
  20201c:	38286980 	strb	w0, [x12, x8]
  202020:	91000508 	add	x8, x8, #0x1
  202024:	17ffff79 	b	201e08 <_ftoa+0x1a8>
  else if ((frac == 0U) || (frac & 1U)) {
  202028:	3607e94e 	tbz	w14, #0, 201d50 <_ftoa+0xf0>
    ++frac;
  20202c:	910005ce 	add	x14, x14, #0x1
  202030:	17ffff48 	b	201d50 <_ftoa+0xf0>
      width--;
  202034:	510004a2 	sub	w2, w5, #0x1
  202038:	aa0203e5 	mov	x5, x2
    while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
  20203c:	eb08005f 	cmp	x2, x8
  202040:	54ffecc8 	b.hi	201dd8 <_ftoa+0x178>  // b.pmore
  202044:	17ffffcc 	b	201f74 <_ftoa+0x314>
  double tmp = (value - whole) * pow10[prec];
  202048:	b0000000 	adrp	x0, 203000 <_vsnprintf+0xc00>
  20204c:	91160000 	add	x0, x0, #0x580
  202050:	910043ec 	add	x12, sp, #0x10
  202054:	d2800008 	mov	x8, #0x0                   	// #0
  202058:	fc645802 	ldr	d2, [x0, w4, uxtw #3]
  20205c:	17ffff2f 	b	201d18 <_ftoa+0xb8>
    if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
  202060:	34fff8a5 	cbz	w5, 201f74 <_ftoa+0x314>
  202064:	17ffff57 	b	201dc0 <_ftoa+0x160>
  202068:	d503201f 	nop
  20206c:	d503201f 	nop

0000000000202070 <_etoa>:


#if defined(PRINTF_SUPPORT_EXPONENTIAL)
// internal ftoa variant for exponential floating-point type, contributed by Martijn Jasperse <m.jasperse@gmail.com>
static size_t _etoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags)
{
  202070:	d10203ff 	sub	sp, sp, #0x80
  // check for NaN and special values
  if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {
  202074:	1e602000 	fcmp	d0, d0
{
  202078:	a9017bfd 	stp	x29, x30, [sp, #16]
  20207c:	910043fd 	add	x29, sp, #0x10
  202080:	a90253f3 	stp	x19, x20, [sp, #32]
  202084:	aa0203f3 	mov	x19, x2
  202088:	2a0603f4 	mov	w20, w6
  20208c:	a9035bf5 	stp	x21, x22, [sp, #48]
  202090:	aa0003f5 	mov	x21, x0
  202094:	aa0103f6 	mov	x22, x1
  202098:	a90463f7 	stp	x23, x24, [sp, #64]
  20209c:	aa0303f7 	mov	x23, x3
  2020a0:	a90673fb 	stp	x27, x28, [sp, #96]
  2020a4:	2a0503fb 	mov	w27, w5
  if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {
  2020a8:	540012c1 	b.ne	202300 <_etoa+0x290>  // b.any
  2020ac:	92f00200 	mov	x0, #0x7fefffffffffffff    	// #9218868437227405311
  2020b0:	9e670001 	fmov	d1, x0
  2020b4:	1e612010 	fcmpe	d0, d1
  2020b8:	5400124c 	b.gt	202300 <_etoa+0x290>
  2020bc:	92e00200 	mov	x0, #0xffefffffffffffff    	// #-4503599627370497
  2020c0:	9e670001 	fmov	d1, x0
  2020c4:	1e612010 	fcmpe	d0, d1
  2020c8:	540011c4 	b.mi	202300 <_etoa+0x290>  // b.first
    return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);
  }

  // determine the sign
  const bool negative = value < 0;
  if (negative) {
  2020cc:	1e602018 	fcmpe	d0, #0.0
  2020d0:	1e614002 	fneg	d2, d0

  conv.F = value;
  int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;           // effectively log2
  conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
  // now approximate log10 from the log2 integer part and an expansion of ln around 1.5
  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
  2020d4:	b0000000 	adrp	x0, 203000 <_vsnprintf+0xc00>
  2020d8:	fd441c16 	ldr	d22, [x0, #2104]
  2020dc:	b0000000 	adrp	x0, 203000 <_vsnprintf+0xc00>
  2020e0:	fd442001 	ldr	d1, [x0, #2112]
  2020e4:	b0000000 	adrp	x0, 203000 <_vsnprintf+0xc00>
  2020e8:	fd442415 	ldr	d21, [x0, #2120]
  2020ec:	1e604c42 	fcsel	d2, d2, d0, mi	// mi = first
  // now we want to compute 10^expval but we want to be sure it won't overflow
  exp2 = (int)(expval * 3.321928094887362 + 0.5);
  2020f0:	b0000000 	adrp	x0, 203000 <_vsnprintf+0xc00>
  2020f4:	fd442814 	ldr	d20, [x0, #2128]
  const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
  2020f8:	b0000000 	adrp	x0, 203000 <_vsnprintf+0xc00>
  2020fc:	fd442c13 	ldr	d19, [x0, #2136]
  202100:	b0000000 	adrp	x0, 203000 <_vsnprintf+0xc00>
  202104:	fd443012 	ldr	d18, [x0, #2144]
  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
  202108:	1e6f1018 	fmov	d24, #1.500000000000000000e+00
  conv.F = value;
  20210c:	9e660040 	fmov	x0, d2
  202110:	a9056bf9 	stp	x25, x26, [sp, #80]
  exp2 = (int)(expval * 3.321928094887362 + 0.5);
  202114:	1e6c1005 	fmov	d5, #5.000000000000000000e-01
  const double z2 = z * z;
  conv.U = (uint64_t)(exp2 + 1023) << 52U;
  // compute exp(z) using continued fractions, see https://en.wikipedia.org/wiki/Exponential_function#Continued_fractions_for_ex
  conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
  202118:	1e659003 	fmov	d3, #1.400000000000000000e+01
  20211c:	1e649007 	fmov	d7, #1.000000000000000000e+01
  202120:	1e631011 	fmov	d17, #6.000000000000000000e+00
  202124:	1e601006 	fmov	d6, #2.000000000000000000e+00
  conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
  202128:	9240cc01 	and	x1, x0, #0xfffffffffffff
  int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;           // effectively log2
  20212c:	d374f800 	ubfx	x0, x0, #52, #11
  202130:	510ffc00 	sub	w0, w0, #0x3ff
  conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
  202134:	b24c2421 	orr	x1, x1, #0x3ff0000000000000
  202138:	9e670024 	fmov	d4, x1
  conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
  20213c:	1e6e1010 	fmov	d16, #1.000000000000000000e+00
  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
  202140:	1e620017 	scvtf	d23, w0
    prec = PRINTF_DEFAULT_FLOAT_PRECISION;
  202144:	721600c3 	ands	w3, w6, #0x400
  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
  202148:	1e783884 	fsub	d4, d4, d24
    prec = PRINTF_DEFAULT_FLOAT_PRECISION;
  20214c:	528000c2 	mov	w2, #0x6                   	// #6
  202150:	1a821084 	csel	w4, w4, w2, ne	// ne = any
  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
  202154:	1f5606e1 	fmadd	d1, d23, d22, d1
  202158:	1f550481 	fmadd	d1, d4, d21, d1
  20215c:	1e780039 	fcvtzs	w25, d1
  exp2 = (int)(expval * 3.321928094887362 + 0.5);
  202160:	1e620324 	scvtf	d4, w25
  202164:	1f541481 	fmadd	d1, d4, d20, d5
  202168:	1e780020 	fcvtzs	w0, d1
  const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
  20216c:	1e620001 	scvtf	d1, w0
  conv.U = (uint64_t)(exp2 + 1023) << 52U;
  202170:	110ffc00 	add	w0, w0, #0x3ff
  202174:	9e670005 	fmov	d5, x0
  202178:	5f7454a5 	shl	d5, d5, #52
  const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
  20217c:	1e730821 	fmul	d1, d1, d19
  202180:	1f728481 	fnmsub	d1, d4, d18, d1
  const double z2 = z * z;
  202184:	1e610824 	fmul	d4, d1, d1
  conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
  202188:	1e6138c6 	fsub	d6, d6, d1
  20218c:	1e612821 	fadd	d1, d1, d1
  202190:	1e631883 	fdiv	d3, d4, d3
  202194:	1e672863 	fadd	d3, d3, d7
  202198:	1e631883 	fdiv	d3, d4, d3
  20219c:	1e712863 	fadd	d3, d3, d17
  2021a0:	1e631884 	fdiv	d4, d4, d3
  2021a4:	1e662884 	fadd	d4, d4, d6
  2021a8:	1e641821 	fdiv	d1, d1, d4
  2021ac:	1e702821 	fadd	d1, d1, d16
  2021b0:	1e650821 	fmul	d1, d1, d5
  // correct for rounding errors
  if (value < conv.F) {
  2021b4:	1e612050 	fcmpe	d2, d1
  2021b8:	54000be4 	b.mi	202334 <_etoa+0x2c4>  // b.first
    expval--;
    conv.F /= 10;
  }

  // the exponent format is "%+03d" and largest value is "307", so set aside 4-5 characters
  unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
  2021bc:	11018f20 	add	w0, w25, #0x63
  2021c0:	7103181f 	cmp	w0, #0xc6
  2021c4:	1a9f97fc 	cset	w28, hi	// hi = pmore
  2021c8:	1100139c 	add	w28, w28, #0x4

  // in "%g" mode, "prec" is the number of *significant figures* not decimals
  if (flags & FLAGS_ADAPT_EXP) {
  2021cc:	36580134 	tbz	w20, #11, 2021f0 <_etoa+0x180>
    // do we want to fall-back to "%f" mode?
    if ((value >= 1e-4) && (value < 1e6)) {
  2021d0:	b0000000 	adrp	x0, 203000 <_vsnprintf+0xc00>
  2021d4:	fd443403 	ldr	d3, [x0, #2152]
  2021d8:	1e632050 	fcmpe	d2, d3
  2021dc:	54000cea 	b.ge	202378 <_etoa+0x308>  // b.tcont
      minwidth = 0U;
      expval   = 0;
    }
    else {
      // we use one sigfig for the whole part
      if ((prec > 0) && (flags & FLAGS_PRECISION)) {
  2021e0:	34000084 	cbz	w4, 2021f0 <_etoa+0x180>
        --prec;
  2021e4:	7100007f 	cmp	w3, #0x0
  2021e8:	1a9f07e0 	cset	w0, ne	// ne = any
  2021ec:	4b000084 	sub	w4, w4, w0

  // will everything fit?
  unsigned int fwidth = width;
  if (width > minwidth) {
    // we didn't fall-back so subtract the characters required for the exponent
    fwidth -= minwidth;
  2021f0:	6b1c0365 	subs	w5, w27, w28
  } else {
    // not enough characters, so go back to default sizing
    fwidth = 0U;
  }
  if ((flags & FLAGS_LEFT) && minwidth) {
  2021f4:	121f0280 	and	w0, w20, #0x2
    fwidth -= minwidth;
  2021f8:	1a9f80a5 	csel	w5, w5, wzr, hi	// hi = pmore
  if ((flags & FLAGS_LEFT) && minwidth) {
  2021fc:	7100001f 	cmp	w0, #0x0
  202200:	1a9f07e0 	cset	w0, ne	// ne = any
  202204:	b9007fe0 	str	w0, [sp, #124]
  202208:	1a9f00a5 	csel	w5, w5, wzr, eq	// eq = none
    // if we're padding on the right, DON'T pad the floating part
    fwidth = 0U;
  }

  // rescale the float value
  if (expval) {
  20220c:	5280003a 	mov	w26, #0x1                   	// #1
  202210:	34000059 	cbz	w25, 202218 <_etoa+0x1a8>
    value /= conv.F;
  202214:	1e611842 	fdiv	d2, d2, d1
  }

  // output the floating part
  const size_t start_idx = idx;
  idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
  202218:	1e602018 	fcmpe	d0, #0.0
  20221c:	54000aa4 	b.mi	202370 <_etoa+0x300>  // b.first
  202220:	1e604040 	fmov	d0, d2
  202224:	12147a86 	and	w6, w20, #0xfffff7ff
  202228:	aa1703e3 	mov	x3, x23
  20222c:	aa1303e2 	mov	x2, x19
  202230:	aa1603e1 	mov	x1, x22
  202234:	aa1503e0 	mov	x0, x21
  202238:	97fffe8a 	bl	201c60 <_ftoa>
  20223c:	aa0003f8 	mov	x24, x0

  // output the exponent part
  if (minwidth) {
  202240:	340004fa 	cbz	w26, 2022dc <_etoa+0x26c>
    // output the exponential symbol
    out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);
  202244:	f27b029f 	tst	x20, #0x20
  202248:	52800ca1 	mov	w1, #0x65                  	// #101
  20224c:	aa1803e2 	mov	x2, x24
  202250:	aa1703e3 	mov	x3, x23
  202254:	528008a0 	mov	w0, #0x45                  	// #69
  202258:	1a800020 	csel	w0, w1, w0, eq	// eq = none
  20225c:	aa1603e1 	mov	x1, x22
  202260:	d63f02a0 	blr	x21
    // output the exponent value
    idx = _ntoa_long(out, buffer, idx, maxlen, (expval < 0) ? -expval : expval, expval < 0, 10, 0, minwidth-1, FLAGS_ZEROPAD | FLAGS_PLUS);
  202264:	7100033f 	cmp	w25, #0x0
  202268:	528000a0 	mov	w0, #0x5                   	// #5
  20226c:	5a99a724 	cneg	w4, w25, lt	// lt = tstop
  202270:	5100079c 	sub	w28, w28, #0x1
  202274:	b90003fc 	str	w28, [sp]
    out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);
  202278:	91000702 	add	x2, x24, #0x1
    idx = _ntoa_long(out, buffer, idx, maxlen, (expval < 0) ? -expval : expval, expval < 0, 10, 0, minwidth-1, FLAGS_ZEROPAD | FLAGS_PLUS);
  20227c:	b9000be0 	str	w0, [sp, #8]
  202280:	93407c84 	sxtw	x4, w4
  202284:	531f7f25 	lsr	w5, w25, #31
  202288:	aa1703e3 	mov	x3, x23
  20228c:	aa1603e1 	mov	x1, x22
  202290:	aa1503e0 	mov	x0, x21
  202294:	52800007 	mov	w7, #0x0                   	// #0
  202298:	d2800146 	mov	x6, #0xa                   	// #10
  20229c:	97fffd95 	bl	2018f0 <_ntoa_long>
  2022a0:	aa0003f8 	mov	x24, x0
    // might need to right-pad spaces
    if (flags & FLAGS_LEFT) {
  2022a4:	b9407fe0 	ldr	w0, [sp, #124]
  2022a8:	340001a0 	cbz	w0, 2022dc <_etoa+0x26c>
      while (idx - start_idx < width) out(' ', buffer, idx++, maxlen);
  2022ac:	cb130313 	sub	x19, x24, x19
  2022b0:	eb13037f 	cmp	x27, x19
  2022b4:	54000149 	b.ls	2022dc <_etoa+0x26c>  // b.plast
  2022b8:	aa1803e2 	mov	x2, x24
  2022bc:	91000673 	add	x19, x19, #0x1
  2022c0:	aa1703e3 	mov	x3, x23
  2022c4:	aa1603e1 	mov	x1, x22
  2022c8:	52800400 	mov	w0, #0x20                  	// #32
  2022cc:	d63f02a0 	blr	x21
  2022d0:	91000718 	add	x24, x24, #0x1
  2022d4:	eb1b027f 	cmp	x19, x27
  2022d8:	54ffff03 	b.cc	2022b8 <_etoa+0x248>  // b.lo, b.ul, b.last
    }
  }
  return idx;
}
  2022dc:	a9417bfd 	ldp	x29, x30, [sp, #16]
  2022e0:	aa1803e0 	mov	x0, x24
  2022e4:	a94253f3 	ldp	x19, x20, [sp, #32]
  2022e8:	a9435bf5 	ldp	x21, x22, [sp, #48]
  2022ec:	a94463f7 	ldp	x23, x24, [sp, #64]
  2022f0:	a9456bf9 	ldp	x25, x26, [sp, #80]
  2022f4:	a94673fb 	ldp	x27, x28, [sp, #96]
  2022f8:	910203ff 	add	sp, sp, #0x80
  2022fc:	d65f03c0 	ret
    return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);
  202300:	2a1403e6 	mov	w6, w20
  202304:	2a1b03e5 	mov	w5, w27
  202308:	aa1703e3 	mov	x3, x23
  20230c:	aa1303e2 	mov	x2, x19
  202310:	aa1603e1 	mov	x1, x22
  202314:	aa1503e0 	mov	x0, x21
}
  202318:	a9417bfd 	ldp	x29, x30, [sp, #16]
  20231c:	a94253f3 	ldp	x19, x20, [sp, #32]
  202320:	a9435bf5 	ldp	x21, x22, [sp, #48]
  202324:	a94463f7 	ldp	x23, x24, [sp, #64]
  202328:	a94673fb 	ldp	x27, x28, [sp, #96]
  20232c:	910203ff 	add	sp, sp, #0x80
  idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
  202330:	17fffe4c 	b	201c60 <_ftoa>
    conv.F /= 10;
  202334:	1e671821 	fdiv	d1, d1, d7
    expval--;
  202338:	51000739 	sub	w25, w25, #0x1
  unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
  20233c:	11018f20 	add	w0, w25, #0x63
  202340:	7103181f 	cmp	w0, #0xc6
  202344:	1a9f97fc 	cset	w28, hi	// hi = pmore
  202348:	1100139c 	add	w28, w28, #0x4
  if (flags & FLAGS_ADAPT_EXP) {
  20234c:	365ff534 	tbz	w20, #11, 2021f0 <_etoa+0x180>
  202350:	17ffffa0 	b	2021d0 <_etoa+0x160>
      flags |= FLAGS_PRECISION;   // make sure _ftoa respects precision
  202354:	2a0103f4 	mov	w20, w1
    fwidth = 0U;
  202358:	52800005 	mov	w5, #0x0                   	// #0
      minwidth = 0U;
  20235c:	5280001c 	mov	w28, #0x0                   	// #0
  if ((flags & FLAGS_LEFT) && minwidth) {
  202360:	5280001a 	mov	w26, #0x0                   	// #0
      expval   = 0;
  202364:	52800019 	mov	w25, #0x0                   	// #0
  if ((flags & FLAGS_LEFT) && minwidth) {
  202368:	b9007fff 	str	wzr, [sp, #124]
  20236c:	d503201f 	nop
  idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
  202370:	1e614042 	fneg	d2, d2
  202374:	17ffffab 	b	202220 <_etoa+0x1b0>
    if ((value >= 1e-4) && (value < 1e6)) {
  202378:	d2d09000 	mov	x0, #0x848000000000        	// #145685290680320
  20237c:	f2e825c0 	movk	x0, #0x412e, lsl #48
  202380:	9e670003 	fmov	d3, x0
  202384:	1e632050 	fcmpe	d2, d3
  202388:	54000044 	b.mi	202390 <_etoa+0x320>  // b.first
  20238c:	17ffff95 	b	2021e0 <_etoa+0x170>
        prec = (unsigned)((int)prec - expval - 1);
  202390:	4b190080 	sub	w0, w4, w25
  202394:	6b04033f 	cmp	w25, w4
  202398:	51000400 	sub	w0, w0, #0x1
      flags |= FLAGS_PRECISION;   // make sure _ftoa respects precision
  20239c:	32160281 	orr	w1, w20, #0x400
        prec = (unsigned)((int)prec - expval - 1);
  2023a0:	1a9fb004 	csel	w4, w0, wzr, lt	// lt = tstop
  if (width > minwidth) {
  2023a4:	350001bb 	cbnz	w27, 2023d8 <_etoa+0x368>
  idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
  2023a8:	1e602018 	fcmpe	d0, #0.0
  2023ac:	54fffd44 	b.mi	202354 <_etoa+0x2e4>  // b.first
  2023b0:	12147a86 	and	w6, w20, #0xfffff7ff
  2023b4:	1e604040 	fmov	d0, d2
  2023b8:	a9456bf9 	ldp	x25, x26, [sp, #80]
  2023bc:	321600c6 	orr	w6, w6, #0x400
  2023c0:	aa1703e3 	mov	x3, x23
  2023c4:	aa1303e2 	mov	x2, x19
  2023c8:	aa1603e1 	mov	x1, x22
  2023cc:	aa1503e0 	mov	x0, x21
  2023d0:	52800005 	mov	w5, #0x0                   	// #0
  2023d4:	17ffffd1 	b	202318 <_etoa+0x2a8>
      flags |= FLAGS_PRECISION;   // make sure _ftoa respects precision
  2023d8:	2a0103f4 	mov	w20, w1
  if (width > minwidth) {
  2023dc:	2a1b03e5 	mov	w5, w27
      minwidth = 0U;
  2023e0:	5280001c 	mov	w28, #0x0                   	// #0
  if (width > minwidth) {
  2023e4:	52800019 	mov	w25, #0x0                   	// #0
  2023e8:	5280001a 	mov	w26, #0x0                   	// #0
  2023ec:	b9007fff 	str	wzr, [sp, #124]
  2023f0:	17ffff8a 	b	202218 <_etoa+0x1a8>
  2023f4:	d503201f 	nop
  2023f8:	d503201f 	nop
  2023fc:	d503201f 	nop

0000000000202400 <_vsnprintf>:
#endif  // PRINTF_SUPPORT_FLOAT


// internal vsnprintf
static int _vsnprintf(out_fct_type out, char* buffer, const size_t maxlen, const char* format, va_list va)
{
  202400:	d102c3ff 	sub	sp, sp, #0xb0
  unsigned int flags, width, precision, n;
  size_t idx = 0U;

  if (!buffer) {
    // use null output function
    out = _out_null;
  202404:	f100003f 	cmp	x1, #0x0
{
  202408:	a9017bfd 	stp	x29, x30, [sp, #16]
  20240c:	910043fd 	add	x29, sp, #0x10
  202410:	a90253f3 	stp	x19, x20, [sp, #32]
    out = _out_null;
  202414:	f0fffff3 	adrp	x19, 201000 <init+0x250>
  202418:	911f4273 	add	x19, x19, #0x7d0
{
  20241c:	a9035bf5 	stp	x21, x22, [sp, #48]
    out = _out_null;
  202420:	9a800273 	csel	x19, x19, x0, eq	// eq = none
{
  202424:	aa0103f5 	mov	x21, x1
  202428:	a90463f7 	stp	x23, x24, [sp, #64]
  20242c:	aa0203f4 	mov	x20, x2
  202430:	b9401898 	ldr	w24, [x4, #24]
  202434:	a90673fb 	stp	x27, x28, [sp, #96]
  }

  while (*format)
  202438:	d280001c 	mov	x28, #0x0                   	// #0
  20243c:	f9400880 	ldr	x0, [x4, #16]
  202440:	f9004fe0 	str	x0, [sp, #152]
  202444:	39400061 	ldrb	w1, [x3]
  202448:	a9400896 	ldp	x22, x2, [x4]
  20244c:	f90047e2 	str	x2, [sp, #136]
  202450:	b9401c80 	ldr	w0, [x4, #28]
  202454:	b90077e0 	str	w0, [sp, #116]
  202458:	34004141 	cbz	w1, 202c80 <_vsnprintf+0x880>
      default :
        break;
    }

    // evaluate specifier
    switch (*format) {
  20245c:	d280003b 	mov	x27, #0x1                   	// #1
  202460:	a9056bf9 	stp	x25, x26, [sp, #80]
  202464:	b0000019 	adrp	x25, 203000 <_vsnprintf+0xc00>
  202468:	9113c320 	add	x0, x25, #0x4f0
  20246c:	aa0303fa 	mov	x26, x3
  202470:	f9003fe0 	str	x0, [sp, #120]
  202474:	1400000a 	b	20249c <_vsnprintf+0x9c>
      out(*format, buffer, idx++, maxlen);
  202478:	91000784 	add	x4, x28, #0x1
  20247c:	2a0103e0 	mov	w0, w1
        out('%', buffer, idx++, maxlen);
        format++;
        break;

      default :
        out(*format, buffer, idx++, maxlen);
  202480:	aa1c03e2 	mov	x2, x28
  202484:	aa1403e3 	mov	x3, x20
  202488:	aa1503e1 	mov	x1, x21
  20248c:	aa0403fc 	mov	x28, x4
  202490:	d63f0260 	blr	x19
  while (*format)
  202494:	39400341 	ldrb	w1, [x26]
  202498:	34000cc1 	cbz	w1, 202630 <_vsnprintf+0x230>
      format++;
  20249c:	9100075a 	add	x26, x26, #0x1
    if (*format != '%') {
  2024a0:	7100943f 	cmp	w1, #0x25
  2024a4:	54fffea1 	b.ne	202478 <_vsnprintf+0x78>  // b.any
      switch (*format) {
  2024a8:	aa1a03e1 	mov	x1, x26
    flags = 0U;
  2024ac:	52800006 	mov	w6, #0x0                   	// #0
      switch (*format) {
  2024b0:	38401420 	ldrb	w0, [x1], #1
  2024b4:	7100ac1f 	cmp	w0, #0x2b
  2024b8:	540001a0 	b.eq	2024ec <_vsnprintf+0xec>  // b.none
  2024bc:	d503201f 	nop
  2024c0:	540001c8 	b.hi	2024f8 <_vsnprintf+0xf8>  // b.pmore
  2024c4:	7100801f 	cmp	w0, #0x20
  2024c8:	54000260 	b.eq	202514 <_vsnprintf+0x114>  // b.none
  2024cc:	71008c1f 	cmp	w0, #0x23
  2024d0:	540002e1 	b.ne	20252c <_vsnprintf+0x12c>  // b.any
        case '#': flags |= FLAGS_HASH;    format++; n = 1U; break;
  2024d4:	321c00c6 	orr	w6, w6, #0x10
      format++;
  2024d8:	aa0103fa 	mov	x26, x1
      switch (*format) {
  2024dc:	aa1a03e1 	mov	x1, x26
  2024e0:	38401420 	ldrb	w0, [x1], #1
  2024e4:	7100ac1f 	cmp	w0, #0x2b
  2024e8:	54fffec1 	b.ne	2024c0 <_vsnprintf+0xc0>  // b.any
        case '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;
  2024ec:	321e00c6 	orr	w6, w6, #0x4
      format++;
  2024f0:	aa0103fa 	mov	x26, x1
  2024f4:	17fffffa 	b	2024dc <_vsnprintf+0xdc>
      switch (*format) {
  2024f8:	7100b41f 	cmp	w0, #0x2d
  2024fc:	54000120 	b.eq	202520 <_vsnprintf+0x120>  // b.none
  202500:	7100c01f 	cmp	w0, #0x30
  202504:	54005fe1 	b.ne	203100 <_vsnprintf+0xd00>  // b.any
        case '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;
  202508:	320000c6 	orr	w6, w6, #0x1
      format++;
  20250c:	aa0103fa 	mov	x26, x1
  202510:	17fffff3 	b	2024dc <_vsnprintf+0xdc>
        case ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;
  202514:	321d00c6 	orr	w6, w6, #0x8
      format++;
  202518:	aa0103fa 	mov	x26, x1
  20251c:	17fffff0 	b	2024dc <_vsnprintf+0xdc>
        case '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;
  202520:	321f00c6 	orr	w6, w6, #0x2
      format++;
  202524:	aa0103fa 	mov	x26, x1
  202528:	17ffffed 	b	2024dc <_vsnprintf+0xdc>
    else if (*format == '*') {
  20252c:	7100a81f 	cmp	w0, #0x2a
  202530:	54000ae0 	b.eq	20268c <_vsnprintf+0x28c>  // b.none
    width = 0U;
  202534:	52800019 	mov	w25, #0x0                   	// #0
    precision = 0U;
  202538:	52800017 	mov	w23, #0x0                   	// #0
    switch (*format) {
  20253c:	7101b01f 	cmp	w0, #0x6c
        format++;
  202540:	aa0103e2 	mov	x2, x1
    switch (*format) {
  202544:	54000de0 	b.eq	202700 <_vsnprintf+0x300>  // b.none
  202548:	54000969 	b.ls	202674 <_vsnprintf+0x274>  // b.plast
  20254c:	7101d01f 	cmp	w0, #0x74
  202550:	54000060 	b.eq	20255c <_vsnprintf+0x15c>  // b.none
  202554:	7101e81f 	cmp	w0, #0x7a
  202558:	54000241 	b.ne	2025a0 <_vsnprintf+0x1a0>  // b.any
        if (*format == 'l') {
  20255c:	39400740 	ldrb	w0, [x26, #1]
        flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
  202560:	321800c6 	orr	w6, w6, #0x100
        format++;
  202564:	9100045a 	add	x26, x2, #0x1
    switch (*format) {
  202568:	71019c1f 	cmp	w0, #0x67
  20256c:	540001e8 	b.hi	2025a8 <_vsnprintf+0x1a8>  // b.pmore
  202570:	7100901f 	cmp	w0, #0x24
  202574:	54000089 	b.ls	202584 <_vsnprintf+0x184>  // b.plast
  202578:	51009401 	sub	w1, w0, #0x25
  20257c:	7101083f 	cmp	w1, #0x42
  202580:	54000069 	b.ls	20258c <_vsnprintf+0x18c>  // b.plast
        out(*format, buffer, idx++, maxlen);
  202584:	91000784 	add	x4, x28, #0x1
  202588:	17ffffbe 	b	202480 <_vsnprintf+0x80>
    switch (*format) {
  20258c:	f9403fe2 	ldr	x2, [sp, #120]
  202590:	78615841 	ldrh	w1, [x2, w1, uxtw #1]
  202594:	10000062 	adr	x2, 2025a0 <_vsnprintf+0x1a0>
  202598:	8b21a841 	add	x1, x2, w1, sxth #2
  20259c:	d61f0020 	br	x1
        format++;
  2025a0:	aa0103fa 	mov	x26, x1
  2025a4:	d503201f 	nop
    switch (*format) {
  2025a8:	5101a401 	sub	w1, w0, #0x69
  2025ac:	12001c21 	and	w1, w1, #0xff
  2025b0:	71003c3f 	cmp	w1, #0xf
  2025b4:	54fffe88 	b.hi	202584 <_vsnprintf+0x184>  // b.pmore
  2025b8:	9ac12362 	lsl	x2, x27, x1
  2025bc:	d2920823 	mov	x3, #0x9041                	// #36929
  2025c0:	ea03005f 	tst	x2, x3
  2025c4:	54003021 	b.ne	202bc8 <_vsnprintf+0x7c8>  // b.any
  2025c8:	7100283f 	cmp	w1, #0xa
  2025cc:	540014a0 	b.eq	202860 <_vsnprintf+0x460>  // b.none
  2025d0:	71001c3f 	cmp	w1, #0x7
  2025d4:	54fffd81 	b.ne	202584 <_vsnprintf+0x184>  // b.any
        flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
  2025d8:	52800420 	mov	w0, #0x21                  	// #33
  2025dc:	2a0000c0 	orr	w0, w6, w0
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
  2025e0:	37f820f8 	tbnz	w24, #31, 2029fc <_vsnprintf+0x5fc>
  2025e4:	91003ec2 	add	x2, x22, #0xf
  2025e8:	aa1603e1 	mov	x1, x22
  2025ec:	927df056 	and	x22, x2, #0xfffffffffffffff8
  2025f0:	2a1703e7 	mov	w7, w23
  2025f4:	aa1c03e2 	mov	x2, x28
  2025f8:	f9400024 	ldr	x4, [x1]
  2025fc:	d2800206 	mov	x6, #0x10                  	// #16
  202600:	52800201 	mov	w1, #0x10                  	// #16
  202604:	b90003e1 	str	w1, [sp]
  202608:	b9000be0 	str	w0, [sp, #8]
  20260c:	52800005 	mov	w5, #0x0                   	// #0
  202610:	aa1503e1 	mov	x1, x21
  202614:	aa1403e3 	mov	x3, x20
  202618:	aa1303e0 	mov	x0, x19
  20261c:	97fffcb5 	bl	2018f0 <_ntoa_long>
  while (*format)
  202620:	39400341 	ldrb	w1, [x26]
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
  202624:	aa0003fc 	mov	x28, x0
  while (*format)
  202628:	35fff3a1 	cbnz	w1, 20249c <_vsnprintf+0x9c>
  20262c:	d503201f 	nop
  202630:	a9456bf9 	ldp	x25, x26, [sp, #80]

  // termination
  out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);

  // return written chars without terminating \0
  return (int)idx;
  202634:	2a1c03f6 	mov	w22, w28
  out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
  202638:	eb1c029f 	cmp	x20, x28
  20263c:	d1000682 	sub	x2, x20, #0x1
  202640:	aa1503e1 	mov	x1, x21
  202644:	9a9c9042 	csel	x2, x2, x28, ls	// ls = plast
  202648:	aa1403e3 	mov	x3, x20
  20264c:	52800000 	mov	w0, #0x0                   	// #0
  202650:	d63f0260 	blr	x19
}
  202654:	a9417bfd 	ldp	x29, x30, [sp, #16]
  202658:	2a1603e0 	mov	w0, w22
  20265c:	a94253f3 	ldp	x19, x20, [sp, #32]
  202660:	a9435bf5 	ldp	x21, x22, [sp, #48]
  202664:	a94463f7 	ldp	x23, x24, [sp, #64]
  202668:	a94673fb 	ldp	x27, x28, [sp, #96]
  20266c:	9102c3ff 	add	sp, sp, #0xb0
  202670:	d65f03c0 	ret
    switch (*format) {
  202674:	7101a01f 	cmp	w0, #0x68
  202678:	54000ea0 	b.eq	20284c <_vsnprintf+0x44c>  // b.none
  20267c:	7101a81f 	cmp	w0, #0x6a
  202680:	54fff6e0 	b.eq	20255c <_vsnprintf+0x15c>  // b.none
  202684:	aa1a03e2 	mov	x2, x26
  202688:	17ffffb7 	b	202564 <_vsnprintf+0x164>
      const int w = va_arg(va, int);
  20268c:	37f80498 	tbnz	w24, #31, 20271c <_vsnprintf+0x31c>
  202690:	91002ec2 	add	x2, x22, #0xb
  202694:	aa1603e0 	mov	x0, x22
  202698:	927df056 	and	x22, x2, #0xfffffffffffffff8
  20269c:	b9400019 	ldr	w25, [x0]
      if (w < 0) {
  2026a0:	36f80079 	tbz	w25, #31, 2026ac <_vsnprintf+0x2ac>
        flags |= FLAGS_LEFT;    // reverse padding
  2026a4:	321f00c6 	orr	w6, w6, #0x2
        width = (unsigned int)-w;
  2026a8:	4b1903f9 	neg	w25, w25
    if (*format == '.') {
  2026ac:	39400740 	ldrb	w0, [x26, #1]
      format++;
  2026b0:	aa0103fa 	mov	x26, x1
  2026b4:	91000421 	add	x1, x1, #0x1
    if (*format == '.') {
  2026b8:	7100b81f 	cmp	w0, #0x2e
    precision = 0U;
  2026bc:	52800017 	mov	w23, #0x0                   	// #0
    if (*format == '.') {
  2026c0:	54fff3e1 	b.ne	20253c <_vsnprintf+0x13c>  // b.any
      if (_is_digit(*format)) {
  2026c4:	39400740 	ldrb	w0, [x26, #1]
      flags |= FLAGS_PRECISION;
  2026c8:	321600c6 	orr	w6, w6, #0x400
      format++;
  2026cc:	aa0103e2 	mov	x2, x1
  return (ch >= '0') && (ch <= '9');
  2026d0:	5100c003 	sub	w3, w0, #0x30
      if (_is_digit(*format)) {
  2026d4:	12001c63 	and	w3, w3, #0xff
  2026d8:	7100247f 	cmp	w3, #0x9
  2026dc:	54001489 	b.ls	20296c <_vsnprintf+0x56c>  // b.plast
      else if (*format == '*') {
  2026e0:	7100a81f 	cmp	w0, #0x2a
  2026e4:	540025c0 	b.eq	202b9c <_vsnprintf+0x79c>  // b.none
      format++;
  2026e8:	aa0103fa 	mov	x26, x1
  2026ec:	91000421 	add	x1, x1, #0x1
    switch (*format) {
  2026f0:	7101b01f 	cmp	w0, #0x6c
        format++;
  2026f4:	aa0103e2 	mov	x2, x1
    switch (*format) {
  2026f8:	54fff281 	b.ne	202548 <_vsnprintf+0x148>  // b.any
  2026fc:	d503201f 	nop
        if (*format == 'l') {
  202700:	39400740 	ldrb	w0, [x26, #1]
  202704:	7101b01f 	cmp	w0, #0x6c
  202708:	54fff2c1 	b.ne	202560 <_vsnprintf+0x160>  // b.any
    switch (*format) {
  20270c:	39400b40 	ldrb	w0, [x26, #2]
          flags |= FLAGS_LONG_LONG;
  202710:	321804c6 	orr	w6, w6, #0x300
          format++;
  202714:	91000b42 	add	x2, x26, #0x2
  202718:	17ffff93 	b	202564 <_vsnprintf+0x164>
      const int w = va_arg(va, int);
  20271c:	11002302 	add	w2, w24, #0x8
  202720:	7100005f 	cmp	w2, #0x0
  202724:	540018ed 	b.le	202a40 <_vsnprintf+0x640>
  202728:	91002ec3 	add	x3, x22, #0xb
  20272c:	aa1603e0 	mov	x0, x22
  202730:	2a0203f8 	mov	w24, w2
  202734:	927df076 	and	x22, x3, #0xfffffffffffffff8
  202738:	17ffffd9 	b	20269c <_vsnprintf+0x29c>
        if ((*format == 'g')||(*format == 'G')) flags |= FLAGS_ADAPT_EXP;
  20273c:	121a7801 	and	w1, w0, #0xffffffdf
        if ((*format == 'E')||(*format == 'G')) flags |= FLAGS_UPPERCASE;
  202740:	121e7800 	and	w0, w0, #0xfffffffd
        if ((*format == 'g')||(*format == 'G')) flags |= FLAGS_ADAPT_EXP;
  202744:	71011c3f 	cmp	w1, #0x47
  202748:	321500c1 	orr	w1, w6, #0x800
  20274c:	1a860026 	csel	w6, w1, w6, eq	// eq = none
        if ((*format == 'E')||(*format == 'G')) flags |= FLAGS_UPPERCASE;
  202750:	7101141f 	cmp	w0, #0x45
  202754:	321b00c0 	orr	w0, w6, #0x20
  202758:	1a860006 	csel	w6, w0, w6, eq	// eq = none
        idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
  20275c:	b94077e0 	ldr	w0, [sp, #116]
  202760:	37f815e0 	tbnz	w0, #31, 202a1c <_vsnprintf+0x61c>
  202764:	91003ec1 	add	x1, x22, #0xf
  202768:	aa1603e0 	mov	x0, x22
  20276c:	927df036 	and	x22, x1, #0xfffffffffffffff8
  202770:	fd400000 	ldr	d0, [x0]
  202774:	aa1c03e2 	mov	x2, x28
  202778:	2a1903e5 	mov	w5, w25
  20277c:	2a1703e4 	mov	w4, w23
  202780:	aa1403e3 	mov	x3, x20
  202784:	aa1503e1 	mov	x1, x21
  202788:	aa1303e0 	mov	x0, x19
  20278c:	97fffe39 	bl	202070 <_etoa>
  202790:	aa0003fc 	mov	x28, x0
        break;
  202794:	17ffff40 	b	202494 <_vsnprintf+0x94>
        if (*format == 'F') flags |= FLAGS_UPPERCASE;
  202798:	7101181f 	cmp	w0, #0x46
  20279c:	321b00c0 	orr	w0, w6, #0x20
  2027a0:	1a860006 	csel	w6, w0, w6, eq	// eq = none
        idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
  2027a4:	b94077e0 	ldr	w0, [sp, #116]
  2027a8:	37f81180 	tbnz	w0, #31, 2029d8 <_vsnprintf+0x5d8>
  2027ac:	91003ec1 	add	x1, x22, #0xf
  2027b0:	aa1603e0 	mov	x0, x22
  2027b4:	927df036 	and	x22, x1, #0xfffffffffffffff8
  2027b8:	fd400000 	ldr	d0, [x0]
  2027bc:	aa1c03e2 	mov	x2, x28
  2027c0:	2a1903e5 	mov	w5, w25
  2027c4:	2a1703e4 	mov	w4, w23
  2027c8:	aa1403e3 	mov	x3, x20
  2027cc:	aa1503e1 	mov	x1, x21
  2027d0:	aa1303e0 	mov	x0, x19
  2027d4:	97fffd23 	bl	201c60 <_ftoa>
  2027d8:	aa0003fc 	mov	x28, x0
        break;
  2027dc:	17ffff2e 	b	202494 <_vsnprintf+0x94>
        unsigned int l = 1U;
  2027e0:	52800020 	mov	w0, #0x1                   	// #1
  2027e4:	b90083e0 	str	w0, [sp, #128]
        if (!(flags & FLAGS_LEFT)) {
  2027e8:	121f00c0 	and	w0, w6, #0x2
  2027ec:	b90093e0 	str	w0, [sp, #144]
  2027f0:	36081ac6 	tbz	w6, #1, 202b48 <_vsnprintf+0x748>
        out((char)va_arg(va, int), buffer, idx++, maxlen);
  2027f4:	37f80d38 	tbnz	w24, #31, 202998 <_vsnprintf+0x598>
  2027f8:	91002ec1 	add	x1, x22, #0xb
  2027fc:	aa1603e0 	mov	x0, x22
  202800:	927df036 	and	x22, x1, #0xfffffffffffffff8
  202804:	39400000 	ldrb	w0, [x0]
  202808:	aa1403e3 	mov	x3, x20
  20280c:	aa1c03e2 	mov	x2, x28
  202810:	aa1503e1 	mov	x1, x21
  202814:	91000797 	add	x23, x28, #0x1
  202818:	d63f0260 	blr	x19
        if (flags & FLAGS_LEFT) {
  20281c:	b94093e0 	ldr	w0, [sp, #144]
  202820:	35001700 	cbnz	w0, 202b00 <_vsnprintf+0x700>
        break;
  202824:	aa1703fc 	mov	x28, x23
  202828:	17ffff1b 	b	202494 <_vsnprintf+0x94>
        out('%', buffer, idx++, maxlen);
  20282c:	91000780 	add	x0, x28, #0x1
  202830:	aa1c03e2 	mov	x2, x28
  202834:	aa1403e3 	mov	x3, x20
  202838:	aa0003fc 	mov	x28, x0
  20283c:	aa1503e1 	mov	x1, x21
  202840:	528004a0 	mov	w0, #0x25                  	// #37
  202844:	d63f0260 	blr	x19
        break;
  202848:	17ffff13 	b	202494 <_vsnprintf+0x94>
        if (*format == 'h') {
  20284c:	39400740 	ldrb	w0, [x26, #1]
  202850:	7101a01f 	cmp	w0, #0x68
  202854:	54002020 	b.eq	202c58 <_vsnprintf+0x858>  // b.none
        flags |= FLAGS_SHORT;
  202858:	321900c6 	orr	w6, w6, #0x80
  20285c:	17ffff42 	b	202564 <_vsnprintf+0x164>
        const char* p = va_arg(va, char*);
  202860:	37f80ad8 	tbnz	w24, #31, 2029b8 <_vsnprintf+0x5b8>
  202864:	91003ec1 	add	x1, x22, #0xf
  202868:	aa1603e0 	mov	x0, x22
  20286c:	927df036 	and	x22, x1, #0xfffffffffffffff8
  202870:	f940000a 	ldr	x10, [x0]
        unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
  202874:	710002ff 	cmp	w23, #0x0
  202878:	2a1703e3 	mov	w3, w23
  20287c:	da9f1063 	csinv	x3, x3, xzr, ne	// ne = any
  for (s = str; *s && maxsize--; ++s);
  202880:	39400140 	ldrb	w0, [x10]
  202884:	34003500 	cbz	w0, 202f24 <_vsnprintf+0xb24>
  202888:	8b030143 	add	x3, x10, x3
  20288c:	aa0a03e1 	mov	x1, x10
  202890:	14000003 	b	20289c <_vsnprintf+0x49c>
  202894:	eb03003f 	cmp	x1, x3
  202898:	54000060 	b.eq	2028a4 <_vsnprintf+0x4a4>  // b.none
  20289c:	38401c22 	ldrb	w2, [x1, #1]!
  2028a0:	35ffffa2 	cbnz	w2, 202894 <_vsnprintf+0x494>
  return (unsigned int)(s - str);
  2028a4:	4b0a0021 	sub	w1, w1, w10
  2028a8:	b90093e1 	str	w1, [sp, #144]
        if (flags & FLAGS_PRECISION) {
  2028ac:	121600c1 	and	w1, w6, #0x400
  2028b0:	b900abe1 	str	w1, [sp, #168]
  2028b4:	365000a6 	tbz	w6, #10, 2028c8 <_vsnprintf+0x4c8>
          l = (l < precision ? l : precision);
  2028b8:	b94093e1 	ldr	w1, [sp, #144]
  2028bc:	6b17003f 	cmp	w1, w23
  2028c0:	1a979021 	csel	w1, w1, w23, ls	// ls = plast
  2028c4:	b90093e1 	str	w1, [sp, #144]
        if (!(flags & FLAGS_LEFT)) {
  2028c8:	121f00c1 	and	w1, w6, #0x2
  2028cc:	b900afe1 	str	w1, [sp, #172]
  2028d0:	36081f26 	tbz	w6, #1, 202cb4 <_vsnprintf+0x8b4>
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  2028d4:	340002a0 	cbz	w0, 202928 <_vsnprintf+0x528>
  2028d8:	b940abe1 	ldr	w1, [sp, #168]
  2028dc:	34001aa1 	cbz	w1, 202c30 <_vsnprintf+0x830>
  2028e0:	8b374381 	add	x1, x28, w23, uxtw
            out(' ', buffer, idx++, maxlen);
  2028e4:	aa1c03e2 	mov	x2, x28
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  2028e8:	cb1c0157 	sub	x23, x10, x28
  2028ec:	f90043e1 	str	x1, [sp, #128]
  2028f0:	14000008 	b	202910 <_vsnprintf+0x510>
          out(*(p++), buffer, idx++, maxlen);
  2028f4:	9100045c 	add	x28, x2, #0x1
  2028f8:	aa1403e3 	mov	x3, x20
  2028fc:	aa1503e1 	mov	x1, x21
  202900:	d63f0260 	blr	x19
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  202904:	387c6ae0 	ldrb	w0, [x23, x28]
  202908:	340000c0 	cbz	w0, 202920 <_vsnprintf+0x520>
          out(*(p++), buffer, idx++, maxlen);
  20290c:	aa1c03e2 	mov	x2, x28
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  202910:	f94043e1 	ldr	x1, [sp, #128]
  202914:	eb02003f 	cmp	x1, x2
  202918:	54fffee1 	b.ne	2028f4 <_vsnprintf+0x4f4>  // b.any
  20291c:	aa0103fc 	mov	x28, x1
        if (flags & FLAGS_LEFT) {
  202920:	b940afe0 	ldr	w0, [sp, #172]
  202924:	34ffdb80 	cbz	w0, 202494 <_vsnprintf+0x94>
          while (l++ < width) {
  202928:	b94093e1 	ldr	w1, [sp, #144]
  20292c:	aa1c03f7 	mov	x23, x28
  202930:	6b19003f 	cmp	w1, w25
  202934:	54ffdb02 	b.cs	202494 <_vsnprintf+0x94>  // b.hs, b.nlast
  202938:	51000720 	sub	w0, w25, #0x1
  20293c:	91000789 	add	x9, x28, #0x1
  202940:	4b010000 	sub	w0, w0, w1
  202944:	8b09001c 	add	x28, x0, x9
            out(' ', buffer, idx++, maxlen);
  202948:	aa1703e2 	mov	x2, x23
  20294c:	aa1403e3 	mov	x3, x20
  202950:	910006f7 	add	x23, x23, #0x1
  202954:	aa1503e1 	mov	x1, x21
  202958:	52800400 	mov	w0, #0x20                  	// #32
  20295c:	d63f0260 	blr	x19
          while (l++ < width) {
  202960:	eb1c02ff 	cmp	x23, x28
  202964:	54ffff21 	b.ne	202948 <_vsnprintf+0x548>  // b.any
  202968:	17fffecb 	b	202494 <_vsnprintf+0x94>
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
  20296c:	52800143 	mov	w3, #0xa                   	// #10
  202970:	1b0302e7 	madd	w7, w23, w3, w0
  while (_is_digit(**str)) {
  202974:	38401c40 	ldrb	w0, [x2, #1]!
  return (ch >= '0') && (ch <= '9');
  202978:	5100c001 	sub	w1, w0, #0x30
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
  20297c:	5100c0f7 	sub	w23, w7, #0x30
  while (_is_digit(**str)) {
  202980:	12001c21 	and	w1, w1, #0xff
  202984:	7100243f 	cmp	w1, #0x9
  202988:	54ffff49 	b.ls	202970 <_vsnprintf+0x570>  // b.plast
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
  20298c:	aa0203fa 	mov	x26, x2
  202990:	91000441 	add	x1, x2, #0x1
  202994:	17fffeea 	b	20253c <_vsnprintf+0x13c>
        out((char)va_arg(va, int), buffer, idx++, maxlen);
  202998:	11002301 	add	w1, w24, #0x8
  20299c:	7100003f 	cmp	w1, #0x0
  2029a0:	540024ed 	b.le	202e3c <_vsnprintf+0xa3c>
  2029a4:	91002ec2 	add	x2, x22, #0xb
  2029a8:	aa1603e0 	mov	x0, x22
  2029ac:	2a0103f8 	mov	w24, w1
  2029b0:	927df056 	and	x22, x2, #0xfffffffffffffff8
  2029b4:	17ffff94 	b	202804 <_vsnprintf+0x404>
        const char* p = va_arg(va, char*);
  2029b8:	11002301 	add	w1, w24, #0x8
  2029bc:	7100003f 	cmp	w1, #0x0
  2029c0:	540021ad 	b.le	202df4 <_vsnprintf+0x9f4>
  2029c4:	91003ec2 	add	x2, x22, #0xf
  2029c8:	aa1603e0 	mov	x0, x22
  2029cc:	2a0103f8 	mov	w24, w1
  2029d0:	927df056 	and	x22, x2, #0xfffffffffffffff8
  2029d4:	17ffffa7 	b	202870 <_vsnprintf+0x470>
        idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
  2029d8:	b94077e0 	ldr	w0, [sp, #116]
  2029dc:	11004001 	add	w1, w0, #0x10
  2029e0:	7100003f 	cmp	w1, #0x0
  2029e4:	5400218d 	b.le	202e14 <_vsnprintf+0xa14>
  2029e8:	91003ec2 	add	x2, x22, #0xf
  2029ec:	aa1603e0 	mov	x0, x22
  2029f0:	927df056 	and	x22, x2, #0xfffffffffffffff8
  2029f4:	b90077e1 	str	w1, [sp, #116]
  2029f8:	17ffff70 	b	2027b8 <_vsnprintf+0x3b8>
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
  2029fc:	11002302 	add	w2, w24, #0x8
  202a00:	7100005f 	cmp	w2, #0x0
  202a04:	5400200d 	b.le	202e04 <_vsnprintf+0xa04>
  202a08:	91003ec3 	add	x3, x22, #0xf
  202a0c:	aa1603e1 	mov	x1, x22
  202a10:	2a0203f8 	mov	w24, w2
  202a14:	927df076 	and	x22, x3, #0xfffffffffffffff8
  202a18:	17fffef6 	b	2025f0 <_vsnprintf+0x1f0>
        idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
  202a1c:	b94077e0 	ldr	w0, [sp, #116]
  202a20:	11004001 	add	w1, w0, #0x10
  202a24:	7100003f 	cmp	w1, #0x0
  202a28:	5400200d 	b.le	202e28 <_vsnprintf+0xa28>
  202a2c:	91003ec2 	add	x2, x22, #0xf
  202a30:	aa1603e0 	mov	x0, x22
  202a34:	927df056 	and	x22, x2, #0xfffffffffffffff8
  202a38:	b90077e1 	str	w1, [sp, #116]
  202a3c:	17ffff4d 	b	202770 <_vsnprintf+0x370>
      const int w = va_arg(va, int);
  202a40:	f94047e0 	ldr	x0, [sp, #136]
  202a44:	8b38c000 	add	x0, x0, w24, sxtw
  202a48:	2a0203f8 	mov	w24, w2
  202a4c:	17ffff14 	b	20269c <_vsnprintf+0x29c>
        if (*format == 'x' || *format == 'X') {
  202a50:	121a7801 	and	w1, w0, #0xffffffdf
  202a54:	7101603f 	cmp	w1, #0x58
  202a58:	54001080 	b.eq	202c68 <_vsnprintf+0x868>  // b.none
        else if (*format == 'b') {
  202a5c:	7101881f 	cmp	w0, #0x62
  202a60:	54001920 	b.eq	202d84 <_vsnprintf+0x984>  // b.none
        if ((*format != 'i') && (*format != 'd')) {
  202a64:	52800c81 	mov	w1, #0x64                  	// #100
  202a68:	7101a41f 	cmp	w0, #0x69
  202a6c:	7a411004 	ccmp	w0, w1, #0x4, ne	// ne = any
          flags &= ~FLAGS_HASH;   // no hash for dec format
  202a70:	121b78c6 	and	w6, w6, #0xffffffef
        if ((*format != 'i') && (*format != 'd')) {
  202a74:	d2800141 	mov	x1, #0xa                   	// #10
  202a78:	54000b41 	b.ne	202be0 <_vsnprintf+0x7e0>  // b.any
          flags &= ~FLAGS_ZEROPAD;
  202a7c:	f27600df 	tst	x6, #0x400
  202a80:	121f78c2 	and	w2, w6, #0xfffffffe
  202a84:	1a861046 	csel	w6, w2, w6, ne	// ne = any
        if ((*format == 'i') || (*format == 'd')) {
  202a88:	7101a41f 	cmp	w0, #0x69
  202a8c:	52800c82 	mov	w2, #0x64                  	// #100
          if (flags & FLAGS_LONG_LONG) {
  202a90:	121700c3 	and	w3, w6, #0x200
        if ((*format == 'i') || (*format == 'd')) {
  202a94:	7a421004 	ccmp	w0, w2, #0x4, ne	// ne = any
  202a98:	54000b81 	b.ne	202c08 <_vsnprintf+0x808>  // b.any
          if (flags & FLAGS_LONG_LONG) {
  202a9c:	35001903 	cbnz	w3, 202dbc <_vsnprintf+0x9bc>
          else if (flags & FLAGS_LONG) {
  202aa0:	37401d66 	tbnz	w6, #8, 202e4c <_vsnprintf+0xa4c>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  202aa4:	37301626 	tbnz	w6, #6, 202d68 <_vsnprintf+0x968>
  202aa8:	363822e6 	tbz	w6, #7, 202f04 <_vsnprintf+0xb04>
  202aac:	37f82d58 	tbnz	w24, #31, 203054 <_vsnprintf+0xc54>
  202ab0:	91002ec2 	add	x2, x22, #0xb
  202ab4:	aa1603e0 	mov	x0, x22
  202ab8:	927df056 	and	x22, x2, #0xfffffffffffffff8
  202abc:	79c00005 	ldrsh	w5, [x0]
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
  202ac0:	710000bf 	cmp	w5, #0x0
  202ac4:	5a85a4a4 	cneg	w4, w5, lt	// lt = tstop
  202ac8:	12003c84 	and	w4, w4, #0xffff
  202acc:	2a1703e7 	mov	w7, w23
  202ad0:	531f7ca5 	lsr	w5, w5, #31
  202ad4:	93407c84 	sxtw	x4, w4
  202ad8:	aa1c03e2 	mov	x2, x28
  202adc:	b9000be6 	str	w6, [sp, #8]
  202ae0:	aa0103e6 	mov	x6, x1
  202ae4:	b90003f9 	str	w25, [sp]
            idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
  202ae8:	aa1403e3 	mov	x3, x20
  202aec:	aa1503e1 	mov	x1, x21
  202af0:	aa1303e0 	mov	x0, x19
  202af4:	97fffb7f 	bl	2018f0 <_ntoa_long>
  202af8:	aa0003fc 	mov	x28, x0
        break;
  202afc:	17fffe66 	b	202494 <_vsnprintf+0x94>
          while (l++ < width) {
  202b00:	b94083e0 	ldr	w0, [sp, #128]
  202b04:	6b19001f 	cmp	w0, w25
  202b08:	54ffe8e2 	b.cs	202824 <_vsnprintf+0x424>  // b.hs, b.nlast
  202b0c:	51000725 	sub	w5, w25, #0x1
  202b10:	91000b89 	add	x9, x28, #0x2
  202b14:	4b0000a0 	sub	w0, w5, w0
  202b18:	8b090019 	add	x25, x0, x9
  202b1c:	d503201f 	nop
            out(' ', buffer, idx++, maxlen);
  202b20:	aa1703e2 	mov	x2, x23
  202b24:	aa1403e3 	mov	x3, x20
  202b28:	910006f7 	add	x23, x23, #0x1
  202b2c:	aa1503e1 	mov	x1, x21
  202b30:	52800400 	mov	w0, #0x20                  	// #32
  202b34:	d63f0260 	blr	x19
          while (l++ < width) {
  202b38:	eb1902ff 	cmp	x23, x25
  202b3c:	54ffff21 	b.ne	202b20 <_vsnprintf+0x720>  // b.any
        break;
  202b40:	aa1703fc 	mov	x28, x23
  202b44:	17fffe54 	b	202494 <_vsnprintf+0x94>
          while (l++ < width) {
  202b48:	7100073f 	cmp	w25, #0x1
  202b4c:	54002409 	b.ls	202fcc <_vsnprintf+0xbcc>  // b.plast
  202b50:	91000784 	add	x4, x28, #0x1
  202b54:	51000b20 	sub	w0, w25, #0x2
  202b58:	8b000097 	add	x23, x4, x0
  202b5c:	14000002 	b	202b64 <_vsnprintf+0x764>
  202b60:	91000484 	add	x4, x4, #0x1
  202b64:	f90043e4 	str	x4, [sp, #128]
            out(' ', buffer, idx++, maxlen);
  202b68:	aa1c03e2 	mov	x2, x28
  202b6c:	aa1403e3 	mov	x3, x20
  202b70:	aa1503e1 	mov	x1, x21
  202b74:	52800400 	mov	w0, #0x20                  	// #32
  202b78:	d63f0260 	blr	x19
  202b7c:	f94043e4 	ldr	x4, [sp, #128]
  202b80:	aa0403fc 	mov	x28, x4
          while (l++ < width) {
  202b84:	eb17009f 	cmp	x4, x23
  202b88:	54fffec1 	b.ne	202b60 <_vsnprintf+0x760>  // b.any
  202b8c:	11000720 	add	w0, w25, #0x1
  202b90:	b90083e0 	str	w0, [sp, #128]
        out((char)va_arg(va, int), buffer, idx++, maxlen);
  202b94:	36ffe338 	tbz	w24, #31, 2027f8 <_vsnprintf+0x3f8>
  202b98:	17ffff80 	b	202998 <_vsnprintf+0x598>
        const int prec = (int)va_arg(va, int);
  202b9c:	37f807d8 	tbnz	w24, #31, 202c94 <_vsnprintf+0x894>
  202ba0:	91002ec1 	add	x1, x22, #0xb
  202ba4:	aa1603e0 	mov	x0, x22
  202ba8:	927df036 	and	x22, x1, #0xfffffffffffffff8
        precision = prec > 0 ? (unsigned int)prec : 0U;
  202bac:	b9400007 	ldr	w7, [x0]
        format++;
  202bb0:	91000b5a 	add	x26, x26, #0x2
    switch (*format) {
  202bb4:	39400340 	ldrb	w0, [x26]
  202bb8:	91000741 	add	x1, x26, #0x1
        precision = prec > 0 ? (unsigned int)prec : 0U;
  202bbc:	710000ff 	cmp	w7, #0x0
  202bc0:	1a9fa0f7 	csel	w23, w7, wzr, ge	// ge = tcont
        format++;
  202bc4:	17fffe5e 	b	20253c <_vsnprintf+0x13c>
        if (*format == 'x' || *format == 'X') {
  202bc8:	121a7801 	and	w1, w0, #0xffffffdf
  202bcc:	7101603f 	cmp	w1, #0x58
  202bd0:	540005c0 	b.eq	202c88 <_vsnprintf+0x888>  // b.none
        else if (*format == 'o') {
  202bd4:	7101bc1f 	cmp	w0, #0x6f
  202bd8:	d2800101 	mov	x1, #0x8                   	// #8
  202bdc:	54fff441 	b.ne	202a64 <_vsnprintf+0x664>  // b.any
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
  202be0:	121c74c6 	and	w6, w6, #0xfffffff3
  202be4:	d503201f 	nop
          flags &= ~FLAGS_ZEROPAD;
  202be8:	f27600df 	tst	x6, #0x400
  202bec:	121f78c2 	and	w2, w6, #0xfffffffe
  202bf0:	1a861046 	csel	w6, w2, w6, ne	// ne = any
        if ((*format == 'i') || (*format == 'd')) {
  202bf4:	7101a41f 	cmp	w0, #0x69
  202bf8:	52800c82 	mov	w2, #0x64                  	// #100
          if (flags & FLAGS_LONG_LONG) {
  202bfc:	121700c3 	and	w3, w6, #0x200
        if ((*format == 'i') || (*format == 'd')) {
  202c00:	7a421004 	ccmp	w0, w2, #0x4, ne	// ne = any
  202c04:	54fff4c0 	b.eq	202a9c <_vsnprintf+0x69c>  // b.none
          if (flags & FLAGS_LONG_LONG) {
  202c08:	35000c43 	cbnz	w3, 202d90 <_vsnprintf+0x990>
          else if (flags & FLAGS_LONG) {
  202c0c:	374013c6 	tbnz	w6, #8, 202e84 <_vsnprintf+0xa84>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  202c10:	37300926 	tbnz	w6, #6, 202d34 <_vsnprintf+0x934>
  202c14:	363816c6 	tbz	w6, #7, 202eec <_vsnprintf+0xaec>
  202c18:	37f822f8 	tbnz	w24, #31, 203074 <_vsnprintf+0xc74>
  202c1c:	aa1603e0 	mov	x0, x22
  202c20:	91002ec2 	add	x2, x22, #0xb
  202c24:	927df056 	and	x22, x2, #0xfffffffffffffff8
  202c28:	79400004 	ldrh	w4, [x0]
  202c2c:	14000047 	b	202d48 <_vsnprintf+0x948>
  202c30:	cb1c0157 	sub	x23, x10, x28
  202c34:	d503201f 	nop
          out(*(p++), buffer, idx++, maxlen);
  202c38:	aa1c03e2 	mov	x2, x28
  202c3c:	9100079c 	add	x28, x28, #0x1
  202c40:	aa1403e3 	mov	x3, x20
  202c44:	aa1503e1 	mov	x1, x21
  202c48:	d63f0260 	blr	x19
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  202c4c:	387c6ae0 	ldrb	w0, [x23, x28]
  202c50:	35ffff40 	cbnz	w0, 202c38 <_vsnprintf+0x838>
  202c54:	17ffff33 	b	202920 <_vsnprintf+0x520>
    switch (*format) {
  202c58:	39400b40 	ldrb	w0, [x26, #2]
          flags |= FLAGS_CHAR;
  202c5c:	321a04c6 	orr	w6, w6, #0xc0
          format++;
  202c60:	91000b42 	add	x2, x26, #0x2
  202c64:	17fffe40 	b	202564 <_vsnprintf+0x164>
        if (*format == 'X') {
  202c68:	7101601f 	cmp	w0, #0x58
  202c6c:	540000e1 	b.ne	202c88 <_vsnprintf+0x888>  // b.any
          flags |= FLAGS_UPPERCASE;
  202c70:	321b00c6 	orr	w6, w6, #0x20
  202c74:	d2800201 	mov	x1, #0x10                  	// #16
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
  202c78:	121c74c6 	and	w6, w6, #0xfffffff3
  202c7c:	17ffffdb 	b	202be8 <_vsnprintf+0x7e8>
  while (*format)
  202c80:	52800016 	mov	w22, #0x0                   	// #0
  202c84:	17fffe6d 	b	202638 <_vsnprintf+0x238>
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
  202c88:	121c74c6 	and	w6, w6, #0xfffffff3
        if (*format == 'X') {
  202c8c:	d2800201 	mov	x1, #0x10                  	// #16
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
  202c90:	17ffffd6 	b	202be8 <_vsnprintf+0x7e8>
        const int prec = (int)va_arg(va, int);
  202c94:	11002301 	add	w1, w24, #0x8
  202c98:	7100003f 	cmp	w1, #0x0
  202c9c:	5400044d 	b.le	202d24 <_vsnprintf+0x924>
  202ca0:	91002ec2 	add	x2, x22, #0xb
  202ca4:	aa1603e0 	mov	x0, x22
  202ca8:	2a0103f8 	mov	w24, w1
  202cac:	927df056 	and	x22, x2, #0xfffffffffffffff8
  202cb0:	17ffffbf 	b	202bac <_vsnprintf+0x7ac>
          while (l++ < width) {
  202cb4:	b94093e1 	ldr	w1, [sp, #144]
  202cb8:	6b19003f 	cmp	w1, w25
  202cbc:	54001902 	b.cs	202fdc <_vsnprintf+0xbdc>  // b.hs, b.nlast
  202cc0:	51000720 	sub	w0, w25, #0x1
  202cc4:	91000784 	add	x4, x28, #0x1
  202cc8:	4b010000 	sub	w0, w0, w1
  202ccc:	8b040000 	add	x0, x0, x4
  202cd0:	f90053e0 	str	x0, [sp, #160]
  202cd4:	14000002 	b	202cdc <_vsnprintf+0x8dc>
  202cd8:	91000484 	add	x4, x4, #0x1
  202cdc:	f90043ea 	str	x10, [sp, #128]
            out(' ', buffer, idx++, maxlen);
  202ce0:	aa1c03e2 	mov	x2, x28
  202ce4:	f9004be4 	str	x4, [sp, #144]
  202ce8:	52800400 	mov	w0, #0x20                  	// #32
  202cec:	aa1403e3 	mov	x3, x20
  202cf0:	aa1503e1 	mov	x1, x21
  202cf4:	d63f0260 	blr	x19
  202cf8:	f9404be4 	ldr	x4, [sp, #144]
          while (l++ < width) {
  202cfc:	f94053e0 	ldr	x0, [sp, #160]
            out(' ', buffer, idx++, maxlen);
  202d00:	aa0403fc 	mov	x28, x4
          while (l++ < width) {
  202d04:	f94043ea 	ldr	x10, [sp, #128]
  202d08:	eb00009f 	cmp	x4, x0
  202d0c:	54fffe61 	b.ne	202cd8 <_vsnprintf+0x8d8>  // b.any
  202d10:	11000720 	add	w0, w25, #0x1
  202d14:	b90093e0 	str	w0, [sp, #144]
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  202d18:	39400140 	ldrb	w0, [x10]
  202d1c:	35ffdde0 	cbnz	w0, 2028d8 <_vsnprintf+0x4d8>
  202d20:	17fffddd 	b	202494 <_vsnprintf+0x94>
        const int prec = (int)va_arg(va, int);
  202d24:	f94047e0 	ldr	x0, [sp, #136]
  202d28:	8b38c000 	add	x0, x0, w24, sxtw
  202d2c:	2a0103f8 	mov	w24, w1
  202d30:	17ffff9f 	b	202bac <_vsnprintf+0x7ac>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  202d34:	37f812d8 	tbnz	w24, #31, 202f8c <_vsnprintf+0xb8c>
  202d38:	91002ec2 	add	x2, x22, #0xb
  202d3c:	aa1603e0 	mov	x0, x22
  202d40:	927df056 	and	x22, x2, #0xfffffffffffffff8
  202d44:	39400004 	ldrb	w4, [x0]
            idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
  202d48:	2a1703e7 	mov	w7, w23
  202d4c:	2a0403e4 	mov	w4, w4
  202d50:	b9000be6 	str	w6, [sp, #8]
  202d54:	aa0103e6 	mov	x6, x1
  202d58:	b90003f9 	str	w25, [sp]
  202d5c:	aa1c03e2 	mov	x2, x28
  202d60:	52800005 	mov	w5, #0x0                   	// #0
  202d64:	17ffff61 	b	202ae8 <_vsnprintf+0x6e8>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  202d68:	37f80e38 	tbnz	w24, #31, 202f2c <_vsnprintf+0xb2c>
  202d6c:	91002ec2 	add	x2, x22, #0xb
  202d70:	aa1603e0 	mov	x0, x22
  202d74:	927df056 	and	x22, x2, #0xfffffffffffffff8
  202d78:	39400005 	ldrb	w5, [x0]
  202d7c:	2a0503e4 	mov	w4, w5
  202d80:	17ffff53 	b	202acc <_vsnprintf+0x6cc>
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
  202d84:	121c74c6 	and	w6, w6, #0xfffffff3
  202d88:	d2800041 	mov	x1, #0x2                   	// #2
  202d8c:	17ffff97 	b	202be8 <_vsnprintf+0x7e8>
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
  202d90:	37f808f8 	tbnz	w24, #31, 202eac <_vsnprintf+0xaac>
  202d94:	91003ec2 	add	x2, x22, #0xf
  202d98:	aa1603e0 	mov	x0, x22
  202d9c:	927df056 	and	x22, x2, #0xfffffffffffffff8
  202da0:	f9400004 	ldr	x4, [x0]
  202da4:	2a1703e7 	mov	w7, w23
  202da8:	aa1c03e2 	mov	x2, x28
  202dac:	b90003f9 	str	w25, [sp]
  202db0:	b9000be6 	str	w6, [sp, #8]
  202db4:	aa0103e6 	mov	x6, x1
  202db8:	17fffe15 	b	20260c <_vsnprintf+0x20c>
            const long long value = va_arg(va, long long);
  202dbc:	37f80898 	tbnz	w24, #31, 202ecc <_vsnprintf+0xacc>
  202dc0:	91003ec2 	add	x2, x22, #0xf
  202dc4:	aa1603e0 	mov	x0, x22
  202dc8:	927df056 	and	x22, x2, #0xfffffffffffffff8
  202dcc:	f9400005 	ldr	x5, [x0]
            idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
  202dd0:	2a1703e7 	mov	w7, w23
  202dd4:	aa1c03e2 	mov	x2, x28
  202dd8:	b90003f9 	str	w25, [sp]
  202ddc:	f10000bf 	cmp	x5, #0x0
  202de0:	b9000be6 	str	w6, [sp, #8]
  202de4:	da85a4a4 	cneg	x4, x5, lt	// lt = tstop
  202de8:	aa0103e6 	mov	x6, x1
  202dec:	d37ffca5 	lsr	x5, x5, #63
  202df0:	17fffe08 	b	202610 <_vsnprintf+0x210>
        const char* p = va_arg(va, char*);
  202df4:	f94047e0 	ldr	x0, [sp, #136]
  202df8:	8b38c000 	add	x0, x0, w24, sxtw
  202dfc:	2a0103f8 	mov	w24, w1
  202e00:	17fffe9c 	b	202870 <_vsnprintf+0x470>
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
  202e04:	f94047e1 	ldr	x1, [sp, #136]
  202e08:	8b38c021 	add	x1, x1, w24, sxtw
  202e0c:	2a0203f8 	mov	w24, w2
  202e10:	17fffdf8 	b	2025f0 <_vsnprintf+0x1f0>
        idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
  202e14:	f9404fe2 	ldr	x2, [sp, #152]
  202e18:	b94077e0 	ldr	w0, [sp, #116]
  202e1c:	b90077e1 	str	w1, [sp, #116]
  202e20:	8b20c040 	add	x0, x2, w0, sxtw
  202e24:	17fffe65 	b	2027b8 <_vsnprintf+0x3b8>
        idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
  202e28:	f9404fe2 	ldr	x2, [sp, #152]
  202e2c:	b94077e0 	ldr	w0, [sp, #116]
  202e30:	b90077e1 	str	w1, [sp, #116]
  202e34:	8b20c040 	add	x0, x2, w0, sxtw
  202e38:	17fffe4e 	b	202770 <_vsnprintf+0x370>
        out((char)va_arg(va, int), buffer, idx++, maxlen);
  202e3c:	f94047e0 	ldr	x0, [sp, #136]
  202e40:	8b38c000 	add	x0, x0, w24, sxtw
  202e44:	2a0103f8 	mov	w24, w1
  202e48:	17fffe6f 	b	202804 <_vsnprintf+0x404>
            const long value = va_arg(va, long);
  202e4c:	37f80818 	tbnz	w24, #31, 202f4c <_vsnprintf+0xb4c>
  202e50:	91003ec2 	add	x2, x22, #0xf
  202e54:	aa1603e0 	mov	x0, x22
  202e58:	927df056 	and	x22, x2, #0xfffffffffffffff8
  202e5c:	f9400005 	ldr	x5, [x0]
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
  202e60:	2a1703e7 	mov	w7, w23
  202e64:	aa1c03e2 	mov	x2, x28
  202e68:	b90003f9 	str	w25, [sp]
  202e6c:	f10000bf 	cmp	x5, #0x0
  202e70:	b9000be6 	str	w6, [sp, #8]
  202e74:	da85a4a4 	cneg	x4, x5, lt	// lt = tstop
  202e78:	aa0103e6 	mov	x6, x1
  202e7c:	d37ffca5 	lsr	x5, x5, #63
  202e80:	17ffff1a 	b	202ae8 <_vsnprintf+0x6e8>
            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
  202e84:	37f80758 	tbnz	w24, #31, 202f6c <_vsnprintf+0xb6c>
  202e88:	91003ec2 	add	x2, x22, #0xf
  202e8c:	aa1603e0 	mov	x0, x22
  202e90:	927df056 	and	x22, x2, #0xfffffffffffffff8
  202e94:	f9400004 	ldr	x4, [x0]
  202e98:	2a1703e7 	mov	w7, w23
  202e9c:	b90003f9 	str	w25, [sp]
  202ea0:	b9000be6 	str	w6, [sp, #8]
  202ea4:	aa0103e6 	mov	x6, x1
  202ea8:	17ffffad 	b	202d5c <_vsnprintf+0x95c>
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
  202eac:	11002302 	add	w2, w24, #0x8
  202eb0:	7100005f 	cmp	w2, #0x0
  202eb4:	540007cd 	b.le	202fac <_vsnprintf+0xbac>
  202eb8:	91003ec3 	add	x3, x22, #0xf
  202ebc:	aa1603e0 	mov	x0, x22
  202ec0:	2a0203f8 	mov	w24, w2
  202ec4:	927df076 	and	x22, x3, #0xfffffffffffffff8
  202ec8:	17ffffb6 	b	202da0 <_vsnprintf+0x9a0>
            const long long value = va_arg(va, long long);
  202ecc:	11002302 	add	w2, w24, #0x8
  202ed0:	7100005f 	cmp	w2, #0x0
  202ed4:	5400074d 	b.le	202fbc <_vsnprintf+0xbbc>
  202ed8:	91003ec3 	add	x3, x22, #0xf
  202edc:	aa1603e0 	mov	x0, x22
  202ee0:	2a0203f8 	mov	w24, w2
  202ee4:	927df076 	and	x22, x3, #0xfffffffffffffff8
  202ee8:	17ffffb9 	b	202dcc <_vsnprintf+0x9cc>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  202eec:	37f808b8 	tbnz	w24, #31, 203000 <_vsnprintf+0xc00>
  202ef0:	aa1603e0 	mov	x0, x22
  202ef4:	91002ec2 	add	x2, x22, #0xb
  202ef8:	927df056 	and	x22, x2, #0xfffffffffffffff8
  202efc:	b9400004 	ldr	w4, [x0]
  202f00:	17ffff92 	b	202d48 <_vsnprintf+0x948>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  202f04:	37f80998 	tbnz	w24, #31, 203034 <_vsnprintf+0xc34>
  202f08:	91002ec2 	add	x2, x22, #0xb
  202f0c:	aa1603e0 	mov	x0, x22
  202f10:	927df056 	and	x22, x2, #0xfffffffffffffff8
  202f14:	b9400005 	ldr	w5, [x0]
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
  202f18:	710000bf 	cmp	w5, #0x0
  202f1c:	5a85a4a4 	cneg	w4, w5, lt	// lt = tstop
  202f20:	17fffeeb 	b	202acc <_vsnprintf+0x6cc>
  for (s = str; *s && maxsize--; ++s);
  202f24:	b90093ff 	str	wzr, [sp, #144]
  202f28:	17fffe61 	b	2028ac <_vsnprintf+0x4ac>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  202f2c:	11002302 	add	w2, w24, #0x8
  202f30:	7100005f 	cmp	w2, #0x0
  202f34:	5400078d 	b.le	203024 <_vsnprintf+0xc24>
  202f38:	91002ec3 	add	x3, x22, #0xb
  202f3c:	aa1603e0 	mov	x0, x22
  202f40:	2a0203f8 	mov	w24, w2
  202f44:	927df076 	and	x22, x3, #0xfffffffffffffff8
  202f48:	17ffff8c 	b	202d78 <_vsnprintf+0x978>
            const long value = va_arg(va, long);
  202f4c:	11002302 	add	w2, w24, #0x8
  202f50:	7100005f 	cmp	w2, #0x0
  202f54:	54000aad 	b.le	2030a8 <_vsnprintf+0xca8>
  202f58:	91003ec3 	add	x3, x22, #0xf
  202f5c:	aa1603e0 	mov	x0, x22
  202f60:	2a0203f8 	mov	w24, w2
  202f64:	927df076 	and	x22, x3, #0xfffffffffffffff8
  202f68:	17ffffbd 	b	202e5c <_vsnprintf+0xa5c>
            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
  202f6c:	11002302 	add	w2, w24, #0x8
  202f70:	7100005f 	cmp	w2, #0x0
  202f74:	540003ed 	b.le	202ff0 <_vsnprintf+0xbf0>
  202f78:	91003ec3 	add	x3, x22, #0xf
  202f7c:	aa1603e0 	mov	x0, x22
  202f80:	2a0203f8 	mov	w24, w2
  202f84:	927df076 	and	x22, x3, #0xfffffffffffffff8
  202f88:	17ffffc3 	b	202e94 <_vsnprintf+0xa94>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  202f8c:	11002302 	add	w2, w24, #0x8
  202f90:	7100005f 	cmp	w2, #0x0
  202f94:	5400082d 	b.le	203098 <_vsnprintf+0xc98>
  202f98:	91002ec3 	add	x3, x22, #0xb
  202f9c:	aa1603e0 	mov	x0, x22
  202fa0:	2a0203f8 	mov	w24, w2
  202fa4:	927df076 	and	x22, x3, #0xfffffffffffffff8
  202fa8:	17ffff67 	b	202d44 <_vsnprintf+0x944>
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
  202fac:	f94047e0 	ldr	x0, [sp, #136]
  202fb0:	8b38c000 	add	x0, x0, w24, sxtw
  202fb4:	2a0203f8 	mov	w24, w2
  202fb8:	17ffff7a 	b	202da0 <_vsnprintf+0x9a0>
            const long long value = va_arg(va, long long);
  202fbc:	f94047e0 	ldr	x0, [sp, #136]
  202fc0:	8b38c000 	add	x0, x0, w24, sxtw
  202fc4:	2a0203f8 	mov	w24, w2
  202fc8:	17ffff81 	b	202dcc <_vsnprintf+0x9cc>
          while (l++ < width) {
  202fcc:	52800040 	mov	w0, #0x2                   	// #2
  202fd0:	b90083e0 	str	w0, [sp, #128]
        out((char)va_arg(va, int), buffer, idx++, maxlen);
  202fd4:	36ffc138 	tbz	w24, #31, 2027f8 <_vsnprintf+0x3f8>
  202fd8:	17fffe70 	b	202998 <_vsnprintf+0x598>
          while (l++ < width) {
  202fdc:	b94093e1 	ldr	w1, [sp, #144]
  202fe0:	11000421 	add	w1, w1, #0x1
  202fe4:	b90093e1 	str	w1, [sp, #144]
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  202fe8:	35ffc780 	cbnz	w0, 2028d8 <_vsnprintf+0x4d8>
  202fec:	17fffd2a 	b	202494 <_vsnprintf+0x94>
            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
  202ff0:	f94047e0 	ldr	x0, [sp, #136]
  202ff4:	8b38c000 	add	x0, x0, w24, sxtw
  202ff8:	2a0203f8 	mov	w24, w2
  202ffc:	17ffffa6 	b	202e94 <_vsnprintf+0xa94>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  203000:	11002302 	add	w2, w24, #0x8
  203004:	7100005f 	cmp	w2, #0x0
  203008:	5400060d 	b.le	2030c8 <_vsnprintf+0xcc8>
  20300c:	aa1603e0 	mov	x0, x22
  203010:	91002ec3 	add	x3, x22, #0xb
  203014:	2a0203f8 	mov	w24, w2
  203018:	927df076 	and	x22, x3, #0xfffffffffffffff8
  20301c:	b9400004 	ldr	w4, [x0]
  203020:	17ffff4a 	b	202d48 <_vsnprintf+0x948>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  203024:	f94047e0 	ldr	x0, [sp, #136]
  203028:	8b38c000 	add	x0, x0, w24, sxtw
  20302c:	2a0203f8 	mov	w24, w2
  203030:	17ffff52 	b	202d78 <_vsnprintf+0x978>
  203034:	11002302 	add	w2, w24, #0x8
  203038:	7100005f 	cmp	w2, #0x0
  20303c:	5400050d 	b.le	2030dc <_vsnprintf+0xcdc>
  203040:	91002ec3 	add	x3, x22, #0xb
  203044:	aa1603e0 	mov	x0, x22
  203048:	2a0203f8 	mov	w24, w2
  20304c:	927df076 	and	x22, x3, #0xfffffffffffffff8
  203050:	17ffffb1 	b	202f14 <_vsnprintf+0xb14>
  203054:	11002302 	add	w2, w24, #0x8
  203058:	7100005f 	cmp	w2, #0x0
  20305c:	540002ed 	b.le	2030b8 <_vsnprintf+0xcb8>
  203060:	91002ec3 	add	x3, x22, #0xb
  203064:	aa1603e0 	mov	x0, x22
  203068:	2a0203f8 	mov	w24, w2
  20306c:	927df076 	and	x22, x3, #0xfffffffffffffff8
  203070:	17fffe93 	b	202abc <_vsnprintf+0x6bc>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  203074:	11002302 	add	w2, w24, #0x8
  203078:	7100005f 	cmp	w2, #0x0
  20307c:	5400038d 	b.le	2030ec <_vsnprintf+0xcec>
  203080:	aa1603e0 	mov	x0, x22
  203084:	91002ec3 	add	x3, x22, #0xb
  203088:	2a0203f8 	mov	w24, w2
  20308c:	927df076 	and	x22, x3, #0xfffffffffffffff8
  203090:	79400004 	ldrh	w4, [x0]
  203094:	17ffff2d 	b	202d48 <_vsnprintf+0x948>
  203098:	f94047e0 	ldr	x0, [sp, #136]
  20309c:	8b38c000 	add	x0, x0, w24, sxtw
  2030a0:	2a0203f8 	mov	w24, w2
  2030a4:	17ffff28 	b	202d44 <_vsnprintf+0x944>
            const long value = va_arg(va, long);
  2030a8:	f94047e0 	ldr	x0, [sp, #136]
  2030ac:	8b38c000 	add	x0, x0, w24, sxtw
  2030b0:	2a0203f8 	mov	w24, w2
  2030b4:	17ffff6a 	b	202e5c <_vsnprintf+0xa5c>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  2030b8:	f94047e0 	ldr	x0, [sp, #136]
  2030bc:	8b38c000 	add	x0, x0, w24, sxtw
  2030c0:	2a0203f8 	mov	w24, w2
  2030c4:	17fffe7e 	b	202abc <_vsnprintf+0x6bc>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  2030c8:	f94047e0 	ldr	x0, [sp, #136]
  2030cc:	8b38c000 	add	x0, x0, w24, sxtw
  2030d0:	2a0203f8 	mov	w24, w2
  2030d4:	b9400004 	ldr	w4, [x0]
  2030d8:	17ffff1c 	b	202d48 <_vsnprintf+0x948>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  2030dc:	f94047e0 	ldr	x0, [sp, #136]
  2030e0:	8b38c000 	add	x0, x0, w24, sxtw
  2030e4:	2a0203f8 	mov	w24, w2
  2030e8:	17ffff8b 	b	202f14 <_vsnprintf+0xb14>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  2030ec:	f94047e0 	ldr	x0, [sp, #136]
  2030f0:	8b38c000 	add	x0, x0, w24, sxtw
  2030f4:	2a0203f8 	mov	w24, w2
  2030f8:	79400004 	ldrh	w4, [x0]
  2030fc:	17ffff13 	b	202d48 <_vsnprintf+0x948>
  return (ch >= '0') && (ch <= '9');
  203100:	5100c002 	sub	w2, w0, #0x30
  unsigned int i = 0U;
  203104:	52800019 	mov	w25, #0x0                   	// #0
    if (_is_digit(*format)) {
  203108:	12001c42 	and	w2, w2, #0xff
  20310c:	7100245f 	cmp	w2, #0x9
  203110:	54ffad48 	b.hi	2026b8 <_vsnprintf+0x2b8>  // b.pmore
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
  203114:	52800143 	mov	w3, #0xa                   	// #10
  203118:	1b030325 	madd	w5, w25, w3, w0
  while (_is_digit(**str)) {
  20311c:	39400020 	ldrb	w0, [x1]
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
  203120:	aa0103fa 	mov	x26, x1
  203124:	91000421 	add	x1, x1, #0x1
  return (ch >= '0') && (ch <= '9');
  203128:	5100c002 	sub	w2, w0, #0x30
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
  20312c:	5100c0b9 	sub	w25, w5, #0x30
  while (_is_digit(**str)) {
  203130:	12001c42 	and	w2, w2, #0xff
  203134:	7100245f 	cmp	w2, #0x9
  203138:	54ffff09 	b.ls	203118 <_vsnprintf+0xd18>  // b.plast
  20313c:	17fffd5f 	b	2026b8 <_vsnprintf+0x2b8>

0000000000203140 <sddf_printf_>:


///////////////////////////////////////////////////////////////////////////////

int sddf_printf_(const char* format, ...)
{
  203140:	a9ae7bfd 	stp	x29, x30, [sp, #-288]!
  va_list va;
  va_start(va, format);
  203144:	12800fe9 	mov	w9, #0xffffff80            	// #-128
  203148:	128006ea 	mov	w10, #0xffffffc8            	// #-56
{
  20314c:	910003fd 	mov	x29, sp
  va_start(va, format);
  203150:	910383eb 	add	x11, sp, #0xe0
  203154:	910483e8 	add	x8, sp, #0x120
  203158:	a90423e8 	stp	x8, x8, [sp, #64]
{
  20315c:	aa0003e8 	mov	x8, x0
  char buffer[1];
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  203160:	d0ffffe0 	adrp	x0, 201000 <init+0x250>
  203164:	9130c000 	add	x0, x0, #0xc30
  va_start(va, format);
  203168:	f9002beb 	str	x11, [sp, #80]
  20316c:	290b27ea 	stp	w10, w9, [sp, #88]
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  203170:	a94437ec 	ldp	x12, x13, [sp, #64]
  203174:	a90137ec 	stp	x12, x13, [sp, #16]
  203178:	a9452fea 	ldp	x10, x11, [sp, #80]
  20317c:	a9022fea 	stp	x10, x11, [sp, #32]
{
  203180:	3d801be0 	str	q0, [sp, #96]
  203184:	3d801fe1 	str	q1, [sp, #112]
  203188:	3d8023e2 	str	q2, [sp, #128]
  20318c:	3d8027e3 	str	q3, [sp, #144]
  203190:	3d802be4 	str	q4, [sp, #160]
  203194:	3d802fe5 	str	q5, [sp, #176]
  203198:	3d8033e6 	str	q6, [sp, #192]
  20319c:	3d8037e7 	str	q7, [sp, #208]
  2031a0:	a90e8be1 	stp	x1, x2, [sp, #232]
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  2031a4:	9100e3e1 	add	x1, sp, #0x38
  2031a8:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
{
  2031ac:	a90f93e3 	stp	x3, x4, [sp, #248]
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  2031b0:	910043e4 	add	x4, sp, #0x10
  2031b4:	aa0803e3 	mov	x3, x8
{
  2031b8:	a9109be5 	stp	x5, x6, [sp, #264]
  2031bc:	f9008fe7 	str	x7, [sp, #280]
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  2031c0:	97fffc90 	bl	202400 <_vsnprintf>
  va_end(va);
  return ret;
}
  2031c4:	a8d27bfd 	ldp	x29, x30, [sp], #288
  2031c8:	d65f03c0 	ret
  2031cc:	d503201f 	nop

00000000002031d0 <sddf_sprintf_>:


int sddf_sprintf_(char* buffer, const char* format, ...)
{
  2031d0:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
  va_list va;
  va_start(va, format);
  2031d4:	12800fe9 	mov	w9, #0xffffff80            	// #-128
  2031d8:	128005ea 	mov	w10, #0xffffffd0            	// #-48
{
  2031dc:	910003fd 	mov	x29, sp
  va_start(va, format);
  2031e0:	910343e8 	add	x8, sp, #0xd0
  2031e4:	910403eb 	add	x11, sp, #0x100
  2031e8:	a9032feb 	stp	x11, x11, [sp, #48]
  2031ec:	f90023e8 	str	x8, [sp, #64]
{
  2031f0:	aa0103e8 	mov	x8, x1
  va_start(va, format);
  2031f4:	290927ea 	stp	w10, w9, [sp, #72]
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
  2031f8:	aa0003e1 	mov	x1, x0
  2031fc:	a94337ec 	ldp	x12, x13, [sp, #48]
  203200:	d0ffffe0 	adrp	x0, 201000 <init+0x250>
  203204:	a9442fea 	ldp	x10, x11, [sp, #64]
  203208:	911ec000 	add	x0, x0, #0x7b0
  20320c:	a90137ec 	stp	x12, x13, [sp, #16]
  203210:	a9022fea 	stp	x10, x11, [sp, #32]
{
  203214:	3d8017e0 	str	q0, [sp, #80]
  203218:	3d801be1 	str	q1, [sp, #96]
  20321c:	3d801fe2 	str	q2, [sp, #112]
  203220:	3d8023e3 	str	q3, [sp, #128]
  203224:	3d8027e4 	str	q4, [sp, #144]
  203228:	3d802be5 	str	q5, [sp, #160]
  20322c:	3d802fe6 	str	q6, [sp, #176]
  203230:	3d8033e7 	str	q7, [sp, #192]
  203234:	a90d0fe2 	stp	x2, x3, [sp, #208]
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
  203238:	aa0803e3 	mov	x3, x8
  20323c:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
{
  203240:	a90e17e4 	stp	x4, x5, [sp, #224]
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
  203244:	910043e4 	add	x4, sp, #0x10
{
  203248:	a90f1fe6 	stp	x6, x7, [sp, #240]
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
  20324c:	97fffc6d 	bl	202400 <_vsnprintf>
  va_end(va);
  return ret;
}
  203250:	a8d07bfd 	ldp	x29, x30, [sp], #256
  203254:	d65f03c0 	ret
  203258:	d503201f 	nop
  20325c:	d503201f 	nop

0000000000203260 <sddf_snprintf_>:


int sddf_snprintf_(char* buffer, size_t count, const char* format, ...)
{
  203260:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
  va_list va;
  va_start(va, format);
  203264:	128004e8 	mov	w8, #0xffffffd8            	// #-40
  203268:	12800fea 	mov	w10, #0xffffff80            	// #-128
{
  20326c:	910003fd 	mov	x29, sp
  va_start(va, format);
  203270:	910343e9 	add	x9, sp, #0xd0
  203274:	910403eb 	add	x11, sp, #0x100
  203278:	a9032feb 	stp	x11, x11, [sp, #48]
  20327c:	f90023e9 	str	x9, [sp, #64]
{
  203280:	aa0103e9 	mov	x9, x1
  va_start(va, format);
  203284:	29092be8 	stp	w8, w10, [sp, #72]
{
  203288:	aa0203e8 	mov	x8, x2
  const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
  20328c:	a94337ec 	ldp	x12, x13, [sp, #48]
  203290:	aa0003e1 	mov	x1, x0
  203294:	a9442fea 	ldp	x10, x11, [sp, #64]
  203298:	aa0903e2 	mov	x2, x9
  20329c:	d0ffffe0 	adrp	x0, 201000 <init+0x250>
  2032a0:	911ec000 	add	x0, x0, #0x7b0
  2032a4:	a90137ec 	stp	x12, x13, [sp, #16]
  2032a8:	a9022fea 	stp	x10, x11, [sp, #32]
{
  2032ac:	3d8017e0 	str	q0, [sp, #80]
  2032b0:	3d801be1 	str	q1, [sp, #96]
  2032b4:	3d801fe2 	str	q2, [sp, #112]
  2032b8:	3d8023e3 	str	q3, [sp, #128]
  2032bc:	3d8027e4 	str	q4, [sp, #144]
  2032c0:	3d802be5 	str	q5, [sp, #160]
  2032c4:	3d802fe6 	str	q6, [sp, #176]
  2032c8:	3d8033e7 	str	q7, [sp, #192]
  2032cc:	a90d93e3 	stp	x3, x4, [sp, #216]
  const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
  2032d0:	910043e4 	add	x4, sp, #0x10
  2032d4:	aa0803e3 	mov	x3, x8
{
  2032d8:	a90e9be5 	stp	x5, x6, [sp, #232]
  2032dc:	f9007fe7 	str	x7, [sp, #248]
  const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
  2032e0:	97fffc48 	bl	202400 <_vsnprintf>
  va_end(va);
  return ret;
}
  2032e4:	a8d07bfd 	ldp	x29, x30, [sp], #256
  2032e8:	d65f03c0 	ret
  2032ec:	d503201f 	nop

00000000002032f0 <sddf_vprintf_>:


int sddf_vprintf_(const char* format, va_list va)
{
  2032f0:	aa0103e5 	mov	x5, x1
  2032f4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  char buffer[1];
  return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  2032f8:	aa0003e3 	mov	x3, x0
{
  2032fc:	910003fd 	mov	x29, sp
  return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  203300:	a9401ca6 	ldp	x6, x7, [x5]
  203304:	f9000be6 	str	x6, [sp, #16]
  203308:	910043e4 	add	x4, sp, #0x10
  20330c:	9100e3e1 	add	x1, sp, #0x38
  203310:	f94008a6 	ldr	x6, [x5, #16]
  203314:	f9000fe7 	str	x7, [sp, #24]
  203318:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
  20331c:	d0ffffe0 	adrp	x0, 201000 <init+0x250>
  203320:	f9400ca5 	ldr	x5, [x5, #24]
  203324:	9130c000 	add	x0, x0, #0xc30
  203328:	a90217e6 	stp	x6, x5, [sp, #32]
  20332c:	97fffc35 	bl	202400 <_vsnprintf>
}
  203330:	a8c47bfd 	ldp	x29, x30, [sp], #64
  203334:	d65f03c0 	ret
  203338:	d503201f 	nop
  20333c:	d503201f 	nop

0000000000203340 <sddf_vsnprintf_>:


int sddf_vsnprintf_(char* buffer, size_t count, const char* format, va_list va)
{
  203340:	aa0303e5 	mov	x5, x3
  203344:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  203348:	aa0103e4 	mov	x4, x1
  20334c:	910003fd 	mov	x29, sp
  return _vsnprintf(_out_buffer, buffer, count, format, va);
  203350:	a9401ca8 	ldp	x8, x7, [x5]
  203354:	aa0003e1 	mov	x1, x0
  203358:	a94114a6 	ldp	x6, x5, [x5, #16]
  20335c:	aa0203e3 	mov	x3, x2
  203360:	d0ffffe0 	adrp	x0, 201000 <init+0x250>
  203364:	911ec000 	add	x0, x0, #0x7b0
  203368:	aa0403e2 	mov	x2, x4
  20336c:	910043e4 	add	x4, sp, #0x10
  203370:	a9011fe8 	stp	x8, x7, [sp, #16]
  203374:	a90217e6 	stp	x6, x5, [sp, #32]
  203378:	97fffc22 	bl	202400 <_vsnprintf>
}
  20337c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  203380:	d65f03c0 	ret
  203384:	d503201f 	nop
  203388:	d503201f 	nop
  20338c:	d503201f 	nop

0000000000203390 <sddf_fctprintf>:


int sddf_fctprintf(void (*out)(char character, void* arg), void* arg, const char* format, ...)
{
  203390:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  va_list va;
  va_start(va, format);
  203394:	12800feb 	mov	w11, #0xffffff80            	// #-128
  203398:	128004e9 	mov	w9, #0xffffffd8            	// #-40
{
  20339c:	910003fd 	mov	x29, sp
  va_start(va, format);
  2033a0:	910383ea 	add	x10, sp, #0xe0
  2033a4:	910443e8 	add	x8, sp, #0x110
  2033a8:	a90423e8 	stp	x8, x8, [sp, #64]
{
  2033ac:	aa0203e8 	mov	x8, x2
  const out_fct_wrap_type out_fct_wrap = { out, arg };
  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
  2033b0:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
  va_start(va, format);
  2033b4:	f9002bea 	str	x10, [sp, #80]
{
  2033b8:	aa0003ea 	mov	x10, x0
  va_start(va, format);
  2033bc:	290b2fe9 	stp	w9, w11, [sp, #88]
{
  2033c0:	aa0103e9 	mov	x9, x1
  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
  2033c4:	a9443fee 	ldp	x14, x15, [sp, #64]
  2033c8:	9100c3e1 	add	x1, sp, #0x30
  2033cc:	a94537ec 	ldp	x12, x13, [sp, #80]
  2033d0:	d0ffffe0 	adrp	x0, 201000 <init+0x250>
  2033d4:	91310000 	add	x0, x0, #0xc40
  2033d8:	a9013fee 	stp	x14, x15, [sp, #16]
  2033dc:	a90237ec 	stp	x12, x13, [sp, #32]
  const out_fct_wrap_type out_fct_wrap = { out, arg };
  2033e0:	a90327ea 	stp	x10, x9, [sp, #48]
{
  2033e4:	3d801be0 	str	q0, [sp, #96]
  2033e8:	3d801fe1 	str	q1, [sp, #112]
  2033ec:	3d8023e2 	str	q2, [sp, #128]
  2033f0:	3d8027e3 	str	q3, [sp, #144]
  2033f4:	3d802be4 	str	q4, [sp, #160]
  2033f8:	3d802fe5 	str	q5, [sp, #176]
  2033fc:	3d8033e6 	str	q6, [sp, #192]
  203400:	3d8037e7 	str	q7, [sp, #208]
  203404:	a90e93e3 	stp	x3, x4, [sp, #232]
  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
  203408:	910043e4 	add	x4, sp, #0x10
  20340c:	aa0803e3 	mov	x3, x8
{
  203410:	a90f9be5 	stp	x5, x6, [sp, #248]
  203414:	f90087e7 	str	x7, [sp, #264]
  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
  203418:	97fffbfa 	bl	202400 <_vsnprintf>
  va_end(va);
  return ret;
}
  20341c:	a8d17bfd 	ldp	x29, x30, [sp], #272
  203420:	d65f03c0 	ret
	...

0000000000203430 <_assert_fail>:
 */

#include <sddf/util/printf.h>

void _assert_fail(const char  *assertion, const char  *file, unsigned int line, const char  *function)
{
  203430:	2a0203e5 	mov	w5, w2
  203434:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  203438:	aa0103e4 	mov	x4, x1
  20343c:	910003fd 	mov	x29, sp
    sddf_dprintf("Failed assertion '%s' at %s:%u in function %s\n", assertion, file, line, function);
  203440:	aa0003e1 	mov	x1, x0
  203444:	aa0403e2 	mov	x2, x4
  203448:	aa0303e4 	mov	x4, x3
  20344c:	90000000 	adrp	x0, 203000 <_vsnprintf+0xc00>
  203450:	91202000 	add	x0, x0, #0x808
  203454:	2a0503e3 	mov	w3, w5
  203458:	97ffff3a 	bl	203140 <sddf_printf_>
    __builtin_trap();
  20345c:	d4207d00 	brk	#0x3e8

0000000000203460 <_sddf_putchar>:

static char string_buffer[MAX_STRING_LENGTH + 1];
static uint32_t local_tail;

void _sddf_putchar(char character)
{
  203460:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    string_buffer[local_tail] = character;
  203464:	90000041 	adrp	x1, 20b000 <arp_table+0x3e40>
  203468:	91190021 	add	x1, x1, #0x640
{
  20346c:	910003fd 	mov	x29, sp
  203470:	f9000bf3 	str	x19, [sp, #16]
    string_buffer[local_tail] = character;
  203474:	90000053 	adrp	x19, 20b000 <arp_table+0x3e40>
  203478:	b9463263 	ldr	w3, [x19, #1584]
{
  20347c:	12001c00 	and	w0, w0, #0xff
    local_tail++;
  203480:	11000462 	add	w2, w3, #0x1
  203484:	b9063262 	str	w2, [x19, #1584]

    if (character == FLUSH_CHAR || local_tail == MAX_STRING_LENGTH) {
  203488:	7140045f 	cmp	w2, #0x1, lsl #12
    string_buffer[local_tail] = character;
  20348c:	38234820 	strb	w0, [x1, w3, uxtw]
    if (character == FLUSH_CHAR || local_tail == MAX_STRING_LENGTH) {
  203490:	7a4a1804 	ccmp	w0, #0xa, #0x4, ne	// ne = any
  203494:	540000a1 	b.ne	2034a8 <_sddf_putchar+0x48>  // b.any
        string_buffer[local_tail] = '\0';
        microkit_dbg_puts(string_buffer);
  203498:	aa0103e0 	mov	x0, x1
        string_buffer[local_tail] = '\0';
  20349c:	3822483f 	strb	wzr, [x1, w2, uxtw]
        microkit_dbg_puts(string_buffer);
  2034a0:	97fff804 	bl	2014b0 <microkit_dbg_puts>
        local_tail = 0;
  2034a4:	b906327f 	str	wzr, [x19, #1584]
    }
  2034a8:	f9400bf3 	ldr	x19, [sp, #16]
  2034ac:	a8c27bfd 	ldp	x29, x30, [sp], #32
  2034b0:	d65f03c0 	ret
  2034b4:	00000000 	udf	#0

00000000002034b8 <__FUNCTION__.3>:
  2034b8:	636f7270 5f737365 5f707261 74696177     process_arp_wait
  2034c8:	00676e69 00000000                       ing.....

00000000002034d0 <__FUNCTION__.2>:
  2034d0:	74756f72 00000065                       route...

00000000002034d8 <__FUNCTION__.0>:
  2034d8:	5f74656e 66667562 5f737265 74696e69     net_buffers_init
	...
  2034f0:	fff900a3 fff9fff9 fff9fff9 fff9fff9     ................
  203500:	fff9fff9 fff9fff9 fff9fff9 fff9fff9     ................
  203510:	fff9fff9 fff9fff9 fff9fff9 fff9fff9     ................
  203520:	fff9fff9 fff9fff9 fff9fff9 fff9fff9     ................
  203530:	007e0067 fff90067 fff9fff9 fff9fff9     g.~.g...........
  203540:	fff9fff9 fff9fff9 fff9fff9 fff9fff9     ................
  203550:	fff9fff9 012cfff9 fff9fff9 fff9fff9     ......,.........
  203560:	fff9fff9 fff9fff9 012cfff9 012c0090     ..........,...,.
  203570:	007e0067 00000067 00000000 00000000     g.~.g...........

0000000000203580 <pow10.0>:
  203580:	00000000 3ff00000 00000000 40240000     .......?......$@
  203590:	00000000 40590000 00000000 408f4000     ......Y@.....@.@
  2035a0:	00000000 40c38800 00000000 40f86a00     .......@.....j.@
  2035b0:	00000000 412e8480 00000000 416312d0     .......A......cA
  2035c0:	00000000 4197d784 00000000 41cdcd65     .......A....e..A
