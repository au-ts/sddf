
build/arp_requester.elf:     file format elf64-littleaarch64


Disassembly of section .text:

0000000000200000 <_start>:
  200000:	140002f4 	b	200bd0 <main>
	...

0000000000200010 <hash>:
#include <string.h>

#include "firewall_arp.h"
#include "hashmap.h"
#include "config.h"

  200010:	12002400 	and	w0, w0, #0x3ff
  200014:	d65f03c0 	ret
  200018:	d503201f 	nop
  20001c:	d503201f 	nop

0000000000200020 <hashtable_init>:
#define MAX_ARP_CACHE 64

// typedef struct arp_entry {
//     uint32_t ip_addr;
  200020:	91400c03 	add	x3, x0, #0x3, lsl #12
  200024:	cb0303e1 	neg	x1, x3
  200028:	f2400c24 	ands	x4, x1, #0xf
  20002c:	54001360 	b.eq	200298 <hashtable_init+0x278>  // b.none
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200030:	3900007f 	strb	wzr, [x3]
//     uint32_t ip_addr;
  200034:	f27f083f 	tst	x1, #0xe
  200038:	54001240 	b.eq	200280 <hashtable_init+0x260>  // b.none
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  20003c:	3900047f 	strb	wzr, [x3, #1]
//     uint32_t ip_addr;
  200040:	f100089f 	cmp	x4, #0x2
  200044:	54001249 	b.ls	20028c <hashtable_init+0x26c>  // b.plast
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200048:	3900087f 	strb	wzr, [x3, #2]
//     uint32_t ip_addr;
  20004c:	f27e043f 	tst	x1, #0xc
  200050:	540012a0 	b.eq	2002a4 <hashtable_init+0x284>  // b.none
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200054:	39000c7f 	strb	wzr, [x3, #3]
//     uint32_t ip_addr;
  200058:	f100109f 	cmp	x4, #0x4
  20005c:	540012a9 	b.ls	2002b0 <hashtable_init+0x290>  // b.plast
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200060:	3900107f 	strb	wzr, [x3, #4]
//     uint32_t ip_addr;
  200064:	f100149f 	cmp	x4, #0x5
  200068:	54001300 	b.eq	2002c8 <hashtable_init+0x2a8>  // b.none
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  20006c:	3900147f 	strb	wzr, [x3, #5]
//     uint32_t ip_addr;
  200070:	f100189f 	cmp	x4, #0x6
  200074:	54001360 	b.eq	2002e0 <hashtable_init+0x2c0>  // b.none
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200078:	3900187f 	strb	wzr, [x3, #6]
//     uint32_t ip_addr;
  20007c:	361812c1 	tbz	w1, #3, 2002d4 <hashtable_init+0x2b4>
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200080:	39001c7f 	strb	wzr, [x3, #7]
//     uint32_t ip_addr;
  200084:	f100209f 	cmp	x4, #0x8
  200088:	54001329 	b.ls	2002ec <hashtable_init+0x2cc>  // b.plast
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  20008c:	3900207f 	strb	wzr, [x3, #8]
//     uint32_t ip_addr;
  200090:	f100249f 	cmp	x4, #0x9
  200094:	54001320 	b.eq	2002f8 <hashtable_init+0x2d8>  // b.none
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200098:	3900247f 	strb	wzr, [x3, #9]
//     uint32_t ip_addr;
  20009c:	f100289f 	cmp	x4, #0xa
  2000a0:	540010e0 	b.eq	2002bc <hashtable_init+0x29c>  // b.none
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  2000a4:	3900287f 	strb	wzr, [x3, #10]
//     uint32_t ip_addr;
  2000a8:	f1002c9f 	cmp	x4, #0xb
  2000ac:	540012c0 	b.eq	200304 <hashtable_init+0x2e4>  // b.none
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  2000b0:	39002c7f 	strb	wzr, [x3, #11]
//     uint32_t ip_addr;
  2000b4:	f100309f 	cmp	x4, #0xc
  2000b8:	54001320 	b.eq	20031c <hashtable_init+0x2fc>  // b.none
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  2000bc:	3900307f 	strb	wzr, [x3, #12]
//     uint32_t ip_addr;
  2000c0:	f100349f 	cmp	x4, #0xd
  2000c4:	54001320 	b.eq	200328 <hashtable_init+0x308>  // b.none
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  2000c8:	3900347f 	strb	wzr, [x3, #13]
//     uint32_t ip_addr;
  2000cc:	f1003c9f 	cmp	x4, #0xf
  2000d0:	54001201 	b.ne	200310 <hashtable_init+0x2f0>  // b.any
  2000d4:	aa0403e5 	mov	x5, x4
  2000d8:	d2807e22 	mov	x2, #0x3f1                 	// #1009
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  2000dc:	3900387f 	strb	wzr, [x3, #14]
//     uint32_t ip_addr;
  2000e0:	91400c81 	add	x1, x4, #0x3, lsl #12
  2000e4:	d2808003 	mov	x3, #0x400                 	// #1024
  2000e8:	cb040064 	sub	x4, x3, x4
  2000ec:	8b010001 	add	x1, x0, x1
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  2000f0:	4f000400 	movi	v0.4s, #0x0
  2000f4:	927cec83 	and	x3, x4, #0xfffffffffffffff0
  2000f8:	8b010063 	add	x3, x3, x1
  2000fc:	d503201f 	nop
  200100:	3c810420 	str	q0, [x1], #16
//     uint32_t ip_addr;
  200104:	eb03003f 	cmp	x1, x3
  200108:	54ffffc1 	b.ne	200100 <hashtable_init+0xe0>  // b.any
  20010c:	927cec83 	and	x3, x4, #0xfffffffffffffff0
  200110:	f2400c9f 	tst	x4, #0xf
  200114:	8b0300a1 	add	x1, x5, x3
  200118:	cb030042 	sub	x2, x2, x3
  20011c:	54000b00 	b.eq	20027c <hashtable_init+0x25c>  // b.none
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200120:	8b010003 	add	x3, x0, x1
//     uint32_t ip_addr;
  200124:	f100045f 	cmp	x2, #0x1
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200128:	91400c63 	add	x3, x3, #0x3, lsl #12
//     uint32_t ip_addr;
  20012c:	91000424 	add	x4, x1, #0x1
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200130:	3900007f 	strb	wzr, [x3]
//     uint32_t ip_addr;
  200134:	54000a40 	b.eq	20027c <hashtable_init+0x25c>  // b.none
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200138:	8b040004 	add	x4, x0, x4
//     uint32_t ip_addr;
  20013c:	f100085f 	cmp	x2, #0x2
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200140:	91400c84 	add	x4, x4, #0x3, lsl #12
//     uint32_t ip_addr;
  200144:	91000823 	add	x3, x1, #0x2
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200148:	3900009f 	strb	wzr, [x4]
//     uint32_t ip_addr;
  20014c:	54000980 	b.eq	20027c <hashtable_init+0x25c>  // b.none
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200150:	8b030003 	add	x3, x0, x3
//     uint32_t ip_addr;
  200154:	f1000c5f 	cmp	x2, #0x3
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200158:	91400c63 	add	x3, x3, #0x3, lsl #12
//     uint32_t ip_addr;
  20015c:	91000c24 	add	x4, x1, #0x3
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200160:	3900007f 	strb	wzr, [x3]
//     uint32_t ip_addr;
  200164:	540008c0 	b.eq	20027c <hashtable_init+0x25c>  // b.none
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200168:	8b040004 	add	x4, x0, x4
//     uint32_t ip_addr;
  20016c:	f100105f 	cmp	x2, #0x4
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200170:	91400c84 	add	x4, x4, #0x3, lsl #12
//     uint32_t ip_addr;
  200174:	91001023 	add	x3, x1, #0x4
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200178:	3900009f 	strb	wzr, [x4]
//     uint32_t ip_addr;
  20017c:	54000800 	b.eq	20027c <hashtable_init+0x25c>  // b.none
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200180:	8b030003 	add	x3, x0, x3
//     uint32_t ip_addr;
  200184:	f100145f 	cmp	x2, #0x5
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200188:	91400c63 	add	x3, x3, #0x3, lsl #12
//     uint32_t ip_addr;
  20018c:	91001424 	add	x4, x1, #0x5
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200190:	3900007f 	strb	wzr, [x3]
//     uint32_t ip_addr;
  200194:	54000740 	b.eq	20027c <hashtable_init+0x25c>  // b.none
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200198:	8b040003 	add	x3, x0, x4
//     uint32_t ip_addr;
  20019c:	f100185f 	cmp	x2, #0x6
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  2001a0:	91400c63 	add	x3, x3, #0x3, lsl #12
//     uint32_t ip_addr;
  2001a4:	91001824 	add	x4, x1, #0x6
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  2001a8:	3900007f 	strb	wzr, [x3]
//     uint32_t ip_addr;
  2001ac:	54000680 	b.eq	20027c <hashtable_init+0x25c>  // b.none
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  2001b0:	8b040004 	add	x4, x0, x4
//     uint32_t ip_addr;
  2001b4:	f1001c5f 	cmp	x2, #0x7
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  2001b8:	91400c84 	add	x4, x4, #0x3, lsl #12
//     uint32_t ip_addr;
  2001bc:	91001c23 	add	x3, x1, #0x7
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  2001c0:	3900009f 	strb	wzr, [x4]
//     uint32_t ip_addr;
  2001c4:	540005c0 	b.eq	20027c <hashtable_init+0x25c>  // b.none
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  2001c8:	8b030003 	add	x3, x0, x3
//     uint32_t ip_addr;
  2001cc:	f100205f 	cmp	x2, #0x8
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  2001d0:	91400c63 	add	x3, x3, #0x3, lsl #12
//     uint32_t ip_addr;
  2001d4:	91002024 	add	x4, x1, #0x8
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  2001d8:	3900007f 	strb	wzr, [x3]
//     uint32_t ip_addr;
  2001dc:	54000500 	b.eq	20027c <hashtable_init+0x25c>  // b.none
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  2001e0:	8b040004 	add	x4, x0, x4
//     uint32_t ip_addr;
  2001e4:	f100245f 	cmp	x2, #0x9
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  2001e8:	91400c84 	add	x4, x4, #0x3, lsl #12
//     uint32_t ip_addr;
  2001ec:	91002423 	add	x3, x1, #0x9
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  2001f0:	3900009f 	strb	wzr, [x4]
//     uint32_t ip_addr;
  2001f4:	54000440 	b.eq	20027c <hashtable_init+0x25c>  // b.none
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  2001f8:	8b030003 	add	x3, x0, x3
//     uint32_t ip_addr;
  2001fc:	f100285f 	cmp	x2, #0xa
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200200:	91400c63 	add	x3, x3, #0x3, lsl #12
//     uint32_t ip_addr;
  200204:	91002824 	add	x4, x1, #0xa
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200208:	3900007f 	strb	wzr, [x3]
//     uint32_t ip_addr;
  20020c:	54000380 	b.eq	20027c <hashtable_init+0x25c>  // b.none
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200210:	8b040004 	add	x4, x0, x4
//     uint32_t ip_addr;
  200214:	f1002c5f 	cmp	x2, #0xb
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200218:	91400c84 	add	x4, x4, #0x3, lsl #12
//     uint32_t ip_addr;
  20021c:	91002c23 	add	x3, x1, #0xb
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200220:	3900009f 	strb	wzr, [x4]
//     uint32_t ip_addr;
  200224:	540002c0 	b.eq	20027c <hashtable_init+0x25c>  // b.none
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200228:	8b030003 	add	x3, x0, x3
//     uint32_t ip_addr;
  20022c:	f100305f 	cmp	x2, #0xc
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200230:	91400c63 	add	x3, x3, #0x3, lsl #12
//     uint32_t ip_addr;
  200234:	91003024 	add	x4, x1, #0xc
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200238:	3900007f 	strb	wzr, [x3]
//     uint32_t ip_addr;
  20023c:	54000200 	b.eq	20027c <hashtable_init+0x25c>  // b.none
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200240:	8b040004 	add	x4, x0, x4
//     uint32_t ip_addr;
  200244:	f100345f 	cmp	x2, #0xd
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200248:	91400c84 	add	x4, x4, #0x3, lsl #12
//     uint32_t ip_addr;
  20024c:	91003423 	add	x3, x1, #0xd
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200250:	3900009f 	strb	wzr, [x4]
//     uint32_t ip_addr;
  200254:	54000140 	b.eq	20027c <hashtable_init+0x25c>  // b.none
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200258:	8b030003 	add	x3, x0, x3
//     uint32_t ip_addr;
  20025c:	91003821 	add	x1, x1, #0xe
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200260:	91400c63 	add	x3, x3, #0x3, lsl #12
//     uint32_t ip_addr;
  200264:	f100385f 	cmp	x2, #0xe
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200268:	3900007f 	strb	wzr, [x3]
//     uint32_t ip_addr;
  20026c:	54000080 	b.eq	20027c <hashtable_init+0x25c>  // b.none
//     uint8_t mac_addr[ETH_HWADDR_LEN];
  200270:	8b010000 	add	x0, x0, x1
  200274:	91400c00 	add	x0, x0, #0x3, lsl #12
  200278:	3900001f 	strb	wzr, [x0]
//     /* @kwinter: Add a timeout for stale ARP entiries*/
//     // uint32_t timeout;
  20027c:	d65f03c0 	ret
//     uint32_t ip_addr;
  200280:	d2807fe2 	mov	x2, #0x3ff                 	// #1023
  200284:	d2800025 	mov	x5, #0x1                   	// #1
  200288:	17ffff96 	b	2000e0 <hashtable_init+0xc0>
  20028c:	d2807fc2 	mov	x2, #0x3fe                 	// #1022
  200290:	d2800045 	mov	x5, #0x2                   	// #2
  200294:	17ffff93 	b	2000e0 <hashtable_init+0xc0>
  200298:	d2800005 	mov	x5, #0x0                   	// #0
  20029c:	d2808002 	mov	x2, #0x400                 	// #1024
  2002a0:	17ffff90 	b	2000e0 <hashtable_init+0xc0>
  2002a4:	d2807fa2 	mov	x2, #0x3fd                 	// #1021
  2002a8:	d2800065 	mov	x5, #0x3                   	// #3
  2002ac:	17ffff8d 	b	2000e0 <hashtable_init+0xc0>
  2002b0:	d2807f82 	mov	x2, #0x3fc                 	// #1020
  2002b4:	d2800085 	mov	x5, #0x4                   	// #4
  2002b8:	17ffff8a 	b	2000e0 <hashtable_init+0xc0>
  2002bc:	aa0403e5 	mov	x5, x4
  2002c0:	d2807ec2 	mov	x2, #0x3f6                 	// #1014
  2002c4:	17ffff87 	b	2000e0 <hashtable_init+0xc0>
  2002c8:	aa0403e5 	mov	x5, x4
  2002cc:	d2807f62 	mov	x2, #0x3fb                 	// #1019
  2002d0:	17ffff84 	b	2000e0 <hashtable_init+0xc0>
  2002d4:	d2807f22 	mov	x2, #0x3f9                 	// #1017
  2002d8:	d28000e5 	mov	x5, #0x7                   	// #7
  2002dc:	17ffff81 	b	2000e0 <hashtable_init+0xc0>
  2002e0:	aa0403e5 	mov	x5, x4
  2002e4:	d2807f42 	mov	x2, #0x3fa                 	// #1018
  2002e8:	17ffff7e 	b	2000e0 <hashtable_init+0xc0>
  2002ec:	d2807f02 	mov	x2, #0x3f8                 	// #1016
  2002f0:	d2800105 	mov	x5, #0x8                   	// #8
  2002f4:	17ffff7b 	b	2000e0 <hashtable_init+0xc0>
  2002f8:	d2800125 	mov	x5, #0x9                   	// #9
  2002fc:	d2807ee2 	mov	x2, #0x3f7                 	// #1015
  200300:	17ffff78 	b	2000e0 <hashtable_init+0xc0>
  200304:	aa0403e5 	mov	x5, x4
  200308:	d2807ea2 	mov	x2, #0x3f5                 	// #1013
  20030c:	17ffff75 	b	2000e0 <hashtable_init+0xc0>
  200310:	d2807e42 	mov	x2, #0x3f2                 	// #1010
  200314:	d28001c5 	mov	x5, #0xe                   	// #14
  200318:	17ffff72 	b	2000e0 <hashtable_init+0xc0>
  20031c:	aa0403e5 	mov	x5, x4
  200320:	d2807e82 	mov	x2, #0x3f4                 	// #1012
  200324:	17ffff6f 	b	2000e0 <hashtable_init+0xc0>
  200328:	aa0403e5 	mov	x5, x4
  20032c:	d2807e62 	mov	x2, #0x3f3                 	// #1011
  200330:	17ffff6c 	b	2000e0 <hashtable_init+0xc0>
  200334:	d503201f 	nop
  200338:	d503201f 	nop
  20033c:	d503201f 	nop

0000000000200340 <hashtable_insert>:
#include "config.h"
  200340:	12002429 	and	w9, w1, #0x3ff
// This component needs to be connected to BOTH rx and tx of this
// network subsystem.

__attribute__((__section__(".arp_resources"))) arp_requester_config_t arp_config;

__attribute__((__section__(".net_client_config"))) net_client_config_t net_config;
  200344:	d2800188 	mov	x8, #0xc                   	// #12
// This component needs to be connected to BOTH rx and tx of this
  200348:	2a0903e3 	mov	w3, w9

  20034c:	14000007 	b	200368 <hashtable_insert+0x28>
__attribute__((__section__(".net_client_config"))) net_client_config_t net_config;
  200350:	b8666804 	ldr	w4, [x0, x6]
  200354:	6b01009f 	cmp	w4, w1
  200358:	540004c0 	b.eq	2003f0 <hashtable_insert+0xb0>  // b.none

hashtable_t arp_table;
net_queue_handle_t virt_tx_queue;
net_queue_handle_t virt_rx_queue;
/* @kwinter: This needs to be placed in shared memory with the routing component
  20035c:	120024e3 	and	w3, w7, #0x3ff
to reduce ARP checking overhead. We should only invoke this component when we cannot
  200360:	6b03013f 	cmp	w9, w3
  200364:	54000440 	b.eq	2003ec <hashtable_insert+0xac>  // b.none

  200368:	2a0303e5 	mov	w5, w3
/* @kwinter: This needs to be placed in shared memory with the routing component
  20036c:	11000467 	add	w7, w3, #0x1

  200370:	8b050004 	add	x4, x0, x5
  200374:	91400c84 	add	x4, x4, #0x3, lsl #12
__attribute__((__section__(".net_client_config"))) net_client_config_t net_config;
  200378:	9b087ca6 	mul	x6, x5, x8

  20037c:	39400084 	ldrb	w4, [x4]
  200380:	35fffe84 	cbnz	w4, 200350 <hashtable_insert+0x10>
arp_entry_t arp_cache[MAX_ARP_CACHE];

/* This queue will hold all the ARP requests/responses that are needed by the
packets in the arp_waiting queue. */
arp_queue_handle_t arp_query;

  200384:	d2800184 	mov	x4, #0xc                   	// #12
void process_requests()
  200388:	d2800087 	mov	x7, #0x4                   	// #4
  20038c:	91000446 	add	x6, x2, #0x1
  200390:	9ba41c63 	umaddl	x3, w3, w4, x7

  200394:	9b047ca7 	mul	x7, x5, x4
void process_requests()
  200398:	8b030004 	add	x4, x0, x3
  20039c:	aa020088 	orr	x8, x4, x2
  2003a0:	cb060086 	sub	x6, x4, x6

  2003a4:	b8276801 	str	w1, [x0, x7]

static inline void *sddf_memcpy(void *dest, const void *src, size_t n)
{
    unsigned char *to = dest;
    const unsigned char *from = src;
    while (n-- > 0) {
  2003a8:	f240091f 	tst	x8, #0x7
  2003ac:	fa4608c0 	ccmp	x6, #0x6, #0x0, eq	// eq = none
  2003b0:	54000489 	b.ls	200440 <hashtable_insert+0x100>  // b.plast
        *to++ = *from++;
  2003b4:	fd400040 	ldr	d0, [x2]
  2003b8:	fc236800 	str	d0, [x0, x3]
  2003bc:	39402041 	ldrb	w1, [x2, #8]
    }

    // Insert the new entry
    table->entries[index].key = key;
    sddf_memcpy(&table->entries[index].value, value, sizeof(entry_t));
    table->used[index] = 1;  // Mark this slot as used
  2003c0:	8b050000 	add	x0, x0, x5
  2003c4:	39002081 	strb	w1, [x4, #8]
  2003c8:	91400c00 	add	x0, x0, #0x3, lsl #12
  2003cc:	39402441 	ldrb	w1, [x2, #9]
  2003d0:	39002481 	strb	w1, [x4, #9]
  2003d4:	39402841 	ldrb	w1, [x2, #10]
  2003d8:	39002881 	strb	w1, [x4, #10]
  2003dc:	39402c41 	ldrb	w1, [x2, #11]
  2003e0:	39002c81 	strb	w1, [x4, #11]
  2003e4:	52800021 	mov	w1, #0x1                   	// #1
  2003e8:	39000001 	strb	w1, [x0]
}
  2003ec:	d65f03c0 	ret
            sddf_memcpy(&table->entries[index].value, value, sizeof(entry_t));
  2003f0:	d2800081 	mov	x1, #0x4                   	// #4
  2003f4:	91000444 	add	x4, x2, #0x1
  2003f8:	9ba80463 	umaddl	x3, w3, w8, x1
  2003fc:	8b030001 	add	x1, x0, x3
    while (n-- > 0) {
  200400:	aa020025 	orr	x5, x1, x2
  200404:	cb040024 	sub	x4, x1, x4
  200408:	f24008bf 	tst	x5, #0x7
  20040c:	fa460880 	ccmp	x4, #0x6, #0x0, eq	// eq = none
  200410:	540003a9 	b.ls	200484 <hashtable_insert+0x144>  // b.plast
        *to++ = *from++;
  200414:	fd400040 	ldr	d0, [x2]
  200418:	fc236800 	str	d0, [x0, x3]
  20041c:	39402040 	ldrb	w0, [x2, #8]
  200420:	39002020 	strb	w0, [x1, #8]
  200424:	39402440 	ldrb	w0, [x2, #9]
  200428:	39002420 	strb	w0, [x1, #9]
  20042c:	39402840 	ldrb	w0, [x2, #10]
  200430:	39002820 	strb	w0, [x1, #10]
  200434:	39402c40 	ldrb	w0, [x2, #11]
  200438:	39002c20 	strb	w0, [x1, #11]
}
  20043c:	d65f03c0 	ret
  200440:	39400041 	ldrb	w1, [x2]
  200444:	38236801 	strb	w1, [x0, x3]
  200448:	39400441 	ldrb	w1, [x2, #1]
  20044c:	39000481 	strb	w1, [x4, #1]
  200450:	39400841 	ldrb	w1, [x2, #2]
  200454:	39000881 	strb	w1, [x4, #2]
  200458:	39400c41 	ldrb	w1, [x2, #3]
  20045c:	39000c81 	strb	w1, [x4, #3]
  200460:	39401041 	ldrb	w1, [x2, #4]
  200464:	39001081 	strb	w1, [x4, #4]
  200468:	39401441 	ldrb	w1, [x2, #5]
  20046c:	39001481 	strb	w1, [x4, #5]
  200470:	39401841 	ldrb	w1, [x2, #6]
  200474:	39001881 	strb	w1, [x4, #6]
  200478:	39401c41 	ldrb	w1, [x2, #7]
  20047c:	39001c81 	strb	w1, [x4, #7]
  200480:	17ffffcf 	b	2003bc <hashtable_insert+0x7c>
  200484:	39400044 	ldrb	w4, [x2]
  200488:	38236804 	strb	w4, [x0, x3]
  20048c:	39400440 	ldrb	w0, [x2, #1]
  200490:	39000420 	strb	w0, [x1, #1]
  200494:	39400840 	ldrb	w0, [x2, #2]
  200498:	39000820 	strb	w0, [x1, #2]
  20049c:	39400c40 	ldrb	w0, [x2, #3]
  2004a0:	39000c20 	strb	w0, [x1, #3]
  2004a4:	39401040 	ldrb	w0, [x2, #4]
  2004a8:	39001020 	strb	w0, [x1, #4]
  2004ac:	39401440 	ldrb	w0, [x2, #5]
  2004b0:	39001420 	strb	w0, [x1, #5]
  2004b4:	39401840 	ldrb	w0, [x2, #6]
  2004b8:	39001820 	strb	w0, [x1, #6]
  2004bc:	39401c40 	ldrb	w0, [x2, #7]
  2004c0:	39001c20 	strb	w0, [x1, #7]
  2004c4:	17ffffd6 	b	20041c <hashtable_insert+0xdc>
  2004c8:	d503201f 	nop
  2004cc:	d503201f 	nop

00000000002004d0 <hashtable_search>:
    return key % TABLE_SIZE;
  2004d0:	12002428 	and	w8, w1, #0x3ff
void hashtable_search(hashtable_t *table, uint32_t key, arp_entry_t *value) {
    uint32_t index = hash(key);
    uint32_t original_index = index;

    while (table->used[index]) {
        if (table->entries[index].key == key) {
  2004d4:	d2800187 	mov	x7, #0xc                   	// #12
    uint32_t index = hash(key);
  2004d8:	2a0803e4 	mov	w4, w8
            sddf_memcpy(value, &table->entries[index].value, sizeof(entry_t));
  2004dc:	d2800089 	mov	x9, #0x4                   	// #4
    while (table->used[index]) {
  2004e0:	14000004 	b	2004f0 <hashtable_search+0x20>
        }
        index = (index + 1) % TABLE_SIZE;
  2004e4:	120024c4 	and	w4, w6, #0x3ff
        if (index == original_index) {
  2004e8:	6b04011f 	cmp	w8, w4
  2004ec:	54000500 	b.eq	20058c <hashtable_search+0xbc>  // b.none
    while (table->used[index]) {
  2004f0:	2a0403e3 	mov	w3, w4
        index = (index + 1) % TABLE_SIZE;
  2004f4:	11000486 	add	w6, w4, #0x1
    while (table->used[index]) {
  2004f8:	8b030005 	add	x5, x0, x3
  2004fc:	91400ca5 	add	x5, x5, #0x3, lsl #12
        if (table->entries[index].key == key) {
  200500:	9b077c63 	mul	x3, x3, x7
    while (table->used[index]) {
  200504:	394000a5 	ldrb	w5, [x5]
  200508:	34000425 	cbz	w5, 20058c <hashtable_search+0xbc>
        if (table->entries[index].key == key) {
  20050c:	b8636803 	ldr	w3, [x0, x3]
  200510:	6b01007f 	cmp	w3, w1
  200514:	54fffe81 	b.ne	2004e4 <hashtable_search+0x14>  // b.any
            sddf_memcpy(value, &table->entries[index].value, sizeof(entry_t));
  200518:	9ba72484 	umaddl	x4, w4, w7, x9
  20051c:	8b040003 	add	x3, x0, x4
  200520:	38646804 	ldrb	w4, [x0, x4]
  200524:	39000044 	strb	w4, [x2]
  200528:	39400464 	ldrb	w4, [x3, #1]
  20052c:	39000444 	strb	w4, [x2, #1]
  200530:	39400864 	ldrb	w4, [x3, #2]
  200534:	39000844 	strb	w4, [x2, #2]
  200538:	39400c64 	ldrb	w4, [x3, #3]
  20053c:	39000c44 	strb	w4, [x2, #3]
  200540:	39401064 	ldrb	w4, [x3, #4]
  200544:	39001044 	strb	w4, [x2, #4]
  200548:	39401464 	ldrb	w4, [x3, #5]
  20054c:	39001444 	strb	w4, [x2, #5]
  200550:	39401864 	ldrb	w4, [x3, #6]
  200554:	39001844 	strb	w4, [x2, #6]
  200558:	39401c64 	ldrb	w4, [x3, #7]
  20055c:	39001c44 	strb	w4, [x2, #7]
  200560:	39402064 	ldrb	w4, [x3, #8]
  200564:	39002044 	strb	w4, [x2, #8]
  200568:	39402464 	ldrb	w4, [x3, #9]
  20056c:	39002444 	strb	w4, [x2, #9]
  200570:	39402864 	ldrb	w4, [x3, #10]
  200574:	39002844 	strb	w4, [x2, #10]
        index = (index + 1) % TABLE_SIZE;
  200578:	120024c4 	and	w4, w6, #0x3ff
        if (index == original_index) {
  20057c:	6b04011f 	cmp	w8, w4
  200580:	39402c63 	ldrb	w3, [x3, #11]
  200584:	39002c43 	strb	w3, [x2, #11]
  200588:	54fffb41 	b.ne	2004f0 <hashtable_search+0x20>  // b.any
            // Full cycle completed, element not found
            break;
        }
    }
    value = NULL;  // Not found
}
  20058c:	d65f03c0 	ret

0000000000200590 <hashtable_remove>:
    return key % TABLE_SIZE;
  200590:	12002426 	and	w6, w1, #0x3ff
void hashtable_remove(hashtable_t *table, uint32_t key) {
    uint32_t index = hash(key);
    uint32_t original_index = index;

    while (table->used[index]) {
        if (table->entries[index].key == key) {
  200594:	d2800187 	mov	x7, #0xc                   	// #12
    uint32_t index = hash(key);
  200598:	2a0603e2 	mov	w2, w6
    while (table->used[index]) {
  20059c:	14000006 	b	2005b4 <hashtable_remove+0x24>
        if (table->entries[index].key == key) {
  2005a0:	b8636803 	ldr	w3, [x0, x3]
  2005a4:	6b01007f 	cmp	w3, w1
  2005a8:	54000180 	b.eq	2005d8 <hashtable_remove+0x48>  // b.none
            // Mark the slot as unused and clear the entry
            table->used[index] = 0;
            return;
        }
        index = (index + 1) % TABLE_SIZE;
        if (index == original_index) {
  2005ac:	6b0200df 	cmp	w6, w2
  2005b0:	54000120 	b.eq	2005d4 <hashtable_remove+0x44>  // b.none
    while (table->used[index]) {
  2005b4:	2a0203e3 	mov	w3, w2
        index = (index + 1) % TABLE_SIZE;
  2005b8:	11000442 	add	w2, w2, #0x1
    while (table->used[index]) {
  2005bc:	8b030004 	add	x4, x0, x3
        index = (index + 1) % TABLE_SIZE;
  2005c0:	12002442 	and	w2, w2, #0x3ff
    while (table->used[index]) {
  2005c4:	91400c84 	add	x4, x4, #0x3, lsl #12
        if (table->entries[index].key == key) {
  2005c8:	9b077c63 	mul	x3, x3, x7
    while (table->used[index]) {
  2005cc:	39400085 	ldrb	w5, [x4]
  2005d0:	35fffe85 	cbnz	w5, 2005a0 <hashtable_remove+0x10>
            // Full cycle completed, element not found
            break;
        }
    }
  2005d4:	d65f03c0 	ret
            table->used[index] = 0;
  2005d8:	3900009f 	strb	wzr, [x4]
  2005dc:	d65f03c0 	ret

00000000002005e0 <process_requests>:
{
  2005e0:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  2005e4:	910003fd 	mov	x29, sp
  2005e8:	a90363f7 	stp	x23, x24, [sp, #48]
 *
 * @return true indicates the queue is empty, false otherwise.
 */
static inline bool arp_queue_empty_request(arp_queue_handle_t *queue)
{
    return queue->request.tail - queue->request.head == 0;
  2005ec:	90000020 	adrp	x0, 204000 <__sel4_ipc_buffer>
  2005f0:	9103c017 	add	x23, x0, #0xf0
    bool transmitted = false;
    // Loop through and generate ARP requests.
    while (!arp_queue_empty_request(&arp_query)) {
  2005f4:	7941e000 	ldrh	w0, [x0, #240]
  2005f8:	794006e3 	ldrh	w3, [x23, #2]
  2005fc:	6b03001f 	cmp	w0, w3
  200600:	54000d60 	b.eq	2007ac <process_requests+0x1cc>  // b.none
  200604:	a9046bf9 	stp	x25, x26, [sp, #64]
  200608:	90000039 	adrp	x25, 204000 <__sel4_ipc_buffer>
  20060c:	91030339 	add	x25, x25, #0xc0
  200610:	a90573fb 	stp	x27, x28, [sp, #80]
  200614:	9000003c 	adrp	x28, 204000 <__sel4_ipc_buffer>
  200618:	9100e39c 	add	x28, x28, #0x38
            pkt->ethdst_addr[i] = 0xFF;
        }
        // @kwinter: Need to be able to somehow get the MAC address from the driver.
        // memcpy(&reply->ethsrc_addr, ethsrc_addr, ETH_HWADDR_LEN);

        pkt->type = HTONS(ETH_TYPE_ARP);
  20061c:	5280011b 	mov	w27, #0x8                   	// #8
  200620:	528000da 	mov	w26, #0x6                   	// #6
  200624:	a90153f3 	stp	x19, x20, [sp, #16]
            pkt->ethdst_addr[i] = 0xFF;
  200628:	12800014 	mov	w20, #0xffffffff            	// #-1
  20062c:	a9025bf5 	stp	x21, x22, [sp, #32]
{
    if (arp_queue_empty_request(queue)) {
        return -1;
    }

    arp_request_t req = queue->request.queue[queue->request.head % queue->capacity];
  200630:	52800196 	mov	w22, #0xc                   	// #12
  200634:	d503201f 	nop
  200638:	b9700ae4 	ldr	w4, [x23, #12296]
        pkt->hwtype = HTONS(ETH_HWTYPE);
  20063c:	52800026 	mov	w6, #0x1                   	// #1
    sddf_memcpy(request, &req, sizeof(arp_request_t));

    queue->request.head++;
  200640:	0b060068 	add	w8, w3, w6
        pkt->proto = HTONS(ETH_TYPE_IP);
        pkt->hwlen = ETH_HWADDR_LEN;
        pkt->protolen = IPV4_PROTO_LEN;
  200644:	52800087 	mov	w7, #0x4                   	// #4
        // @kwinter: Need to somehow know our IP address here as well as MAC address.
        // memcpy(&request->hwsrc_addr, hwsrc_addr, ETH_HWADDR_LEN);
        // request->ipsrc_addr = ipsrc_addr;

        // Memset the hardware src addr to 0 for ARP requests.
        memset(&pkt->hwdst_addr, 0, ETH_HWADDR_LEN);
  200648:	d28000c2 	mov	x2, #0x6                   	// #6
  20064c:	52800001 	mov	w1, #0x0                   	// #0
    arp_request_t req = queue->request.queue[queue->request.head % queue->capacity];
  200650:	1ac40860 	udiv	w0, w3, w4
  200654:	1b048c00 	msub	w0, w0, w4, w3
  200658:	d2800083 	mov	x3, #0x4                   	// #4
  20065c:	9bb60c00 	umaddl	x0, w0, w22, x3
 *
 * @return true indicates the queue is empty, false otherwise.
 */
static inline bool net_queue_empty_free(net_queue_handle_t *queue)
{
    return queue->free->tail - queue->free->head == 0;
  200660:	f9400323 	ldr	x3, [x25]
  200664:	b8606af8 	ldr	w24, [x23, x0]
  200668:	79400464 	ldrh	w4, [x3, #2]
 *
 * @return -1 when queue is empty, 0 on success.
 */
static inline int net_dequeue_free(net_queue_handle_t *queue, net_buff_desc_t *buffer)
{
    if (net_queue_empty_free(queue)) {
  20066c:	79400060 	ldrh	w0, [x3]
    queue->request.head++;
  200670:	790006e8 	strh	w8, [x23, #2]

    *buffer = queue->free->buffers[queue->free->head % queue->capacity];
#ifdef CONFIG_ENABLE_SMP_SUPPORT
    THREAD_MEMORY_RELEASE();
#endif
    queue->free->head++;
  200674:	0b060088 	add	w8, w4, w6
    if (net_queue_empty_free(queue)) {
  200678:	6b04001f 	cmp	w0, w4
  20067c:	540000e0 	b.eq	200698 <process_requests+0xb8>  // b.none
    *buffer = queue->free->buffers[queue->free->head % queue->capacity];
  200680:	b9401325 	ldr	w5, [x25, #16]
  200684:	1ac50880 	udiv	w0, w4, w5
  200688:	1b059000 	msub	w0, w0, w5, w4
  20068c:	8b001060 	add	x0, x3, x0, lsl #4
  200690:	f9400415 	ldr	x21, [x0, #8]
    queue->free->head++;
  200694:	79000468 	strh	w8, [x3, #2]
        struct arp_packet *pkt = (struct arp_packet *)(net_config.tx_data.vaddr + buffer.io_or_offset);
  200698:	f9403780 	ldr	x0, [x28, #104]
  20069c:	8b150013 	add	x19, x0, x21
            pkt->ethdst_addr[i] = 0xFF;
  2006a0:	38356814 	strb	w20, [x0, x21]
        memset(&pkt->hwdst_addr, 0, ETH_HWADDR_LEN);
  2006a4:	91008260 	add	x0, x19, #0x20
            pkt->ethdst_addr[i] = 0xFF;
  2006a8:	39000674 	strb	w20, [x19, #1]
  2006ac:	39000a74 	strb	w20, [x19, #2]
  2006b0:	39000e74 	strb	w20, [x19, #3]
  2006b4:	39001274 	strb	w20, [x19, #4]
  2006b8:	39001674 	strb	w20, [x19, #5]
        pkt->type = HTONS(ETH_TYPE_ARP);
  2006bc:	3900327b 	strb	w27, [x19, #12]
  2006c0:	3900367a 	strb	w26, [x19, #13]
        pkt->hwtype = HTONS(ETH_HWTYPE);
  2006c4:	39003a7f 	strb	wzr, [x19, #14]
  2006c8:	39003e66 	strb	w6, [x19, #15]
        pkt->proto = HTONS(ETH_TYPE_IP);
  2006cc:	3900427b 	strb	w27, [x19, #16]
  2006d0:	3900467f 	strb	wzr, [x19, #17]
        pkt->hwlen = ETH_HWADDR_LEN;
  2006d4:	39004a7a 	strb	w26, [x19, #18]
        pkt->protolen = IPV4_PROTO_LEN;
  2006d8:	39004e67 	strb	w7, [x19, #19]
        pkt->opcode = HTONS(ETHARP_OPCODE_REQUEST);
  2006dc:	3900527f 	strb	wzr, [x19, #20]
  2006e0:	39005666 	strb	w6, [x19, #21]
        memset(&pkt->hwdst_addr, 0, ETH_HWADDR_LEN);
  2006e4:	94000267 	bl	201080 <memset>
        pkt->ipdst_addr = request.ip_addr;
  2006e8:	39009a78 	strb	w24, [x19, #38]
  2006ec:	53187f03 	lsr	w3, w24, #24
  2006f0:	d3483f02 	ubfx	x2, x24, #8, #8
  2006f4:	d3505f01 	ubfx	x1, x24, #16, #8
  2006f8:	39009e62 	strb	w2, [x19, #39]
  2006fc:	3900a261 	strb	w1, [x19, #40]
        memset(&pkt->padding, 0, 10);
  200700:	d2800142 	mov	x2, #0xa                   	// #10
        pkt->ipdst_addr = request.ip_addr;
  200704:	3900a663 	strb	w3, [x19, #41]
        memset(&pkt->padding, 0, 10);
  200708:	52800001 	mov	w1, #0x0                   	// #0
  20070c:	9100aa60 	add	x0, x19, #0x2a
  200710:	9400025c 	bl	201080 <memset>
    return queue->active->tail - queue->active->head == queue->capacity;
  200714:	f9400721 	ldr	x1, [x25, #8]
    queue->active->buffers[queue->active->tail % queue->capacity] = buffer;
  200718:	d2800108 	mov	x8, #0x8                   	// #8
    return queue->active->tail - queue->active->head == queue->capacity;
  20071c:	b9401324 	ldr	w4, [x25, #16]
    queue->active->buffers[queue->active->tail % queue->capacity] = buffer;
  200720:	52800707 	mov	w7, #0x38                  	// #56
    return queue->active->tail - queue->active->head == queue->capacity;
  200724:	79400022 	ldrh	w2, [x1]
  200728:	79400420 	ldrh	w0, [x1, #2]
    queue->active->tail++;
  20072c:	11000446 	add	w6, w2, #0x1
    return queue->active->tail - queue->active->head == queue->capacity;
  200730:	4b000040 	sub	w0, w2, w0
    if (net_queue_full_active(queue)) {
  200734:	6b04001f 	cmp	w0, w4
  200738:	540004e0 	b.eq	2007d4 <process_requests+0x1f4>  // b.none
    queue->active->buffers[queue->active->tail % queue->capacity] = buffer;
  20073c:	1ac40840 	udiv	w0, w2, w4
    return queue->request.tail - queue->request.head == 0;
  200740:	794006e3 	ldrh	w3, [x23, #2]
    while (!arp_queue_empty_request(&arp_query)) {
  200744:	794002e9 	ldrh	w9, [x23]
  200748:	6b03013f 	cmp	w9, w3
  20074c:	1b048800 	msub	w0, w0, w4, w2
  200750:	8b205100 	add	x0, x8, w0, uxtw #4
  200754:	8b000022 	add	x2, x1, x0
  200758:	f8206835 	str	x21, [x1, x0]
  20075c:	79001047 	strh	w7, [x2, #8]
    queue->active->tail++;
  200760:	79000026 	strh	w6, [x1]
  200764:	54fff6a1 	b.ne	200638 <process_requests+0x58>  // b.any
 *
 * @param queue queue handle of the active queue to check.
 */
static inline bool net_require_signal_active(net_queue_handle_t *queue)
{
    return !queue->active->consumer_signalled;
  200768:	f9400720 	ldr	x0, [x25, #8]
        buffer.len = 56;
        err = net_enqueue_active(&virt_tx_queue, buffer);
        assert(!err);
        transmitted = true;
    }
    if (transmitted && net_require_signal_active(&virt_tx_queue)) {
  20076c:	b9400401 	ldr	w1, [x0, #4]
  200770:	35000241 	cbnz	w1, 2007b8 <process_requests+0x1d8>

static inline void microkit_deferred_notify(microkit_channel ch)
{
    microkit_have_signal = seL4_True;
    microkit_signal_msg = seL4_MessageInfo_new(0, 0, 0, 0);
    microkit_signal_cap = (BASE_OUTPUT_NOTIFICATION_CAP + ch);
  200774:	a94153f3 	ldp	x19, x20, [sp, #16]
    queue->active->consumer_signalled = 1;
  200778:	52800021 	mov	w1, #0x1                   	// #1
  20077c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  200780:	d0000042 	adrp	x2, 20a000 <arp_table+0x2d40>
  200784:	a9446bf9 	ldp	x25, x26, [sp, #64]
  200788:	b9000401 	str	w1, [x0, #4]
    microkit_have_signal = seL4_True;
  20078c:	d0000044 	adrp	x4, 20a000 <arp_table+0x2d40>
    microkit_signal_msg = seL4_MessageInfo_new(0, 0, 0, 0);
  200790:	d0000043 	adrp	x3, 20a000 <arp_table+0x2d40>
    microkit_signal_cap = (BASE_OUTPUT_NOTIFICATION_CAP + ch);
  200794:	39418b80 	ldrb	w0, [x28, #98]
  200798:	a94573fb 	ldp	x27, x28, [sp, #80]
  20079c:	91002800 	add	x0, x0, #0xa
    microkit_have_signal = seL4_True;
  2007a0:	391c0481 	strb	w1, [x4, #1793]
    microkit_signal_msg = seL4_MessageInfo_new(0, 0, 0, 0);
  2007a4:	f903847f 	str	xzr, [x3, #1800]
    microkit_signal_cap = (BASE_OUTPUT_NOTIFICATION_CAP + ch);
  2007a8:	f9038840 	str	x0, [x2, #1808]
        net_cancel_signal_active(&virt_tx_queue);
        // @kwinter: Figure out how to get the channel ID.
        microkit_deferred_notify(net_config.tx.id);
    }
}
  2007ac:	a94363f7 	ldp	x23, x24, [sp, #48]
  2007b0:	a8c67bfd 	ldp	x29, x30, [sp], #96
  2007b4:	d65f03c0 	ret
  2007b8:	a94153f3 	ldp	x19, x20, [sp, #16]
  2007bc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  2007c0:	a94363f7 	ldp	x23, x24, [sp, #48]
  2007c4:	a9446bf9 	ldp	x25, x26, [sp, #64]
  2007c8:	a94573fb 	ldp	x27, x28, [sp, #80]
  2007cc:	a8c67bfd 	ldp	x29, x30, [sp], #96
  2007d0:	d65f03c0 	ret
        assert(!err);
  2007d4:	d0000003 	adrp	x3, 202000 <_vsnprintf+0x150>
  2007d8:	f0000001 	adrp	x1, 203000 <__FUNCTION__.0+0x68>
  2007dc:	913da063 	add	x3, x3, #0xf68
  2007e0:	91024021 	add	x1, x1, #0x90
  2007e4:	f0000000 	adrp	x0, 203000 <__FUNCTION__.0+0x68>
  2007e8:	52800ba2 	mov	w2, #0x5d                  	// #93
  2007ec:	91036000 	add	x0, x0, #0xd8
  2007f0:	940009bc 	bl	202ee0 <_assert_fail>
  2007f4:	794006e3 	ldrh	w3, [x23, #2]
    while (!arp_queue_empty_request(&arp_query)) {
  2007f8:	794002e0 	ldrh	w0, [x23]
  2007fc:	6b03001f 	cmp	w0, w3
  200800:	54fff1c1 	b.ne	200638 <process_requests+0x58>  // b.any
  200804:	17ffffd9 	b	200768 <process_requests+0x188>
  200808:	d503201f 	nop
  20080c:	d503201f 	nop

0000000000200810 <process_responses>:

void process_responses()
{
  200810:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  200814:	910003fd 	mov	x29, sp
  200818:	a90153f3 	stp	x19, x20, [sp, #16]
    return queue->active->tail - queue->active->head == 0;
  20081c:	90000033 	adrp	x19, 204000 <__sel4_ipc_buffer>
  200820:	91030273 	add	x19, x19, #0xc0
  200824:	a9025bf5 	stp	x21, x22, [sp, #32]
  200828:	90000034 	adrp	x20, 204000 <__sel4_ipc_buffer>
  20082c:	9100e294 	add	x20, x20, #0x38
  200830:	f9401263 	ldr	x3, [x19, #32]
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  200834:	d2800115 	mov	x21, #0x8                   	// #8
    return queue->active->tail - queue->active->head == 0;
  200838:	79400464 	ldrh	w4, [x3, #2]
    bool signal = false;
    while (!net_queue_empty_active(&virt_rx_queue)) {
  20083c:	79400060 	ldrh	w0, [x3]
  200840:	6b04001f 	cmp	w0, w4
  200844:	540002c1 	b.ne	20089c <process_responses+0x8c>  // b.any
  200848:	1400005d 	b	2009bc <process_responses+0x1ac>
    return queue->free->tail - queue->free->head == queue->capacity;
  20084c:	f9400e62 	ldr	x2, [x19, #24]
  200850:	91006276 	add	x22, x19, #0x18
  200854:	79400044 	ldrh	w4, [x2]
  200858:	79400440 	ldrh	w0, [x2, #2]
  20085c:	4b000080 	sub	w0, w4, w0
    if (net_queue_full_free(queue)) {
  200860:	6b00003f 	cmp	w1, w0
  200864:	54000cc0 	b.eq	2009fc <process_responses+0x1ec>  // b.none
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  200868:	1ac10880 	udiv	w0, w4, w1
    queue->free->tail++;
  20086c:	11000486 	add	w6, w4, #0x1
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  200870:	1b019000 	msub	w0, w0, w1, w4
  200874:	8b2052a0 	add	x0, x21, w0, uxtw #4
  200878:	8b000041 	add	x1, x2, x0
  20087c:	f8206845 	str	x5, [x2, x0]
  200880:	7900103f 	strh	wzr, [x1, #8]
    queue->free->tail++;
  200884:	79000046 	strh	w6, [x2]
    return queue->active->tail - queue->active->head == 0;
  200888:	79400464 	ldrh	w4, [x3, #2]
  20088c:	79400060 	ldrh	w0, [x3]
    queue->active->consumer_signalled = 0;
  200890:	b900047f 	str	wzr, [x3, #4]
  200894:	6b04001f 	cmp	w0, w4
  200898:	54000920 	b.eq	2009bc <process_responses+0x1ac>  // b.none
    *buffer = queue->active->buffers[queue->active->head % queue->capacity];
  20089c:	b9402a61 	ldr	w1, [x19, #40]
    queue->active->head++;
  2008a0:	11000486 	add	w6, w4, #0x1
        net_buff_desc_t buffer;
        int err = net_dequeue_active(&virt_rx_queue, &buffer);
        assert(!err);

        /* Check if packet is an ARP request */
        struct ethernet_header *ethhdr = (struct ethernet_header *)(net_config.rx_data.vaddr + buffer.io_or_offset);
  2008a4:	f9401a82 	ldr	x2, [x20, #48]
    *buffer = queue->active->buffers[queue->active->head % queue->capacity];
  2008a8:	1ac10880 	udiv	w0, w4, w1
  2008ac:	1b019000 	msub	w0, w0, w1, w4
  2008b0:	8b001060 	add	x0, x3, x0, lsl #4
  2008b4:	f9400405 	ldr	x5, [x0, #8]
    queue->active->head++;
  2008b8:	79000466 	strh	w6, [x3, #2]
  2008bc:	8b050040 	add	x0, x2, x5
        if (ethhdr->type == HTONS(ETH_TYPE_ARP)) {
  2008c0:	39403004 	ldrb	w4, [x0, #12]
  2008c4:	39403402 	ldrb	w2, [x0, #13]
  2008c8:	2a022082 	orr	w2, w4, w2, lsl #8
  2008cc:	7118205f 	cmp	w2, #0x608
  2008d0:	54fffbe1 	b.ne	20084c <process_responses+0x3c>  // b.any
            struct arp_packet *pkt = (struct arp_packet *)ethhdr;
            /* Check if it's a probe, ignore announcements */
            if (pkt->opcode == HTONS(ETHARP_OPCODE_REPLY)) {
  2008d4:	39405004 	ldrb	w4, [x0, #20]
  2008d8:	39405402 	ldrb	w2, [x0, #21]
  2008dc:	2a022082 	orr	w2, w4, w2, lsl #8
  2008e0:	7108005f 	cmp	w2, #0x200
  2008e4:	54fffb41 	b.ne	20084c <process_responses+0x3c>  // b.any
                // Decode the response data, and place it into the ARP response queue for the
                // routing component.
                arp_request_t resp = {0};
                resp.ip_addr = pkt->ipdst_addr;
  2008e8:	39409804 	ldrb	w4, [x0, #38]
    return queue->response.tail - queue->response.head == queue->capacity;
  2008ec:	90000022 	adrp	x2, 204000 <__sel4_ipc_buffer>
  2008f0:	9103c042 	add	x2, x2, #0xf0
  2008f4:	39409c07 	ldrb	w7, [x0, #39]
  2008f8:	3940a006 	ldrb	w6, [x0, #40]
  2008fc:	3940a40d 	ldrb	w13, [x0, #41]
  200900:	aa072087 	orr	x7, x4, x7, lsl #8
  200904:	79700840 	ldrh	w0, [x2, #6148]
  200908:	79700c44 	ldrh	w4, [x2, #6150]
  20090c:	aa0640e6 	orr	x6, x7, x6, lsl #16
    if (arp_queue_full_active(queue)) {
  200910:	b9700847 	ldr	w7, [x2, #12296]
  200914:	aa0d60cd 	orr	x13, x6, x13, lsl #24
    return queue->response.tail - queue->response.head == queue->capacity;
  200918:	4b040004 	sub	w4, w0, w4
  20091c:	2a0d03ec 	mov	w12, w13
    if (arp_queue_full_active(queue)) {
  200920:	6b07009f 	cmp	w4, w7
  200924:	54000060 	b.eq	200930 <process_responses+0x120>  // b.none
    queue->response.tail++;
  200928:	11000400 	add	w0, w0, #0x1
  20092c:	79300840 	strh	w0, [x2, #6148]
    return key % TABLE_SIZE;
  200930:	120025ab 	and	w11, w13, #0x3ff
    while (table->used[index]) {
  200934:	f0000026 	adrp	x6, 207000 <__global_pointer$+0x27f8>
  200938:	910b00c6 	add	x6, x6, #0x2c0
    uint32_t index = hash(key);
  20093c:	2a0b03e0 	mov	w0, w11
        if (table->entries[index].key == key) {
  200940:	d280018a 	mov	x10, #0xc                   	// #12
    while (table->used[index]) {
  200944:	14000007 	b	200960 <process_responses+0x150>
        if (table->entries[index].key == key) {
  200948:	b86868c2 	ldr	w2, [x6, x8]
  20094c:	6b02019f 	cmp	w12, w2
  200950:	540003e0 	b.eq	2009cc <process_responses+0x1bc>  // b.none
        index = (index + 1) % TABLE_SIZE;
  200954:	12002520 	and	w0, w9, #0x3ff
        if (index == original_index) {
  200958:	6b00017f 	cmp	w11, w0
  20095c:	54fff780 	b.eq	20084c <process_responses+0x3c>  // b.none
    while (table->used[index]) {
  200960:	2a0003e4 	mov	w4, w0
        index = (index + 1) % TABLE_SIZE;
  200964:	11000409 	add	w9, w0, #0x1
    while (table->used[index]) {
  200968:	8b0400c2 	add	x2, x6, x4
  20096c:	91400c42 	add	x2, x2, #0x3, lsl #12
        if (table->entries[index].key == key) {
  200970:	9b0a7c88 	mul	x8, x4, x10
    while (table->used[index]) {
  200974:	39400047 	ldrb	w7, [x2]
  200978:	35fffe87 	cbnz	w7, 200948 <process_responses+0x138>
    table->entries[index].key = key;
  20097c:	d2800187 	mov	x7, #0xc                   	// #12
    sddf_memcpy(&table->entries[index].value, value, sizeof(entry_t));
  200980:	d280008b 	mov	x11, #0x4                   	// #4
  200984:	3940ffea 	ldrb	w10, [sp, #63]
  200988:	52800028 	mov	w8, #0x1                   	// #1
    table->entries[index].key = key;
  20098c:	9b077c84 	mul	x4, x4, x7
  200990:	b94043e9 	ldr	w9, [sp, #64]
    sddf_memcpy(&table->entries[index].value, value, sizeof(entry_t));
  200994:	9ba72c00 	umaddl	x0, w0, w7, x11
  200998:	8b0000c7 	add	x7, x6, x0
    table->entries[index].key = key;
  20099c:	b82468cd 	str	w13, [x6, x4]
  2009a0:	b82068df 	str	wzr, [x6, x0]
  2009a4:	790008ff 	strh	wzr, [x7, #4]
  2009a8:	390018e8 	strb	w8, [x7, #6]
  2009ac:	39001cea 	strb	w10, [x7, #7]
  2009b0:	b90008e9 	str	w9, [x7, #8]
    table->used[index] = 1;  // Mark this slot as used
  2009b4:	39000048 	strb	w8, [x2]
                // We are also going to add the ip -> mac mapping to the ARP table.
                arp_entry_t entry = {0};
                sddf_memcpy(resp.mac_addr, entry.mac_addr, sizeof(uint8_t) * ETH_HWADDR_LEN);
                entry.valid = true;
                hashtable_insert(&arp_table, resp.ip_addr, &entry);
                signal = true;
  2009b8:	17ffffa5 	b	20084c <process_responses+0x3c>
        net_request_signal_active(&virt_rx_queue);
    }

    // @kwinter: Figure out how to get the channel for the routing ID.
    // microkit_deferred_notify(ROUTING_ID);
}
  2009bc:	a94153f3 	ldp	x19, x20, [sp, #16]
  2009c0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  2009c4:	a8c47bfd 	ldp	x29, x30, [sp], #64
  2009c8:	d65f03c0 	ret
            sddf_memcpy(&table->entries[index].value, value, sizeof(entry_t));
  2009cc:	d2800082 	mov	x2, #0x4                   	// #4
  2009d0:	3940ffe7 	ldrb	w7, [sp, #63]
  2009d4:	b94043e4 	ldr	w4, [sp, #64]
  2009d8:	52800028 	mov	w8, #0x1                   	// #1
  2009dc:	9baa0800 	umaddl	x0, w0, w10, x2
  2009e0:	8b0000c2 	add	x2, x6, x0
  2009e4:	b82068df 	str	wzr, [x6, x0]
  2009e8:	7900085f 	strh	wzr, [x2, #4]
  2009ec:	39001848 	strb	w8, [x2, #6]
  2009f0:	39001c47 	strb	w7, [x2, #7]
  2009f4:	b9000844 	str	w4, [x2, #8]
    while (n-- > 0) {
  2009f8:	17ffff95 	b	20084c <process_responses+0x3c>
        assert(!err);
  2009fc:	d0000003 	adrp	x3, 202000 <_vsnprintf+0x150>
  200a00:	913da063 	add	x3, x3, #0xf68
  200a04:	91006063 	add	x3, x3, #0x18
  200a08:	f0000001 	adrp	x1, 203000 <__FUNCTION__.0+0x68>
  200a0c:	f0000000 	adrp	x0, 203000 <__FUNCTION__.0+0x68>
  200a10:	91024021 	add	x1, x1, #0x90
  200a14:	91036000 	add	x0, x0, #0xd8
  200a18:	528010e2 	mov	w2, #0x87                  	// #135
  200a1c:	94000931 	bl	202ee0 <_assert_fail>
    queue->active->consumer_signalled = 0;
  200a20:	f94006c3 	ldr	x3, [x22, #8]
  200a24:	17ffff99 	b	200888 <process_responses+0x78>
  200a28:	d503201f 	nop
  200a2c:	d503201f 	nop

0000000000200a30 <init>:

void init(void)
{
  200a30:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    // arp_queue_init(&arp_queue, net_config.tx.free_queue.vaddr, net_config.tx.active_queue.vaddr,
    //                net_config.tx.num_buffers);
    // @kwinter: We might want to do this initialisation ourselves. This
    // only needs to be the size of an ARP packet. However, the current implementation
    // will work, just not space efficient.
    sddf_dprintf("This is the vaddr of the rx free queue: %p\n",net_config.rx.free_queue.vaddr);
  200a34:	f0000000 	adrp	x0, 203000 <__FUNCTION__.0+0x68>
  200a38:	91038000 	add	x0, x0, #0xe0
{
  200a3c:	910003fd 	mov	x29, sp
  200a40:	a90153f3 	stp	x19, x20, [sp, #16]
    sddf_dprintf("This is the vaddr of the rx free queue: %p\n",net_config.rx.free_queue.vaddr);
  200a44:	90000033 	adrp	x19, 204000 <__sel4_ipc_buffer>
  200a48:	9100e273 	add	x19, x19, #0x38
  200a4c:	f9400661 	ldr	x1, [x19, #8]
  200a50:	94000868 	bl	202bf0 <sddf_printf_>
    queue->free = free;
  200a54:	90000022 	adrp	x2, 204000 <__sel4_ipc_buffer>
  200a58:	91030054 	add	x20, x2, #0xc0
  200a5c:	f9400664 	ldr	x4, [x19, #8]
    net_queue_init(&virt_rx_queue, net_config.rx.free_queue.vaddr, net_config.rx.active_queue.vaddr,
  200a60:	f9400e61 	ldr	x1, [x19, #24]
    queue->active = active;
  200a64:	a9018684 	stp	x4, x1, [x20, #24]
                   net_config.rx.num_buffers);
    net_queue_init(&virt_tx_queue, net_config.tx.free_queue.vaddr, net_config.tx.active_queue.vaddr,
  200a68:	7940c263 	ldrh	w3, [x19, #96]
  200a6c:	f9402261 	ldr	x1, [x19, #64]
    queue->free = free;
  200a70:	f9006041 	str	x1, [x2, #192]
  200a74:	f9402a62 	ldr	x2, [x19, #80]
    queue->active = active;
  200a78:	f9000682 	str	x2, [x20, #8]
    net_queue_init(&virt_rx_queue, net_config.rx.free_queue.vaddr, net_config.rx.active_queue.vaddr,
  200a7c:	79405265 	ldrh	w5, [x19, #40]
    queue->capacity = capacity;
  200a80:	b9001283 	str	w3, [x20, #16]
  200a84:	b9002a85 	str	w5, [x20, #40]
    for (uint32_t i = 0; i < queue->capacity; i++) {
  200a88:	340004a3 	cbz	w3, 200b1c <init+0xec>
  200a8c:	52800013 	mov	w19, #0x0                   	// #0
  200a90:	f90013f5 	str	x21, [sp, #32]
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  200a94:	d2800115 	mov	x21, #0x8                   	// #8
    return queue->free->tail - queue->free->head == queue->capacity;
  200a98:	79400022 	ldrh	w2, [x1]
        net_buff_desc_t buffer = {(NET_BUFFER_SIZE * i) + base_addr, 0};
  200a9c:	53155265 	lsl	w5, w19, #11
    return queue->free->tail - queue->free->head == queue->capacity;
  200aa0:	79400420 	ldrh	w0, [x1, #2]
    queue->free->tail++;
  200aa4:	11000444 	add	w4, w2, #0x1
    return queue->free->tail - queue->free->head == queue->capacity;
  200aa8:	4b000040 	sub	w0, w2, w0
    if (net_queue_full_free(queue)) {
  200aac:	6b00007f 	cmp	w3, w0
  200ab0:	540001a0 	b.eq	200ae4 <init+0xb4>  // b.none
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  200ab4:	1ac30840 	udiv	w0, w2, w3
    for (uint32_t i = 0; i < queue->capacity; i++) {
  200ab8:	11000673 	add	w19, w19, #0x1
  200abc:	6b13007f 	cmp	w3, w19
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  200ac0:	1b038800 	msub	w0, w0, w3, w2
  200ac4:	8b2052a0 	add	x0, x21, w0, uxtw #4
  200ac8:	8b000022 	add	x2, x1, x0
  200acc:	f8206825 	str	x5, [x1, x0]
  200ad0:	7900105f 	strh	wzr, [x2, #8]
    queue->free->tail++;
  200ad4:	79000024 	strh	w4, [x1]
    for (uint32_t i = 0; i < queue->capacity; i++) {
  200ad8:	54000209 	b.ls	200b18 <init+0xe8>  // b.plast
    return queue->free->tail - queue->free->head == queue->capacity;
  200adc:	f9400281 	ldr	x1, [x20]
  200ae0:	17ffffee 	b	200a98 <init+0x68>
        assert(!err);
  200ae4:	d0000003 	adrp	x3, 202000 <_vsnprintf+0x150>
  200ae8:	913da063 	add	x3, x3, #0xf68
  200aec:	9100c063 	add	x3, x3, #0x30
  200af0:	f0000001 	adrp	x1, 203000 <__FUNCTION__.0+0x68>
  200af4:	f0000000 	adrp	x0, 203000 <__FUNCTION__.0+0x68>
  200af8:	91044021 	add	x1, x1, #0x110
  200afc:	91036000 	add	x0, x0, #0xd8
  200b00:	52801ba2 	mov	w2, #0xdd                  	// #221
  200b04:	940008f7 	bl	202ee0 <_assert_fail>
    for (uint32_t i = 0; i < queue->capacity; i++) {
  200b08:	11000673 	add	w19, w19, #0x1
  200b0c:	b9401283 	ldr	w3, [x20, #16]
  200b10:	6b03027f 	cmp	w19, w3
  200b14:	54fffe43 	b.cc	200adc <init+0xac>  // b.lo, b.ul, b.last
  200b18:	f94013f5 	ldr	x21, [sp, #32]
                   net_config.tx.num_buffers);
    net_buffers_init(&virt_tx_queue, 0);
    arp_queue_handle_t *arp_queue_pointer = (arp_queue_handle_t *) arp_config.router.arp_queue.vaddr;
  200b1c:	90000033 	adrp	x19, 204000 <__sel4_ipc_buffer>
  200b20:	91002273 	add	x19, x19, #0x8
    arp_query = *arp_queue_pointer;
  200b24:	d2860182 	mov	x2, #0x300c                	// #12300
  200b28:	90000020 	adrp	x0, 204000 <__sel4_ipc_buffer>
  200b2c:	9103c000 	add	x0, x0, #0xf0
  200b30:	f9400661 	ldr	x1, [x19, #8]
  200b34:	940000f3 	bl	200f00 <memcpy>
    /* This hashtable will have been initialised by the router component. */
    hashtable_t *arp_table_vaddr = (hashtable_t*) arp_config.router.arp_cache.vaddr;
    arp_table = *arp_table_vaddr;
  200b38:	f9400e61 	ldr	x1, [x19, #24]
  200b3c:	d2868002 	mov	x2, #0x3400                	// #13312
  200b40:	f0000020 	adrp	x0, 207000 <__global_pointer$+0x27f8>
  200b44:	910b0000 	add	x0, x0, #0x2c0
  200b48:	940000ee 	bl	200f00 <memcpy>
}
  200b4c:	a94153f3 	ldp	x19, x20, [sp, #16]
  200b50:	a8c37bfd 	ldp	x29, x30, [sp], #48
  200b54:	d65f03c0 	ret
  200b58:	d503201f 	nop
  200b5c:	d503201f 	nop

0000000000200b60 <notified>:
{
    // @kwinter: Get the appropriate channel number for the router
    if (0) {
        process_requests();
    } if (1) {
        process_responses();
  200b60:	17ffff2c 	b	200810 <process_responses>
	...

0000000000200b70 <protected>:
  200b70:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  200b74:	d0000040 	adrp	x0, 20a000 <arp_table+0x2d40>
  200b78:	911b0000 	add	x0, x0, #0x6c0
  200b7c:	910003fd 	mov	x29, sp
  200b80:	94000078 	bl	200d60 <microkit_dbg_puts>
  200b84:	f0000000 	adrp	x0, 203000 <__FUNCTION__.0+0x68>
  200b88:	91054000 	add	x0, x0, #0x150
  200b8c:	94000075 	bl	200d60 <microkit_dbg_puts>
  200b90:	d2800000 	mov	x0, #0x0                   	// #0
  200b94:	b900001f 	str	wzr, [x0]
  200b98:	d4207d00 	brk	#0x3e8
  200b9c:	d503201f 	nop

0000000000200ba0 <fault>:
  200ba0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  200ba4:	d0000040 	adrp	x0, 20a000 <arp_table+0x2d40>
  200ba8:	911b0000 	add	x0, x0, #0x6c0
  200bac:	910003fd 	mov	x29, sp
  200bb0:	9400006c 	bl	200d60 <microkit_dbg_puts>
  200bb4:	f0000000 	adrp	x0, 203000 <__FUNCTION__.0+0x68>
  200bb8:	91060000 	add	x0, x0, #0x180
  200bbc:	94000069 	bl	200d60 <microkit_dbg_puts>
  200bc0:	d2800000 	mov	x0, #0x0                   	// #0
  200bc4:	b900001f 	str	wzr, [x0]
  200bc8:	d4207d00 	brk	#0x3e8
  200bcc:	00000000 	udf	#0

0000000000200bd0 <main>:
  200bd0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  200bd4:	90000020 	adrp	x0, 204000 <__sel4_ipc_buffer>
  200bd8:	91000000 	add	x0, x0, #0x0
  200bdc:	910003fd 	mov	x29, sp
  200be0:	a90153f3 	stp	x19, x20, [sp, #16]
  200be4:	90000034 	adrp	x20, 204000 <__sel4_ipc_buffer>
  200be8:	91000294 	add	x20, x20, #0x0
  200bec:	a9025bf5 	stp	x21, x22, [sp, #32]
  200bf0:	eb140015 	subs	x21, x0, x20
  200bf4:	54000100 	b.eq	200c14 <main+0x44>  // b.none
  200bf8:	9343feb5 	asr	x21, x21, #3
  200bfc:	d2800013 	mov	x19, #0x0                   	// #0
  200c00:	f8737a80 	ldr	x0, [x20, x19, lsl #3]
  200c04:	91000673 	add	x19, x19, #0x1
  200c08:	d63f0000 	blr	x0
  200c0c:	eb1302bf 	cmp	x21, x19
  200c10:	54ffff88 	b.hi	200c00 <main+0x30>  // b.pmore
  200c14:	d0000056 	adrp	x22, 20a000 <arp_table+0x2d40>
  200c18:	911b02d6 	add	x22, x22, #0x6c0
  200c1c:	97ffff85 	bl	200a30 <init>
  200c20:	394102c0 	ldrb	w0, [x22, #64]
  200c24:	340000a0 	cbz	w0, 200c38 <main+0x68>
  200c28:	52800021 	mov	w1, #0x1                   	// #1
  200c2c:	d28000a0 	mov	x0, #0x5                   	// #5
  200c30:	390106c1 	strb	w1, [x22, #65]
  200c34:	a90482df 	stp	xzr, x0, [x22, #72]
  200c38:	90000035 	adrp	x21, 204000 <__sel4_ipc_buffer>
  200c3c:	910002b5 	add	x21, x21, #0x0
  200c40:	52800000 	mov	w0, #0x0                   	// #0
  200c44:	d503201f 	nop
  200c48:	35000220 	cbnz	w0, 200c8c <main+0xbc>
  200c4c:	39c106c0 	ldrsb	w0, [x22, #65]
  200c50:	350004e0 	cbnz	w0, 200cec <main+0x11c>
  200c54:	d2800020 	mov	x0, #0x1                   	// #1
  200c58:	d2800086 	mov	x6, #0x4                   	// #4
  200c5c:	928000c7 	mov	x7, #0xfffffffffffffff9    	// #-7
  200c60:	d4000001 	svc	#0x0
  200c64:	f94002a6 	ldr	x6, [x21]
  200c68:	aa0003f3 	mov	x19, x0
  200c6c:	a9008cc2 	stp	x2, x3, [x6, #8]
  200c70:	a90194c4 	stp	x4, x5, [x6, #24]
  200c74:	b7f00313 	tbnz	x19, #62, 200cd4 <main+0x104>
  200c78:	52800014 	mov	w20, #0x0                   	// #0
  200c7c:	b6f801b3 	tbz	x19, #63, 200cb0 <main+0xe0>
  200c80:	12001660 	and	w0, w19, #0x3f
  200c84:	97ffffbb 	bl	200b70 <protected>
  200c88:	f9001fe0 	str	x0, [sp, #56]
  200c8c:	f94002a5 	ldr	x5, [x21]
  200c90:	d2800020 	mov	x0, #0x1                   	// #1
  200c94:	f9401fe1 	ldr	x1, [sp, #56]
  200c98:	d2800086 	mov	x6, #0x4                   	// #4
  200c9c:	a9408ca2 	ldp	x2, x3, [x5, #8]
  200ca0:	92800027 	mov	x7, #0xfffffffffffffffe    	// #-2
  200ca4:	a94194a4 	ldp	x4, x5, [x5, #24]
  200ca8:	d4000001 	svc	#0x0
  200cac:	17ffffee 	b	200c64 <main+0x94>
  200cb0:	370000d3 	tbnz	w19, #0, 200cc8 <main+0xf8>
  200cb4:	d503201f 	nop
  200cb8:	d341fe73 	lsr	x19, x19, #1
  200cbc:	11000694 	add	w20, w20, #0x1
  200cc0:	b4fffc73 	cbz	x19, 200c4c <main+0x7c>
  200cc4:	3607ffb3 	tbz	w19, #0, 200cb8 <main+0xe8>
  200cc8:	2a1403e0 	mov	w0, w20
  200ccc:	97ffffa5 	bl	200b60 <notified>
  200cd0:	17fffffa 	b	200cb8 <main+0xe8>
  200cd4:	12001e60 	and	w0, w19, #0xff
  200cd8:	9100e3e2 	add	x2, sp, #0x38
  200cdc:	97ffffb1 	bl	200ba0 <fault>
  200ce0:	72001c1f 	tst	w0, #0xff
  200ce4:	1a9f07e0 	cset	w0, ne	// ne = any
  200ce8:	17ffffd8 	b	200c48 <main+0x78>
  200cec:	f94002a5 	ldr	x5, [x21]
  200cf0:	d2800020 	mov	x0, #0x1                   	// #1
  200cf4:	a944a2c1 	ldp	x1, x8, [x22, #72]
  200cf8:	d2800086 	mov	x6, #0x4                   	// #4
  200cfc:	a9408ca2 	ldp	x2, x3, [x5, #8]
  200d00:	92800047 	mov	x7, #0xfffffffffffffffd    	// #-3
  200d04:	a94194a4 	ldp	x4, x5, [x5, #24]
  200d08:	d4000001 	svc	#0x0
  200d0c:	f94002a6 	ldr	x6, [x21]
  200d10:	aa0003f3 	mov	x19, x0
  200d14:	390106df 	strb	wzr, [x22, #65]
  200d18:	a9008cc2 	stp	x2, x3, [x6, #8]
  200d1c:	a90194c4 	stp	x4, x5, [x6, #24]
  200d20:	17ffffd5 	b	200c74 <main+0xa4>
	...

0000000000200d30 <microkit_dbg_putc>:
  200d30:	d2800001 	mov	x1, #0x0                   	// #0
  200d34:	92401c00 	and	x0, x0, #0xff
  200d38:	d2800002 	mov	x2, #0x0                   	// #0
  200d3c:	d2800003 	mov	x3, #0x0                   	// #0
  200d40:	d2800004 	mov	x4, #0x0                   	// #0
  200d44:	d2800005 	mov	x5, #0x0                   	// #0
  200d48:	d2800006 	mov	x6, #0x0                   	// #0
  200d4c:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  200d50:	d4000001 	svc	#0x0
  200d54:	d65f03c0 	ret
  200d58:	d503201f 	nop
  200d5c:	d503201f 	nop

0000000000200d60 <microkit_dbg_puts>:
  200d60:	aa0003e8 	mov	x8, x0
  200d64:	39400000 	ldrb	w0, [x0]
  200d68:	34000180 	cbz	w0, 200d98 <microkit_dbg_puts+0x38>
  200d6c:	d503201f 	nop
  200d70:	d2800001 	mov	x1, #0x0                   	// #0
  200d74:	d2800002 	mov	x2, #0x0                   	// #0
  200d78:	d2800003 	mov	x3, #0x0                   	// #0
  200d7c:	d2800004 	mov	x4, #0x0                   	// #0
  200d80:	d2800005 	mov	x5, #0x0                   	// #0
  200d84:	d2800006 	mov	x6, #0x0                   	// #0
  200d88:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  200d8c:	d4000001 	svc	#0x0
  200d90:	38401d00 	ldrb	w0, [x8, #1]!
  200d94:	35fffee0 	cbnz	w0, 200d70 <microkit_dbg_puts+0x10>
  200d98:	d65f03c0 	ret
  200d9c:	d503201f 	nop

0000000000200da0 <__assert_fail>:
  200da0:	f000000b 	adrp	x11, 203000 <__FUNCTION__.0+0x68>
  200da4:	9106a16b 	add	x11, x11, #0x1a8
  200da8:	aa0103e9 	mov	x9, x1
  200dac:	aa0303e8 	mov	x8, x3
  200db0:	aa0003ea 	mov	x10, x0
  200db4:	d2800c20 	mov	x0, #0x61                  	// #97
  200db8:	d2800001 	mov	x1, #0x0                   	// #0
  200dbc:	d2800002 	mov	x2, #0x0                   	// #0
  200dc0:	d2800003 	mov	x3, #0x0                   	// #0
  200dc4:	d2800004 	mov	x4, #0x0                   	// #0
  200dc8:	d2800005 	mov	x5, #0x0                   	// #0
  200dcc:	d2800006 	mov	x6, #0x0                   	// #0
  200dd0:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  200dd4:	d4000001 	svc	#0x0
  200dd8:	38401d60 	ldrb	w0, [x11, #1]!
  200ddc:	35fffee0 	cbnz	w0, 200db8 <__assert_fail+0x18>
  200de0:	39400140 	ldrb	w0, [x10]
  200de4:	34000160 	cbz	w0, 200e10 <__assert_fail+0x70>
  200de8:	d2800001 	mov	x1, #0x0                   	// #0
  200dec:	d2800002 	mov	x2, #0x0                   	// #0
  200df0:	d2800003 	mov	x3, #0x0                   	// #0
  200df4:	d2800004 	mov	x4, #0x0                   	// #0
  200df8:	d2800005 	mov	x5, #0x0                   	// #0
  200dfc:	d2800006 	mov	x6, #0x0                   	// #0
  200e00:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  200e04:	d4000001 	svc	#0x0
  200e08:	38401d40 	ldrb	w0, [x10, #1]!
  200e0c:	35fffee0 	cbnz	w0, 200de8 <__assert_fail+0x48>
  200e10:	d2800400 	mov	x0, #0x20                  	// #32
  200e14:	d2800001 	mov	x1, #0x0                   	// #0
  200e18:	d2800002 	mov	x2, #0x0                   	// #0
  200e1c:	d2800003 	mov	x3, #0x0                   	// #0
  200e20:	d2800004 	mov	x4, #0x0                   	// #0
  200e24:	d2800005 	mov	x5, #0x0                   	// #0
  200e28:	d2800006 	mov	x6, #0x0                   	// #0
  200e2c:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  200e30:	d4000001 	svc	#0x0
  200e34:	39400120 	ldrb	w0, [x9]
  200e38:	34000180 	cbz	w0, 200e68 <__assert_fail+0xc8>
  200e3c:	d503201f 	nop
  200e40:	d2800001 	mov	x1, #0x0                   	// #0
  200e44:	d2800002 	mov	x2, #0x0                   	// #0
  200e48:	d2800003 	mov	x3, #0x0                   	// #0
  200e4c:	d2800004 	mov	x4, #0x0                   	// #0
  200e50:	d2800005 	mov	x5, #0x0                   	// #0
  200e54:	d2800006 	mov	x6, #0x0                   	// #0
  200e58:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  200e5c:	d4000001 	svc	#0x0
  200e60:	38401d20 	ldrb	w0, [x9, #1]!
  200e64:	35fffee0 	cbnz	w0, 200e40 <__assert_fail+0xa0>
  200e68:	d2800400 	mov	x0, #0x20                  	// #32
  200e6c:	d2800001 	mov	x1, #0x0                   	// #0
  200e70:	d2800002 	mov	x2, #0x0                   	// #0
  200e74:	d2800003 	mov	x3, #0x0                   	// #0
  200e78:	d2800004 	mov	x4, #0x0                   	// #0
  200e7c:	d2800005 	mov	x5, #0x0                   	// #0
  200e80:	d2800006 	mov	x6, #0x0                   	// #0
  200e84:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  200e88:	d4000001 	svc	#0x0
  200e8c:	39400100 	ldrb	w0, [x8]
  200e90:	34000180 	cbz	w0, 200ec0 <__assert_fail+0x120>
  200e94:	d503201f 	nop
  200e98:	d2800001 	mov	x1, #0x0                   	// #0
  200e9c:	d2800002 	mov	x2, #0x0                   	// #0
  200ea0:	d2800003 	mov	x3, #0x0                   	// #0
  200ea4:	d2800004 	mov	x4, #0x0                   	// #0
  200ea8:	d2800005 	mov	x5, #0x0                   	// #0
  200eac:	d2800006 	mov	x6, #0x0                   	// #0
  200eb0:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  200eb4:	d4000001 	svc	#0x0
  200eb8:	38401d00 	ldrb	w0, [x8, #1]!
  200ebc:	35fffee0 	cbnz	w0, 200e98 <__assert_fail+0xf8>
  200ec0:	d2800140 	mov	x0, #0xa                   	// #10
  200ec4:	d2800001 	mov	x1, #0x0                   	// #0
  200ec8:	d2800002 	mov	x2, #0x0                   	// #0
  200ecc:	d2800003 	mov	x3, #0x0                   	// #0
  200ed0:	d2800004 	mov	x4, #0x0                   	// #0
  200ed4:	d2800005 	mov	x5, #0x0                   	// #0
  200ed8:	d2800006 	mov	x6, #0x0                   	// #0
  200edc:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  200ee0:	d4000001 	svc	#0x0
  200ee4:	d65f03c0 	ret
	...

0000000000200f00 <memcpy>:
  200f00:	f9800020 	prfm	pldl1keep, [x1]
  200f04:	8b020024 	add	x4, x1, x2
  200f08:	8b020005 	add	x5, x0, x2
  200f0c:	f100405f 	cmp	x2, #0x10
  200f10:	54000209 	b.ls	200f50 <memcpy+0x50>  // b.plast
  200f14:	f101805f 	cmp	x2, #0x60
  200f18:	54000648 	b.hi	200fe0 <memcpy+0xe0>  // b.pmore
  200f1c:	d1000449 	sub	x9, x2, #0x1
  200f20:	a9401c26 	ldp	x6, x7, [x1]
  200f24:	37300469 	tbnz	w9, #6, 200fb0 <memcpy+0xb0>
  200f28:	a97f348c 	ldp	x12, x13, [x4, #-16]
  200f2c:	362800a9 	tbz	w9, #5, 200f40 <memcpy+0x40>
  200f30:	a9412428 	ldp	x8, x9, [x1, #16]
  200f34:	a97e2c8a 	ldp	x10, x11, [x4, #-32]
  200f38:	a9012408 	stp	x8, x9, [x0, #16]
  200f3c:	a93e2caa 	stp	x10, x11, [x5, #-32]
  200f40:	a9001c06 	stp	x6, x7, [x0]
  200f44:	a93f34ac 	stp	x12, x13, [x5, #-16]
  200f48:	d65f03c0 	ret
  200f4c:	d503201f 	nop
  200f50:	f100205f 	cmp	x2, #0x8
  200f54:	540000e3 	b.cc	200f70 <memcpy+0x70>  // b.lo, b.ul, b.last
  200f58:	f9400026 	ldr	x6, [x1]
  200f5c:	f85f8087 	ldur	x7, [x4, #-8]
  200f60:	f9000006 	str	x6, [x0]
  200f64:	f81f80a7 	stur	x7, [x5, #-8]
  200f68:	d65f03c0 	ret
  200f6c:	d503201f 	nop
  200f70:	361000c2 	tbz	w2, #2, 200f88 <memcpy+0x88>
  200f74:	b9400026 	ldr	w6, [x1]
  200f78:	b85fc087 	ldur	w7, [x4, #-4]
  200f7c:	b9000006 	str	w6, [x0]
  200f80:	b81fc0a7 	stur	w7, [x5, #-4]
  200f84:	d65f03c0 	ret
  200f88:	b4000102 	cbz	x2, 200fa8 <memcpy+0xa8>
  200f8c:	d341fc49 	lsr	x9, x2, #1
  200f90:	39400026 	ldrb	w6, [x1]
  200f94:	385ff087 	ldurb	w7, [x4, #-1]
  200f98:	38696828 	ldrb	w8, [x1, x9]
  200f9c:	39000006 	strb	w6, [x0]
  200fa0:	38296808 	strb	w8, [x0, x9]
  200fa4:	381ff0a7 	sturb	w7, [x5, #-1]
  200fa8:	d65f03c0 	ret
  200fac:	d503201f 	nop
  200fb0:	a9412428 	ldp	x8, x9, [x1, #16]
  200fb4:	a9422c2a 	ldp	x10, x11, [x1, #32]
  200fb8:	a943342c 	ldp	x12, x13, [x1, #48]
  200fbc:	a97e0881 	ldp	x1, x2, [x4, #-32]
  200fc0:	a97f0c84 	ldp	x4, x3, [x4, #-16]
  200fc4:	a9001c06 	stp	x6, x7, [x0]
  200fc8:	a9012408 	stp	x8, x9, [x0, #16]
  200fcc:	a9022c0a 	stp	x10, x11, [x0, #32]
  200fd0:	a903340c 	stp	x12, x13, [x0, #48]
  200fd4:	a93e08a1 	stp	x1, x2, [x5, #-32]
  200fd8:	a93f0ca4 	stp	x4, x3, [x5, #-16]
  200fdc:	d65f03c0 	ret
  200fe0:	92400c09 	and	x9, x0, #0xf
  200fe4:	927cec03 	and	x3, x0, #0xfffffffffffffff0
  200fe8:	a940342c 	ldp	x12, x13, [x1]
  200fec:	cb090021 	sub	x1, x1, x9
  200ff0:	8b090042 	add	x2, x2, x9
  200ff4:	a9411c26 	ldp	x6, x7, [x1, #16]
  200ff8:	a900340c 	stp	x12, x13, [x0]
  200ffc:	a9422428 	ldp	x8, x9, [x1, #32]
  201000:	a9432c2a 	ldp	x10, x11, [x1, #48]
  201004:	a9c4342c 	ldp	x12, x13, [x1, #64]!
  201008:	f1024042 	subs	x2, x2, #0x90
  20100c:	54000169 	b.ls	201038 <memcpy+0x138>  // b.plast
  201010:	a9011c66 	stp	x6, x7, [x3, #16]
  201014:	a9411c26 	ldp	x6, x7, [x1, #16]
  201018:	a9022468 	stp	x8, x9, [x3, #32]
  20101c:	a9422428 	ldp	x8, x9, [x1, #32]
  201020:	a9032c6a 	stp	x10, x11, [x3, #48]
  201024:	a9432c2a 	ldp	x10, x11, [x1, #48]
  201028:	a984346c 	stp	x12, x13, [x3, #64]!
  20102c:	a9c4342c 	ldp	x12, x13, [x1, #64]!
  201030:	f1010042 	subs	x2, x2, #0x40
  201034:	54fffee8 	b.hi	201010 <memcpy+0x110>  // b.pmore
  201038:	a97c0881 	ldp	x1, x2, [x4, #-64]
  20103c:	a9011c66 	stp	x6, x7, [x3, #16]
  201040:	a97d1c86 	ldp	x6, x7, [x4, #-48]
  201044:	a9022468 	stp	x8, x9, [x3, #32]
  201048:	a97e2488 	ldp	x8, x9, [x4, #-32]
  20104c:	a9032c6a 	stp	x10, x11, [x3, #48]
  201050:	a97f2c8a 	ldp	x10, x11, [x4, #-16]
  201054:	a904346c 	stp	x12, x13, [x3, #64]
  201058:	a93c08a1 	stp	x1, x2, [x5, #-64]
  20105c:	a93d1ca6 	stp	x6, x7, [x5, #-48]
  201060:	a93e24a8 	stp	x8, x9, [x5, #-32]
  201064:	a93f2caa 	stp	x10, x11, [x5, #-16]
  201068:	d65f03c0 	ret
	...

0000000000201080 <memset>:
  201080:	4e010c20 	dup	v0.16b, w1
  201084:	8b020004 	add	x4, x0, x2
  201088:	f101805f 	cmp	x2, #0x60
  20108c:	540003c8 	b.hi	201104 <memset+0x84>  // b.pmore
  201090:	f100405f 	cmp	x2, #0x10
  201094:	54000202 	b.cs	2010d4 <memset+0x54>  // b.hs, b.nlast
  201098:	4e083c01 	mov	x1, v0.d[0]
  20109c:	361800a2 	tbz	w2, #3, 2010b0 <memset+0x30>
  2010a0:	f9000001 	str	x1, [x0]
  2010a4:	f81f8081 	stur	x1, [x4, #-8]
  2010a8:	d65f03c0 	ret
  2010ac:	d503201f 	nop
  2010b0:	36100082 	tbz	w2, #2, 2010c0 <memset+0x40>
  2010b4:	b9000001 	str	w1, [x0]
  2010b8:	b81fc081 	stur	w1, [x4, #-4]
  2010bc:	d65f03c0 	ret
  2010c0:	b4000082 	cbz	x2, 2010d0 <memset+0x50>
  2010c4:	39000001 	strb	w1, [x0]
  2010c8:	36080042 	tbz	w2, #1, 2010d0 <memset+0x50>
  2010cc:	781fe081 	sturh	w1, [x4, #-2]
  2010d0:	d65f03c0 	ret
  2010d4:	3d800000 	str	q0, [x0]
  2010d8:	373000c2 	tbnz	w2, #6, 2010f0 <memset+0x70>
  2010dc:	3c9f0080 	stur	q0, [x4, #-16]
  2010e0:	36280062 	tbz	w2, #5, 2010ec <memset+0x6c>
  2010e4:	3d800400 	str	q0, [x0, #16]
  2010e8:	3c9e0080 	stur	q0, [x4, #-32]
  2010ec:	d65f03c0 	ret
  2010f0:	3d800400 	str	q0, [x0, #16]
  2010f4:	ad010000 	stp	q0, q0, [x0, #32]
  2010f8:	ad3f0080 	stp	q0, q0, [x4, #-32]
  2010fc:	d65f03c0 	ret
  201100:	d503201f 	nop
  201104:	12001c21 	and	w1, w1, #0xff
  201108:	927cec03 	and	x3, x0, #0xfffffffffffffff0
  20110c:	3d800000 	str	q0, [x0]
  201110:	f104005f 	cmp	x2, #0x100
  201114:	7a402820 	ccmp	w1, #0x0, #0x0, cs	// cs = hs, nlast
  201118:	54000180 	b.eq	201148 <memset+0xc8>  // b.none
  20111c:	cb030082 	sub	x2, x4, x3
  201120:	d1004063 	sub	x3, x3, #0x10
  201124:	d1014042 	sub	x2, x2, #0x50
  201128:	ad010060 	stp	q0, q0, [x3, #32]
  20112c:	ad820060 	stp	q0, q0, [x3, #64]!
  201130:	f1010042 	subs	x2, x2, #0x40
  201134:	54ffffa8 	b.hi	201128 <memset+0xa8>  // b.pmore
  201138:	ad3e0080 	stp	q0, q0, [x4, #-64]
  20113c:	ad3f0080 	stp	q0, q0, [x4, #-32]
  201140:	d65f03c0 	ret
  201144:	d503201f 	nop
  201148:	d53b00e5 	mrs	x5, dczid_el0
  20114c:	3727fe85 	tbnz	w5, #4, 20111c <memset+0x9c>
  201150:	12000ca5 	and	w5, w5, #0xf
  201154:	710010bf 	cmp	w5, #0x4
  201158:	54000281 	b.ne	2011a8 <memset+0x128>  // b.any
  20115c:	3d800460 	str	q0, [x3, #16]
  201160:	ad010060 	stp	q0, q0, [x3, #32]
  201164:	927ae463 	and	x3, x3, #0xffffffffffffffc0
  201168:	ad020060 	stp	q0, q0, [x3, #64]
  20116c:	ad030060 	stp	q0, q0, [x3, #96]
  201170:	cb030082 	sub	x2, x4, x3
  201174:	d1040042 	sub	x2, x2, #0x100
  201178:	91020063 	add	x3, x3, #0x80
  20117c:	d503201f 	nop
  201180:	d50b7423 	dc	zva, x3
  201184:	91010063 	add	x3, x3, #0x40
  201188:	f1010042 	subs	x2, x2, #0x40
  20118c:	54ffffa8 	b.hi	201180 <memset+0x100>  // b.pmore
  201190:	ad000060 	stp	q0, q0, [x3]
  201194:	ad010060 	stp	q0, q0, [x3, #32]
  201198:	ad3e0080 	stp	q0, q0, [x4, #-64]
  20119c:	ad3f0080 	stp	q0, q0, [x4, #-32]
  2011a0:	d65f03c0 	ret
  2011a4:	d503201f 	nop
  2011a8:	710014bf 	cmp	w5, #0x5
  2011ac:	54000241 	b.ne	2011f4 <memset+0x174>  // b.any
  2011b0:	3d800460 	str	q0, [x3, #16]
  2011b4:	ad010060 	stp	q0, q0, [x3, #32]
  2011b8:	ad020060 	stp	q0, q0, [x3, #64]
  2011bc:	ad030060 	stp	q0, q0, [x3, #96]
  2011c0:	9279e063 	and	x3, x3, #0xffffffffffffff80
  2011c4:	cb030082 	sub	x2, x4, x3
  2011c8:	d1040042 	sub	x2, x2, #0x100
  2011cc:	91020063 	add	x3, x3, #0x80
  2011d0:	d50b7423 	dc	zva, x3
  2011d4:	91020063 	add	x3, x3, #0x80
  2011d8:	f1020042 	subs	x2, x2, #0x80
  2011dc:	54ffffa8 	b.hi	2011d0 <memset+0x150>  // b.pmore
  2011e0:	ad3c0080 	stp	q0, q0, [x4, #-128]
  2011e4:	ad3d0080 	stp	q0, q0, [x4, #-96]
  2011e8:	ad3e0080 	stp	q0, q0, [x4, #-64]
  2011ec:	ad3f0080 	stp	q0, q0, [x4, #-32]
  2011f0:	d65f03c0 	ret
  2011f4:	52800086 	mov	w6, #0x4                   	// #4
  2011f8:	1ac520c7 	lsl	w7, w6, w5
  2011fc:	910100e5 	add	x5, x7, #0x40
  201200:	eb05005f 	cmp	x2, x5
  201204:	54fff8c3 	b.cc	20111c <memset+0x9c>  // b.lo, b.ul, b.last
  201208:	d10004e6 	sub	x6, x7, #0x1
  20120c:	8b070065 	add	x5, x3, x7
  201210:	91004063 	add	x3, x3, #0x10
  201214:	eb0300a2 	subs	x2, x5, x3
  201218:	8a2600a5 	bic	x5, x5, x6
  20121c:	540000a0 	b.eq	201230 <memset+0x1b0>  // b.none
  201220:	ac820060 	stp	q0, q0, [x3], #64
  201224:	ad3f0060 	stp	q0, q0, [x3, #-32]
  201228:	f1010042 	subs	x2, x2, #0x40
  20122c:	54ffffa8 	b.hi	201220 <memset+0x1a0>  // b.pmore
  201230:	aa0503e3 	mov	x3, x5
  201234:	cb050082 	sub	x2, x4, x5
  201238:	eb070042 	subs	x2, x2, x7
  20123c:	540000a3 	b.cc	201250 <memset+0x1d0>  // b.lo, b.ul, b.last
  201240:	d50b7423 	dc	zva, x3
  201244:	8b070063 	add	x3, x3, x7
  201248:	eb070042 	subs	x2, x2, x7
  20124c:	54ffffa2 	b.cs	201240 <memset+0x1c0>  // b.hs, b.nlast
  201250:	8b070042 	add	x2, x2, x7
  201254:	d1008063 	sub	x3, x3, #0x20
  201258:	17ffffb6 	b	201130 <memset+0xb0>
  20125c:	00000000 	udf	#0

0000000000201260 <_out_buffer>:


// internal buffer output
static inline void _out_buffer(char character, void* buffer, size_t idx, size_t maxlen)
{
  if (idx < maxlen) {
  201260:	eb03005f 	cmp	x2, x3
{
  201264:	12001c00 	and	w0, w0, #0xff
  if (idx < maxlen) {
  201268:	54000042 	b.cs	201270 <_out_buffer+0x10>  // b.hs, b.nlast
    ((char*)buffer)[idx] = character;
  20126c:	38226820 	strb	w0, [x1, x2]
  }
}
  201270:	d65f03c0 	ret
  201274:	d503201f 	nop
  201278:	d503201f 	nop
  20127c:	d503201f 	nop

0000000000201280 <_out_null>:

// internal null output
static inline void _out_null(char character, void* buffer, size_t idx, size_t maxlen)
{
  (void)character; (void)buffer; (void)idx; (void)maxlen;
}
  201280:	d65f03c0 	ret
  201284:	d503201f 	nop
  201288:	d503201f 	nop
  20128c:	d503201f 	nop

0000000000201290 <_out_rev>:
}


// output the specified string in reverse, taking care of any zero-padding
static size_t _out_rev(out_fct_type out, char* buffer, size_t idx, size_t maxlen, const char* buf, size_t len, unsigned int width, unsigned int flags)
{
  201290:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  201294:	910003fd 	mov	x29, sp
  201298:	a90153f3 	stp	x19, x20, [sp, #16]
  20129c:	aa0503f3 	mov	x19, x5
  2012a0:	aa0203f4 	mov	x20, x2
  2012a4:	a9025bf5 	stp	x21, x22, [sp, #32]
  2012a8:	aa0003f5 	mov	x21, x0
  2012ac:	aa0103f6 	mov	x22, x1
  2012b0:	a90363f7 	stp	x23, x24, [sp, #48]
  2012b4:	aa0203f8 	mov	x24, x2
  2012b8:	aa0303f7 	mov	x23, x3
  2012bc:	a9046bf9 	stp	x25, x26, [sp, #64]
  2012c0:	aa0403f9 	mov	x25, x4
  2012c4:	2a0603fa 	mov	w26, w6
  2012c8:	a90573fb 	stp	x27, x28, [sp, #80]
  2012cc:	2a0703fb 	mov	w27, w7
  const size_t start_idx = idx;

  // pad spaces up to given width
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
  2012d0:	f240077f 	tst	x27, #0x3
  2012d4:	540001e1 	b.ne	201310 <_out_rev+0x80>  // b.any
    for (size_t i = len; i < width; i++) {
  2012d8:	2a1a03e0 	mov	w0, w26
  2012dc:	aa0203fc 	mov	x28, x2
  2012e0:	cb050014 	sub	x20, x0, x5
  2012e4:	eb0000bf 	cmp	x5, x0
  2012e8:	8b020294 	add	x20, x20, x2
  2012ec:	54000502 	b.cs	20138c <_out_rev+0xfc>  // b.hs, b.nlast
      out(' ', buffer, idx++, maxlen);
  2012f0:	aa1c03e2 	mov	x2, x28
  2012f4:	aa1703e3 	mov	x3, x23
  2012f8:	9100079c 	add	x28, x28, #0x1
  2012fc:	aa1603e1 	mov	x1, x22
  201300:	52800400 	mov	w0, #0x20                  	// #32
  201304:	d63f02a0 	blr	x21
    for (size_t i = len; i < width; i++) {
  201308:	eb1c029f 	cmp	x20, x28
  20130c:	54ffff21 	b.ne	2012f0 <_out_rev+0x60>  // b.any
    }
  }

  // reverse string
  while (len) {
  201310:	8b14027c 	add	x28, x19, x20
  201314:	b4000133 	cbz	x19, 201338 <_out_rev+0xa8>
  201318:	cb130382 	sub	x2, x28, x19
    out(buf[--len], buffer, idx++, maxlen);
  20131c:	d1000673 	sub	x19, x19, #0x1
  201320:	aa1c03f4 	mov	x20, x28
  201324:	aa1703e3 	mov	x3, x23
  201328:	aa1603e1 	mov	x1, x22
  20132c:	38736b20 	ldrb	w0, [x25, x19]
  201330:	d63f02a0 	blr	x21
  while (len) {
  201334:	b5ffff33 	cbnz	x19, 201318 <_out_rev+0x88>
  }

  // append pad spaces up to given width
  if (flags & FLAGS_LEFT) {
  201338:	360801bb 	tbz	w27, #1, 20136c <_out_rev+0xdc>
    while (idx - start_idx < width) {
  20133c:	cb180298 	sub	x24, x20, x24
  201340:	eb1a031f 	cmp	x24, x26
  201344:	54000142 	b.cs	20136c <_out_rev+0xdc>  // b.hs, b.nlast
      out(' ', buffer, idx++, maxlen);
  201348:	aa1403e2 	mov	x2, x20
    while (idx - start_idx < width) {
  20134c:	91000718 	add	x24, x24, #0x1
      out(' ', buffer, idx++, maxlen);
  201350:	aa1703e3 	mov	x3, x23
  201354:	aa1603e1 	mov	x1, x22
  201358:	52800400 	mov	w0, #0x20                  	// #32
  20135c:	d63f02a0 	blr	x21
  201360:	91000694 	add	x20, x20, #0x1
    while (idx - start_idx < width) {
  201364:	eb1a031f 	cmp	x24, x26
  201368:	54ffff03 	b.cc	201348 <_out_rev+0xb8>  // b.lo, b.ul, b.last
    }
  }

  return idx;
}
  20136c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  201370:	aa1403e0 	mov	x0, x20
  201374:	a94153f3 	ldp	x19, x20, [sp, #16]
  201378:	a94363f7 	ldp	x23, x24, [sp, #48]
  20137c:	a9446bf9 	ldp	x25, x26, [sp, #64]
  201380:	a94573fb 	ldp	x27, x28, [sp, #80]
  201384:	a8c67bfd 	ldp	x29, x30, [sp], #96
  201388:	d65f03c0 	ret
    for (size_t i = len; i < width; i++) {
  20138c:	aa0203f4 	mov	x20, x2
  201390:	17ffffe0 	b	201310 <_out_rev+0x80>
  201394:	d503201f 	nop
  201398:	d503201f 	nop
  20139c:	d503201f 	nop

00000000002013a0 <_ntoa_long>:
}


// internal itoa for 'long' type
static size_t _ntoa_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long value, bool negative, unsigned long base, unsigned int prec, unsigned int width, unsigned int flags)
{
  2013a0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  2013a4:	aa0603eb 	mov	x11, x6
  2013a8:	aa0403ea 	mov	x10, x4
  2013ac:	910003fd 	mov	x29, sp
  2013b0:	b9403be8 	ldr	w8, [sp, #56]
  2013b4:	2a0703ef 	mov	w15, w7
  2013b8:	b94033e6 	ldr	w6, [sp, #48]
  2013bc:	12001cb2 	and	w18, w5, #0xff
  if (!value) {
    flags &= ~FLAGS_HASH;
  }

  // write if precision != 0 and value is != 0
  if (!(flags & FLAGS_PRECISION) || value) {
  2013c0:	12160110 	and	w16, w8, #0x400
  if (!value) {
  2013c4:	b4000764 	cbz	x4, 2014b0 <_ntoa_long+0x110>
  if (flags & FLAGS_HASH) {
  2013c8:	121c0111 	and	w17, w8, #0x10
  2013cc:	2a0803e7 	mov	w7, w8
    do {
      const char digit = (char)(value % base);
  2013d0:	9acb094c 	udiv	x12, x10, x11
  2013d4:	f27b00ff 	tst	x7, #0x20
  2013d8:	52800c24 	mov	w4, #0x61                  	// #97
  2013dc:	5280082d 	mov	w13, #0x41                  	// #65
  2013e0:	1a8411ad 	csel	w13, w13, w4, ne	// ne = any
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  2013e4:	d2800005 	mov	x5, #0x0                   	// #0
  2013e8:	510029ad 	sub	w13, w13, #0xa
  2013ec:	910043e4 	add	x4, sp, #0x10
      const char digit = (char)(value % base);
  2013f0:	9b0ba988 	msub	x8, x12, x11, x10
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  2013f4:	910004a5 	add	x5, x5, #0x1
  2013f8:	f100251f 	cmp	x8, #0x9
      const char digit = (char)(value % base);
  2013fc:	12001d08 	and	w8, w8, #0xff
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  201400:	1100c10e 	add	w14, w8, #0x30
  201404:	0b0d0108 	add	w8, w8, w13
  201408:	54000248 	b.hi	201450 <_ntoa_long+0xb0>  // b.pmore
  20140c:	d503201f 	nop
  201410:	8b050088 	add	x8, x4, x5
      value /= base;
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
  201414:	f1007cbf 	cmp	x5, #0x1f
  201418:	1a9f87e9 	cset	w9, ls	// ls = plast
  20141c:	7100013f 	cmp	w9, #0x0
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  201420:	381ff10e 	sturb	w14, [x8, #-1]
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
  201424:	fa4a1162 	ccmp	x11, x10, #0x2, ne	// ne = any
  201428:	54000228 	b.hi	20146c <_ntoa_long+0xcc>  // b.pmore
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  20142c:	aa0c03ea 	mov	x10, x12
  201430:	910004a5 	add	x5, x5, #0x1
      const char digit = (char)(value % base);
  201434:	9acb094c 	udiv	x12, x10, x11
  201438:	9b0ba988 	msub	x8, x12, x11, x10
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  20143c:	f100251f 	cmp	x8, #0x9
      const char digit = (char)(value % base);
  201440:	12001d08 	and	w8, w8, #0xff
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  201444:	1100c10e 	add	w14, w8, #0x30
  201448:	0b0d0108 	add	w8, w8, w13
  20144c:	54fffe29 	b.ls	201410 <_ntoa_long+0x70>  // b.plast
  201450:	8b05008e 	add	x14, x4, x5
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
  201454:	f1007cbf 	cmp	x5, #0x1f
  201458:	1a9f87e9 	cset	w9, ls	// ls = plast
  20145c:	7100013f 	cmp	w9, #0x0
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  201460:	381ff1c8 	sturb	w8, [x14, #-1]
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
  201464:	fa4a1162 	ccmp	x11, x10, #0x2, ne	// ne = any
  201468:	54fffe29 	b.ls	20142c <_ntoa_long+0x8c>  // b.plast
  if (!(flags & FLAGS_LEFT)) {
  20146c:	36080307 	tbz	w7, #1, 2014cc <_ntoa_long+0x12c>
  if (flags & FLAGS_HASH) {
  201470:	34000771 	cbz	w17, 20155c <_ntoa_long+0x1bc>
    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
  201474:	34000850 	cbz	w16, 20157c <_ntoa_long+0x1dc>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201478:	f100417f 	cmp	x11, #0x10
  20147c:	54000de0 	b.eq	201638 <_ntoa_long+0x298>  // b.none
    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201480:	7100013f 	cmp	w9, #0x0
  201484:	7a421960 	ccmp	w11, #0x2, #0x0, ne	// ne = any
  201488:	540000a1 	b.ne	20149c <_ntoa_long+0xfc>  // b.any
      buf[len++] = 'b';
  20148c:	aa0503e8 	mov	x8, x5
  201490:	910004a5 	add	x5, x5, #0x1
  201494:	52800c49 	mov	w9, #0x62                  	// #98
  201498:	38286889 	strb	w9, [x4, x8]
    if (len < PRINTF_NTOA_BUFFER_SIZE) {
  20149c:	f10080bf 	cmp	x5, #0x20
  2014a0:	54000881 	b.ne	2015b0 <_ntoa_long+0x210>  // b.any
  return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
  2014a4:	97ffff7b 	bl	201290 <_out_rev>
  }

  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
}
  2014a8:	a8c37bfd 	ldp	x29, x30, [sp], #48
  2014ac:	d65f03c0 	ret
    flags &= ~FLAGS_HASH;
  2014b0:	121b7907 	and	w7, w8, #0xffffffef
  if (!(flags & FLAGS_PRECISION) || value) {
  2014b4:	340008d0 	cbz	w16, 2015cc <_ntoa_long+0x22c>
  if (!(flags & FLAGS_LEFT)) {
  2014b8:	121f0111 	and	w17, w8, #0x2
  2014bc:	37080a08 	tbnz	w8, #1, 2015fc <_ntoa_long+0x25c>
  2014c0:	910043e4 	add	x4, sp, #0x10
  size_t len = 0U;
  2014c4:	d2800005 	mov	x5, #0x0                   	// #0
  if (!(flags & FLAGS_LEFT)) {
  2014c8:	52800029 	mov	w9, #0x1                   	// #1
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  2014cc:	2a0f03ea 	mov	w10, w15
    if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
  2014d0:	120000ed 	and	w13, w7, #0x1
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  2014d4:	eb0a00bf 	cmp	x5, x10
  2014d8:	1a9f27e8 	cset	w8, cc	// cc = lo, ul, last
  2014dc:	0a080128 	and	w8, w9, w8
    if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
  2014e0:	340007a6 	cbz	w6, 2015d4 <_ntoa_long+0x234>
  2014e4:	3400088d 	cbz	w13, 2015f4 <_ntoa_long+0x254>
  2014e8:	35000072 	cbnz	w18, 2014f4 <_ntoa_long+0x154>
  2014ec:	721e04ff 	tst	w7, #0xc
  2014f0:	54000040 	b.eq	2014f8 <_ntoa_long+0x158>  // b.none
      width--;
  2014f4:	510004c6 	sub	w6, w6, #0x1
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  2014f8:	34000168 	cbz	w8, 201524 <_ntoa_long+0x184>
      buf[len++] = '0';
  2014fc:	5280060c 	mov	w12, #0x30                  	// #48
  201500:	910004a5 	add	x5, x5, #0x1
  201504:	8b050088 	add	x8, x4, x5
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201508:	f1007cbf 	cmp	x5, #0x1f
  20150c:	1a9f87e9 	cset	w9, ls	// ls = plast
  201510:	7100013f 	cmp	w9, #0x0
      buf[len++] = '0';
  201514:	381ff10c 	sturb	w12, [x8, #-1]
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201518:	fa4a10a2 	ccmp	x5, x10, #0x2, ne	// ne = any
  20151c:	54ffff23 	b.cc	201500 <_ntoa_long+0x160>  // b.lo, b.ul, b.last
    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201520:	34fffa8d 	cbz	w13, 201470 <_ntoa_long+0xd0>
  201524:	7100013f 	cmp	w9, #0x0
  201528:	2a0603ea 	mov	w10, w6
  20152c:	fa451140 	ccmp	x10, x5, #0x0, ne	// ne = any
  201530:	54fffa09 	b.ls	201470 <_ntoa_long+0xd0>  // b.plast
      buf[len++] = '0';
  201534:	5280060c 	mov	w12, #0x30                  	// #48
  201538:	910004a5 	add	x5, x5, #0x1
  20153c:	8b050088 	add	x8, x4, x5
    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201540:	f1007cbf 	cmp	x5, #0x1f
  201544:	1a9f87e9 	cset	w9, ls	// ls = plast
  201548:	7100013f 	cmp	w9, #0x0
      buf[len++] = '0';
  20154c:	381ff10c 	sturb	w12, [x8, #-1]
    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201550:	fa4a10a2 	ccmp	x5, x10, #0x2, ne	// ne = any
  201554:	54ffff23 	b.cc	201538 <_ntoa_long+0x198>  // b.lo, b.ul, b.last
  if (flags & FLAGS_HASH) {
  201558:	35fff8f1 	cbnz	w17, 201474 <_ntoa_long+0xd4>
  if (len < PRINTF_NTOA_BUFFER_SIZE) {
  20155c:	f10080bf 	cmp	x5, #0x20
  201560:	54fffa20 	b.eq	2014a4 <_ntoa_long+0x104>  // b.none
    if (negative) {
  201564:	350003d2 	cbnz	w18, 2015dc <_ntoa_long+0x23c>
    else if (flags & FLAGS_PLUS) {
  201568:	36100787 	tbz	w7, #2, 201658 <_ntoa_long+0x2b8>
      buf[len++] = '+';  // ignore the space if the '+' exists
  20156c:	52800568 	mov	w8, #0x2b                  	// #43
  201570:	38256888 	strb	w8, [x4, x5]
  201574:	910004a5 	add	x5, x5, #0x1
  201578:	17ffffcb 	b	2014a4 <_ntoa_long+0x104>
    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
  20157c:	b4000485 	cbz	x5, 20160c <_ntoa_long+0x26c>
  201580:	eb2f40bf 	cmp	x5, w15, uxtw
  201584:	54000060 	b.eq	201590 <_ntoa_long+0x1f0>  // b.none
  201588:	eb2640bf 	cmp	x5, w6, uxtw
  20158c:	54fff761 	b.ne	201478 <_ntoa_long+0xd8>  // b.any
      if (len && (base == 16U)) {
  201590:	f10004a8 	subs	x8, x5, #0x1
  201594:	7a501960 	ccmp	w11, #0x10, #0x0, ne	// ne = any
  201598:	54000821 	b.ne	20169c <_ntoa_long+0x2fc>  // b.any
        len--;
  20159c:	d10008a9 	sub	x9, x5, #0x2
      buf[len++] = 'x';
  2015a0:	aa0803e5 	mov	x5, x8
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  2015a4:	36280907 	tbz	w7, #5, 2016c4 <_ntoa_long+0x324>
      buf[len++] = 'X';
  2015a8:	52800b08 	mov	w8, #0x58                  	// #88
  2015ac:	38296888 	strb	w8, [x4, x9]
      buf[len++] = '0';
  2015b0:	aa0503e8 	mov	x8, x5
  2015b4:	910004a5 	add	x5, x5, #0x1
  2015b8:	52800609 	mov	w9, #0x30                  	// #48
  2015bc:	38286889 	strb	w9, [x4, x8]
  if (len < PRINTF_NTOA_BUFFER_SIZE) {
  2015c0:	f10080bf 	cmp	x5, #0x20
  2015c4:	54fff700 	b.eq	2014a4 <_ntoa_long+0x104>  // b.none
  2015c8:	17ffffe7 	b	201564 <_ntoa_long+0x1c4>
  if (!(flags & FLAGS_PRECISION) || value) {
  2015cc:	52800011 	mov	w17, #0x0                   	// #0
  2015d0:	17ffff80 	b	2013d0 <_ntoa_long+0x30>
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  2015d4:	35fff948 	cbnz	w8, 2014fc <_ntoa_long+0x15c>
  2015d8:	17ffffd2 	b	201520 <_ntoa_long+0x180>
      buf[len++] = '-';
  2015dc:	528005a8 	mov	w8, #0x2d                  	// #45
  2015e0:	38256888 	strb	w8, [x4, x5]
  2015e4:	910004a5 	add	x5, x5, #0x1
  return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
  2015e8:	97ffff2a 	bl	201290 <_out_rev>
}
  2015ec:	a8c37bfd 	ldp	x29, x30, [sp], #48
  2015f0:	d65f03c0 	ret
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  2015f4:	35fff848 	cbnz	w8, 2014fc <_ntoa_long+0x15c>
  2015f8:	17ffff9e 	b	201470 <_ntoa_long+0xd0>
  2015fc:	910043e4 	add	x4, sp, #0x10
  size_t len = 0U;
  201600:	d2800005 	mov	x5, #0x0                   	// #0
    if (negative) {
  201604:	34fffb32 	cbz	w18, 201568 <_ntoa_long+0x1c8>
  201608:	17fffff5 	b	2015dc <_ntoa_long+0x23c>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  20160c:	f100417f 	cmp	x11, #0x10
  201610:	54000500 	b.eq	2016b0 <_ntoa_long+0x310>  // b.none
    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201614:	f100097f 	cmp	x11, #0x2
  201618:	54000381 	b.ne	201688 <_ntoa_long+0x2e8>  // b.any
  20161c:	52800c48 	mov	w8, #0x62                  	// #98
      buf[len++] = '0';
  201620:	52800609 	mov	w9, #0x30                  	// #48
      buf[len++] = 'x';
  201624:	390043e8 	strb	w8, [sp, #16]
      buf[len++] = '0';
  201628:	390047e9 	strb	w9, [sp, #17]
  20162c:	d2800045 	mov	x5, #0x2                   	// #2
    if (negative) {
  201630:	34fff9d2 	cbz	w18, 201568 <_ntoa_long+0x1c8>
  201634:	17ffffea 	b	2015dc <_ntoa_long+0x23c>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201638:	362801a7 	tbz	w7, #5, 20166c <_ntoa_long+0x2cc>
    else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  20163c:	f10080bf 	cmp	x5, #0x20
  201640:	54fff320 	b.eq	2014a4 <_ntoa_long+0x104>  // b.none
      buf[len++] = 'b';
  201644:	910004a9 	add	x9, x5, #0x1
      buf[len++] = 'X';
  201648:	52800b08 	mov	w8, #0x58                  	// #88
  20164c:	38256888 	strb	w8, [x4, x5]
  201650:	aa0903e5 	mov	x5, x9
  201654:	17ffff92 	b	20149c <_ntoa_long+0xfc>
    else if (flags & FLAGS_SPACE) {
  201658:	361ff267 	tbz	w7, #3, 2014a4 <_ntoa_long+0x104>
      buf[len++] = ' ';
  20165c:	52800408 	mov	w8, #0x20                  	// #32
  201660:	38256888 	strb	w8, [x4, x5]
  201664:	910004a5 	add	x5, x5, #0x1
  201668:	17ffff8f 	b	2014a4 <_ntoa_long+0x104>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  20166c:	f10080bf 	cmp	x5, #0x20
  201670:	54fff1a0 	b.eq	2014a4 <_ntoa_long+0x104>  // b.none
      buf[len++] = 'b';
  201674:	aa0503e8 	mov	x8, x5
  201678:	910004a5 	add	x5, x5, #0x1
      buf[len++] = 'x';
  20167c:	52800f09 	mov	w9, #0x78                  	// #120
  201680:	38286889 	strb	w9, [x4, x8]
  201684:	17ffff86 	b	20149c <_ntoa_long+0xfc>
      buf[len++] = '0';
  201688:	52800608 	mov	w8, #0x30                  	// #48
  20168c:	390043e8 	strb	w8, [sp, #16]
  201690:	d2800025 	mov	x5, #0x1                   	// #1
    if (negative) {
  201694:	34fff6b2 	cbz	w18, 201568 <_ntoa_long+0x1c8>
  201698:	17ffffd1 	b	2015dc <_ntoa_long+0x23c>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  20169c:	f100417f 	cmp	x11, #0x10
  2016a0:	54000180 	b.eq	2016d0 <_ntoa_long+0x330>  // b.none
    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  2016a4:	f100097f 	cmp	x11, #0x2
  2016a8:	54ffef60 	b.eq	201494 <_ntoa_long+0xf4>  // b.none
  2016ac:	17ffffc3 	b	2015b8 <_ntoa_long+0x218>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  2016b0:	f27b00ff 	tst	x7, #0x20
  2016b4:	52800f08 	mov	w8, #0x78                  	// #120
  2016b8:	52800b05 	mov	w5, #0x58                  	// #88
  2016bc:	1a850108 	csel	w8, w8, w5, eq	// eq = none
  2016c0:	17ffffd8 	b	201620 <_ntoa_long+0x280>
      buf[len++] = 'x';
  2016c4:	52800f08 	mov	w8, #0x78                  	// #120
  2016c8:	38296888 	strb	w8, [x4, x9]
    if (len < PRINTF_NTOA_BUFFER_SIZE) {
  2016cc:	17ffffb9 	b	2015b0 <_ntoa_long+0x210>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  2016d0:	362ffd67 	tbz	w7, #5, 20167c <_ntoa_long+0x2dc>
  2016d4:	aa0503e9 	mov	x9, x5
      len--;
  2016d8:	aa0803e5 	mov	x5, x8
  2016dc:	17ffffdb 	b	201648 <_ntoa_long+0x2a8>

00000000002016e0 <_out_char>:
  if (character) {
  2016e0:	72001c00 	ands	w0, w0, #0xff
  2016e4:	54000041 	b.ne	2016ec <_out_char+0xc>  // b.any
}
  2016e8:	d65f03c0 	ret
    _sddf_putchar(character);
  2016ec:	14000609 	b	202f10 <_sddf_putchar>

00000000002016f0 <_out_fct>:
  if (character) {
  2016f0:	72001c00 	ands	w0, w0, #0xff
  2016f4:	54000080 	b.eq	201704 <_out_fct+0x14>  // b.none
    ((out_fct_wrap_type*)buffer)->fct(character, ((out_fct_wrap_type*)buffer)->arg);
  2016f8:	a9400422 	ldp	x2, x1, [x1]
  2016fc:	aa0203f0 	mov	x16, x2
  201700:	d61f0200 	br	x16
}
  201704:	d65f03c0 	ret
  201708:	d503201f 	nop
  20170c:	d503201f 	nop

0000000000201710 <_ftoa>:

  // powers of 10
  static const double pow10[] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };

  // test for special values
  if (value != value)
  201710:	1e602000 	fcmp	d0, d0
{
  201714:	2a0603e7 	mov	w7, w6
  if (value != value)
  201718:	54000fa1 	b.ne	20190c <_ftoa+0x1fc>  // b.any
    return _out_rev(out, buffer, idx, maxlen, "nan", 3, width, flags);
  if (value < -DBL_MAX)
  20171c:	92e00206 	mov	x6, #0xffefffffffffffff    	// #-4503599627370497
  201720:	9e6700c1 	fmov	d1, x6
  201724:	1e612010 	fcmpe	d0, d1
  201728:	54001324 	b.mi	20198c <_ftoa+0x27c>  // b.first
  20172c:	aa0003ef 	mov	x15, x0
    return _out_rev(out, buffer, idx, maxlen, "fni-", 4, width, flags);
  if (value > DBL_MAX)
  201730:	92f00200 	mov	x0, #0x7fefffffffffffff    	// #9218868437227405311
  201734:	9e670001 	fmov	d1, x0
  201738:	aa0103f0 	mov	x16, x1
  20173c:	aa0203f1 	mov	x17, x2
  201740:	aa0303f2 	mov	x18, x3
  201744:	1e612010 	fcmpe	d0, d1
  201748:	54000ccc 	b.gt	2018e0 <_ftoa+0x1d0>
    return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? "fni+" : "fni", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);

  // test for very large values
  // standard printf behavior is to print EVERY whole number digit -- which could be 100s of characters overflowing your buffers == bad
  if ((value > PRINTF_MAX_FLOAT) || (value < -PRINTF_MAX_FLOAT)) {
  20174c:	d2d9aca0 	mov	x0, #0xcd6500000000        	// #225833675390976
  201750:	f2e839a0 	movk	x0, #0x41cd, lsl #48
  201754:	9e670001 	fmov	d1, x0
  201758:	1e612010 	fcmpe	d0, d1
  20175c:	540010cc 	b.gt	201974 <_ftoa+0x264>
  201760:	d2d9aca0 	mov	x0, #0xcd6500000000        	// #225833675390976
  201764:	f2f839a0 	movk	x0, #0xc1cd, lsl #48
  201768:	9e670001 	fmov	d1, x0
  20176c:	1e612010 	fcmpe	d0, d1
  201770:	54001024 	b.mi	201974 <_ftoa+0x264>  // b.first
#endif
  }

  // test for negative
  bool negative = false;
  if (value < 0) {
  201774:	1e602018 	fcmpe	d0, #0.0
{
  201778:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  20177c:	910003fd 	mov	x29, sp
  if (value < 0) {
  201780:	54000e44 	b.mi	201948 <_ftoa+0x238>  // b.first
  bool negative = false;
  201784:	52800003 	mov	w3, #0x0                   	// #0
    negative = true;
    value = 0 - value;
  }

  // set default precision, if not set explicitly
  if (!(flags & FLAGS_PRECISION)) {
  201788:	36500e87 	tbz	w7, #10, 201958 <_ftoa+0x248>
    prec = PRINTF_DEFAULT_FLOAT_PRECISION;
  }
  // limit precision to 9, cause a prec >= 10 can lead to overflow errors
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
  20178c:	7100249f 	cmp	w4, #0x9
  201790:	54001b49 	b.ls	201af8 <_ftoa+0x3e8>  // b.plast
  201794:	910043ec 	add	x12, sp, #0x10
  201798:	d2800008 	mov	x8, #0x0                   	// #0
    buf[len++] = '0';
  20179c:	52800601 	mov	w1, #0x30                  	// #48
  2017a0:	91000508 	add	x8, x8, #0x1
    prec--;
  2017a4:	51000484 	sub	w4, w4, #0x1
    buf[len++] = '0';
  2017a8:	8b080180 	add	x0, x12, x8
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
  2017ac:	f1007d1f 	cmp	x8, #0x1f
  2017b0:	7a499880 	ccmp	w4, #0x9, #0x0, ls	// ls = plast
    buf[len++] = '0';
  2017b4:	381ff001 	sturb	w1, [x0, #-1]
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
  2017b8:	54ffff48 	b.hi	2017a0 <_ftoa+0x90>  // b.pmore
  2017bc:	d2d9aca0 	mov	x0, #0xcd6500000000        	// #225833675390976
  2017c0:	f2e839a0 	movk	x0, #0x41cd, lsl #48
  2017c4:	9e670002 	fmov	d2, x0
  }

  int whole = (int)value;
  2017c8:	1e78000a 	fcvtzs	w10, d0
  double tmp = (value - whole) * pow10[prec];
  unsigned long frac = (unsigned long)tmp;
  diff = tmp - frac;

  if (diff > 0.5) {
  2017cc:	1e6c1003 	fmov	d3, #5.000000000000000000e-01
  double tmp = (value - whole) * pow10[prec];
  2017d0:	1e620141 	scvtf	d1, w10
  2017d4:	1e613801 	fsub	d1, d0, d1
  2017d8:	1e620821 	fmul	d1, d1, d2
  unsigned long frac = (unsigned long)tmp;
  2017dc:	9e79002e 	fcvtzu	x14, d1
  diff = tmp - frac;
  2017e0:	9e6301c4 	ucvtf	d4, x14
  2017e4:	1e643821 	fsub	d1, d1, d4
  if (diff > 0.5) {
  2017e8:	1e632030 	fcmpe	d1, d3
  2017ec:	5400106c 	b.gt	2019f8 <_ftoa+0x2e8>
    if (frac >= pow10[prec]) {
      frac = 0;
      ++whole;
    }
  }
  else if (diff < 0.5) {
  2017f0:	54000084 	b.mi	201800 <_ftoa+0xf0>  // b.first
  }
  else if ((frac == 0U) || (frac & 1U)) {
  2017f4:	b500172e 	cbnz	x14, 201ad8 <_ftoa+0x3c8>
    // if halfway, round up if odd OR if last digit is 0
    ++frac;
  2017f8:	910005ce 	add	x14, x14, #0x1
  2017fc:	d503201f 	nop
  }

  if (prec == 0U) {
  201800:	35000d04 	cbnz	w4, 2019a0 <_ftoa+0x290>
    diff = value - (double)whole;
  201804:	1e620141 	scvtf	d1, w10
    if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
  201808:	1e6c1002 	fmov	d2, #5.000000000000000000e-01
    diff = value - (double)whole;
  20180c:	1e613800 	fsub	d0, d0, d1
    if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
  201810:	1e622010 	fcmpe	d0, d2
  201814:	54001564 	b.mi	201ac0 <_ftoa+0x3b0>  // b.first
      // exactly 0.5 and ODD, then round up
      // 1.5 -> 2, but 2.5 -> 2
      ++whole;
  201818:	12000140 	and	w0, w10, #0x1
  20181c:	0b00014a 	add	w10, w10, w0
    }
  }

  // do whole part, number is reversed
  while (len < PRINTF_FTOA_BUFFER_SIZE) {
    buf[len++] = (char)(48 + (whole % 10));
  201820:	528ccce1 	mov	w1, #0x6667                	// #26215
  201824:	72acccc1 	movk	w1, #0x6666, lsl #16
  201828:	52800142 	mov	w2, #0xa                   	// #10
  20182c:	1400000a 	b	201854 <_ftoa+0x144>
  201830:	9362fd29 	asr	x9, x9, #34
  201834:	91000508 	add	x8, x8, #0x1
  201838:	4b8a7d29 	sub	w9, w9, w10, asr #31
  20183c:	8b080180 	add	x0, x12, x8
  201840:	1b02a92b 	msub	w11, w9, w2, w10
    if (!(whole /= 10)) {
  201844:	2a0903ea 	mov	w10, w9
    buf[len++] = (char)(48 + (whole % 10));
  201848:	1100c169 	add	w9, w11, #0x30
  20184c:	381ff009 	sturb	w9, [x0, #-1]
    if (!(whole /= 10)) {
  201850:	34000e4a 	cbz	w10, 201a18 <_ftoa+0x308>
    buf[len++] = (char)(48 + (whole % 10));
  201854:	9b217d49 	smull	x9, w10, w1
  while (len < PRINTF_FTOA_BUFFER_SIZE) {
  201858:	f100811f 	cmp	x8, #0x20
  20185c:	54fffea1 	b.ne	201830 <_ftoa+0x120>  // b.any
      break;
    }
  }

  // pad leading zeros
  if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
  201860:	120004e0 	and	w0, w7, #0x3
  201864:	7100041f 	cmp	w0, #0x1
  201868:	54000281 	b.ne	2018b8 <_ftoa+0x1a8>  // b.any
    if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
  20186c:	34000265 	cbz	w5, 2018b8 <_ftoa+0x1a8>
  201870:	350013a3 	cbnz	w3, 201ae4 <_ftoa+0x3d4>
  201874:	721e04ff 	tst	w7, #0xc
  201878:	54001361 	b.ne	201ae4 <_ftoa+0x3d4>  // b.any
      width--;
    }
    while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
  20187c:	2a0503e2 	mov	w2, w5
  201880:	eb02011f 	cmp	x8, x2
  201884:	54001002 	b.cs	201a84 <_ftoa+0x374>  // b.hs, b.nlast
  201888:	f100811f 	cmp	x8, #0x20
      buf[len++] = '0';
  20188c:	52800601 	mov	w1, #0x30                  	// #48
    while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
  201890:	54000120 	b.eq	2018b4 <_ftoa+0x1a4>  // b.none
  201894:	d503201f 	nop
      buf[len++] = '0';
  201898:	91000508 	add	x8, x8, #0x1
  20189c:	8b080180 	add	x0, x12, x8
    while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
  2018a0:	eb02011f 	cmp	x8, x2
      buf[len++] = '0';
  2018a4:	381ff001 	sturb	w1, [x0, #-1]
    while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
  2018a8:	54000be0 	b.eq	201a24 <_ftoa+0x314>  // b.none
  2018ac:	f100811f 	cmp	x8, #0x20
  2018b0:	54ffff41 	b.ne	201898 <_ftoa+0x188>  // b.any
    }
    else if (flags & FLAGS_PLUS) {
      buf[len++] = '+';  // ignore the space if the '+' exists
    }
    else if (flags & FLAGS_SPACE) {
      buf[len++] = ' ';
  2018b4:	d2800408 	mov	x8, #0x20                  	// #32
    }
  }

  return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
  2018b8:	2a0503e6 	mov	w6, w5
  2018bc:	aa0c03e4 	mov	x4, x12
  2018c0:	aa0803e5 	mov	x5, x8
  2018c4:	aa1203e3 	mov	x3, x18
  2018c8:	aa1103e2 	mov	x2, x17
  2018cc:	aa1003e1 	mov	x1, x16
  2018d0:	aa0f03e0 	mov	x0, x15
  2018d4:	97fffe6f 	bl	201290 <_out_rev>
}
  2018d8:	a8c37bfd 	ldp	x29, x30, [sp], #48
  2018dc:	d65f03c0 	ret
    return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? "fni+" : "fni", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);
  2018e0:	37100207 	tbnz	w7, #2, 201920 <_ftoa+0x210>
  2018e4:	d2800060 	mov	x0, #0x3                   	// #3
  2018e8:	2a0503e6 	mov	w6, w5
  2018ec:	d0000004 	adrp	x4, 203000 <__FUNCTION__.0+0x68>
  2018f0:	91070084 	add	x4, x4, #0x1c0
  2018f4:	aa0003e5 	mov	x5, x0
  2018f8:	aa1203e3 	mov	x3, x18
  2018fc:	aa1103e2 	mov	x2, x17
  201900:	aa1003e1 	mov	x1, x16
  201904:	aa0f03e0 	mov	x0, x15
  201908:	17fffe62 	b	201290 <_out_rev>
    return _out_rev(out, buffer, idx, maxlen, "nan", 3, width, flags);
  20190c:	2a0503e6 	mov	w6, w5
  201910:	d0000004 	adrp	x4, 203000 <__FUNCTION__.0+0x68>
  201914:	d2800065 	mov	x5, #0x3                   	// #3
  201918:	91072084 	add	x4, x4, #0x1c8
  20191c:	17fffe5d 	b	201290 <_out_rev>
    return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? "fni+" : "fni", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);
  201920:	d2800080 	mov	x0, #0x4                   	// #4
  201924:	2a0503e6 	mov	w6, w5
  201928:	d0000004 	adrp	x4, 203000 <__FUNCTION__.0+0x68>
  20192c:	9106e084 	add	x4, x4, #0x1b8
  201930:	aa0003e5 	mov	x5, x0
  201934:	aa1203e3 	mov	x3, x18
  201938:	aa1103e2 	mov	x2, x17
  20193c:	aa1003e1 	mov	x1, x16
  201940:	aa0f03e0 	mov	x0, x15
  201944:	17fffe53 	b	201290 <_out_rev>
    value = 0 - value;
  201948:	2f00e401 	movi	d1, #0x0
    negative = true;
  20194c:	52800023 	mov	w3, #0x1                   	// #1
    value = 0 - value;
  201950:	1e603820 	fsub	d0, d1, d0
  if (!(flags & FLAGS_PRECISION)) {
  201954:	3757f1c7 	tbnz	w7, #10, 20178c <_ftoa+0x7c>
  201958:	d2d09000 	mov	x0, #0x848000000000        	// #145685290680320
  20195c:	910043ec 	add	x12, sp, #0x10
  201960:	f2e825c0 	movk	x0, #0x412e, lsl #48
    prec = PRINTF_DEFAULT_FLOAT_PRECISION;
  201964:	528000c4 	mov	w4, #0x6                   	// #6
  201968:	9e670002 	fmov	d2, x0
  20196c:	d2800008 	mov	x8, #0x0                   	// #0
  201970:	17ffff96 	b	2017c8 <_ftoa+0xb8>
    return _etoa(out, buffer, idx, maxlen, value, prec, width, flags);
  201974:	2a0703e6 	mov	w6, w7
  201978:	aa1203e3 	mov	x3, x18
  20197c:	aa1103e2 	mov	x2, x17
  201980:	aa1003e1 	mov	x1, x16
  201984:	aa0f03e0 	mov	x0, x15
  201988:	14000066 	b	201b20 <_etoa>
    return _out_rev(out, buffer, idx, maxlen, "fni-", 4, width, flags);
  20198c:	2a0503e6 	mov	w6, w5
  201990:	d0000004 	adrp	x4, 203000 <__FUNCTION__.0+0x68>
  201994:	d2800085 	mov	x5, #0x4                   	// #4
  201998:	91074084 	add	x4, x4, #0x1d0
  20199c:	17fffe3d 	b	201290 <_out_rev>
  2019a0:	51008081 	sub	w1, w4, #0x20
      buf[len++] = (char)(48U + (frac % 10U));
  2019a4:	b202e7e2 	mov	x2, #0xcccccccccccccccc    	// #-3689348814741910324
  2019a8:	0b080021 	add	w1, w1, w8
  2019ac:	f29999a2 	movk	x2, #0xcccd
  2019b0:	1400000d 	b	2019e4 <_ftoa+0x2d4>
  2019b4:	d343fd6b 	lsr	x11, x11, #3
      if (!(frac /= 10U)) {
  2019b8:	f10025df 	cmp	x14, #0x9
      --count;
  2019bc:	51000480 	sub	w0, w4, #0x1
      buf[len++] = (char)(48U + (frac % 10U));
  2019c0:	91000509 	add	x9, x8, #0x1
  2019c4:	8b0b096d 	add	x13, x11, x11, lsl #2
  2019c8:	cb0d05cd 	sub	x13, x14, x13, lsl #1
      if (!(frac /= 10U)) {
  2019cc:	aa0b03ee 	mov	x14, x11
      buf[len++] = (char)(48U + (frac % 10U));
  2019d0:	1100c1ab 	add	w11, w13, #0x30
  2019d4:	3828698b 	strb	w11, [x12, x8]
      if (!(frac /= 10U)) {
  2019d8:	54000349 	b.ls	201a40 <_ftoa+0x330>  // b.plast
      --count;
  2019dc:	2a0003e4 	mov	w4, w0
      buf[len++] = (char)(48U + (frac % 10U));
  2019e0:	aa0903e8 	mov	x8, x9
  2019e4:	9bc27dcb 	umulh	x11, x14, x2
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
  2019e8:	6b01009f 	cmp	w4, w1
  2019ec:	54fffe41 	b.ne	2019b4 <_ftoa+0x2a4>  // b.any
      buf[len++] = (char)(48U + (frac % 10U));
  2019f0:	d2800408 	mov	x8, #0x20                  	// #32
  2019f4:	17ffff8b 	b	201820 <_ftoa+0x110>
    ++frac;
  2019f8:	910005ce 	add	x14, x14, #0x1
    if (frac >= pow10[prec]) {
  2019fc:	9e6301c1 	ucvtf	d1, x14
  201a00:	1e622030 	fcmpe	d1, d2
  201a04:	5400004a 	b.ge	201a0c <_ftoa+0x2fc>  // b.tcont
  201a08:	17ffff7e 	b	201800 <_ftoa+0xf0>
      ++whole;
  201a0c:	1100054a 	add	w10, w10, #0x1
      frac = 0;
  201a10:	d280000e 	mov	x14, #0x0                   	// #0
  201a14:	17ffff7b 	b	201800 <_ftoa+0xf0>
  if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
  201a18:	120004e0 	and	w0, w7, #0x3
  201a1c:	7100041f 	cmp	w0, #0x1
  201a20:	54000780 	b.eq	201b10 <_ftoa+0x400>  // b.none
  if (len < PRINTF_FTOA_BUFFER_SIZE) {
  201a24:	f100811f 	cmp	x8, #0x20
  201a28:	54fff480 	b.eq	2018b8 <_ftoa+0x1a8>  // b.none
    if (negative) {
  201a2c:	34000323 	cbz	w3, 201a90 <_ftoa+0x380>
      buf[len++] = '-';
  201a30:	528005a0 	mov	w0, #0x2d                  	// #45
  201a34:	38286980 	strb	w0, [x12, x8]
  201a38:	91000508 	add	x8, x8, #0x1
  201a3c:	17ffff9f 	b	2018b8 <_ftoa+0x1a8>
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
  201a40:	f100813f 	cmp	x9, #0x20
  201a44:	54fffd60 	b.eq	2019f0 <_ftoa+0x2e0>  // b.none
  201a48:	91000901 	add	x1, x8, #0x2
  201a4c:	51000884 	sub	w4, w4, #0x2
  201a50:	8b040021 	add	x1, x1, x4
      buf[len++] = '0';
  201a54:	52800602 	mov	w2, #0x30                  	// #48
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
  201a58:	35000080 	cbnz	w0, 201a68 <_ftoa+0x358>
  201a5c:	14000013 	b	201aa8 <_ftoa+0x398>
  201a60:	eb01013f 	cmp	x9, x1
  201a64:	54000260 	b.eq	201ab0 <_ftoa+0x3a0>  // b.none
      buf[len++] = '0';
  201a68:	91000529 	add	x9, x9, #0x1
  201a6c:	8b090180 	add	x0, x12, x9
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
  201a70:	f100813f 	cmp	x9, #0x20
      buf[len++] = '0';
  201a74:	381ff002 	sturb	w2, [x0, #-1]
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
  201a78:	54ffff41 	b.ne	201a60 <_ftoa+0x350>  // b.any
      buf[len++] = (char)(48U + (frac % 10U));
  201a7c:	d2800408 	mov	x8, #0x20                  	// #32
  201a80:	17ffff68 	b	201820 <_ftoa+0x110>
  if (len < PRINTF_FTOA_BUFFER_SIZE) {
  201a84:	f100811f 	cmp	x8, #0x20
  201a88:	54fff180 	b.eq	2018b8 <_ftoa+0x1a8>  // b.none
  201a8c:	d503201f 	nop
    else if (flags & FLAGS_PLUS) {
  201a90:	371001c7 	tbnz	w7, #2, 201ac8 <_ftoa+0x3b8>
    else if (flags & FLAGS_SPACE) {
  201a94:	361ff127 	tbz	w7, #3, 2018b8 <_ftoa+0x1a8>
      buf[len++] = ' ';
  201a98:	52800400 	mov	w0, #0x20                  	// #32
  201a9c:	38286980 	strb	w0, [x12, x8]
  201aa0:	91000508 	add	x8, x8, #0x1
  201aa4:	17ffff85 	b	2018b8 <_ftoa+0x1a8>
      buf[len++] = (char)(48U + (frac % 10U));
  201aa8:	aa0903e1 	mov	x1, x9
  201aac:	d503201f 	nop
      buf[len++] = '.';
  201ab0:	528005c0 	mov	w0, #0x2e                  	// #46
  201ab4:	91000428 	add	x8, x1, #0x1
  201ab8:	38216980 	strb	w0, [x12, x1]
  201abc:	17ffff59 	b	201820 <_ftoa+0x110>
    if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
  201ac0:	54ffeacc 	b.gt	201818 <_ftoa+0x108>
  201ac4:	17ffff57 	b	201820 <_ftoa+0x110>
      buf[len++] = '+';  // ignore the space if the '+' exists
  201ac8:	52800560 	mov	w0, #0x2b                  	// #43
  201acc:	38286980 	strb	w0, [x12, x8]
  201ad0:	91000508 	add	x8, x8, #0x1
  201ad4:	17ffff79 	b	2018b8 <_ftoa+0x1a8>
  else if ((frac == 0U) || (frac & 1U)) {
  201ad8:	3607e94e 	tbz	w14, #0, 201800 <_ftoa+0xf0>
    ++frac;
  201adc:	910005ce 	add	x14, x14, #0x1
  201ae0:	17ffff48 	b	201800 <_ftoa+0xf0>
      width--;
  201ae4:	510004a2 	sub	w2, w5, #0x1
  201ae8:	aa0203e5 	mov	x5, x2
    while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
  201aec:	eb08005f 	cmp	x2, x8
  201af0:	54ffecc8 	b.hi	201888 <_ftoa+0x178>  // b.pmore
  201af4:	17ffffcc 	b	201a24 <_ftoa+0x314>
  double tmp = (value - whole) * pow10[prec];
  201af8:	d0000000 	adrp	x0, 203000 <__FUNCTION__.0+0x68>
  201afc:	91010000 	add	x0, x0, #0x40
  201b00:	910043ec 	add	x12, sp, #0x10
  201b04:	d2800008 	mov	x8, #0x0                   	// #0
  201b08:	fc645802 	ldr	d2, [x0, w4, uxtw #3]
  201b0c:	17ffff2f 	b	2017c8 <_ftoa+0xb8>
    if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
  201b10:	34fff8a5 	cbz	w5, 201a24 <_ftoa+0x314>
  201b14:	17ffff57 	b	201870 <_ftoa+0x160>
  201b18:	d503201f 	nop
  201b1c:	d503201f 	nop

0000000000201b20 <_etoa>:


#if defined(PRINTF_SUPPORT_EXPONENTIAL)
// internal ftoa variant for exponential floating-point type, contributed by Martijn Jasperse <m.jasperse@gmail.com>
static size_t _etoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags)
{
  201b20:	d10203ff 	sub	sp, sp, #0x80
  // check for NaN and special values
  if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {
  201b24:	1e602000 	fcmp	d0, d0
{
  201b28:	a9017bfd 	stp	x29, x30, [sp, #16]
  201b2c:	910043fd 	add	x29, sp, #0x10
  201b30:	a90253f3 	stp	x19, x20, [sp, #32]
  201b34:	aa0203f3 	mov	x19, x2
  201b38:	2a0603f4 	mov	w20, w6
  201b3c:	a9035bf5 	stp	x21, x22, [sp, #48]
  201b40:	aa0003f5 	mov	x21, x0
  201b44:	aa0103f6 	mov	x22, x1
  201b48:	a90463f7 	stp	x23, x24, [sp, #64]
  201b4c:	aa0303f7 	mov	x23, x3
  201b50:	a90673fb 	stp	x27, x28, [sp, #96]
  201b54:	2a0503fb 	mov	w27, w5
  if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {
  201b58:	540012c1 	b.ne	201db0 <_etoa+0x290>  // b.any
  201b5c:	92f00200 	mov	x0, #0x7fefffffffffffff    	// #9218868437227405311
  201b60:	9e670001 	fmov	d1, x0
  201b64:	1e612010 	fcmpe	d0, d1
  201b68:	5400124c 	b.gt	201db0 <_etoa+0x290>
  201b6c:	92e00200 	mov	x0, #0xffefffffffffffff    	// #-4503599627370497
  201b70:	9e670001 	fmov	d1, x0
  201b74:	1e612010 	fcmpe	d0, d1
  201b78:	540011c4 	b.mi	201db0 <_etoa+0x290>  // b.first
    return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);
  }

  // determine the sign
  const bool negative = value < 0;
  if (negative) {
  201b7c:	1e602018 	fcmpe	d0, #0.0
  201b80:	1e614002 	fneg	d2, d0

  conv.F = value;
  int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;           // effectively log2
  conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
  // now approximate log10 from the log2 integer part and an expansion of ln around 1.5
  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
  201b84:	d0000000 	adrp	x0, 203000 <__FUNCTION__.0+0x68>
  201b88:	fd410416 	ldr	d22, [x0, #520]
  201b8c:	d0000000 	adrp	x0, 203000 <__FUNCTION__.0+0x68>
  201b90:	fd410801 	ldr	d1, [x0, #528]
  201b94:	d0000000 	adrp	x0, 203000 <__FUNCTION__.0+0x68>
  201b98:	fd410c15 	ldr	d21, [x0, #536]
  201b9c:	1e604c42 	fcsel	d2, d2, d0, mi	// mi = first
  // now we want to compute 10^expval but we want to be sure it won't overflow
  exp2 = (int)(expval * 3.321928094887362 + 0.5);
  201ba0:	d0000000 	adrp	x0, 203000 <__FUNCTION__.0+0x68>
  201ba4:	fd411014 	ldr	d20, [x0, #544]
  const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
  201ba8:	d0000000 	adrp	x0, 203000 <__FUNCTION__.0+0x68>
  201bac:	fd411413 	ldr	d19, [x0, #552]
  201bb0:	d0000000 	adrp	x0, 203000 <__FUNCTION__.0+0x68>
  201bb4:	fd411812 	ldr	d18, [x0, #560]
  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
  201bb8:	1e6f1018 	fmov	d24, #1.500000000000000000e+00
  conv.F = value;
  201bbc:	9e660040 	fmov	x0, d2
  201bc0:	a9056bf9 	stp	x25, x26, [sp, #80]
  exp2 = (int)(expval * 3.321928094887362 + 0.5);
  201bc4:	1e6c1005 	fmov	d5, #5.000000000000000000e-01
  const double z2 = z * z;
  conv.U = (uint64_t)(exp2 + 1023) << 52U;
  // compute exp(z) using continued fractions, see https://en.wikipedia.org/wiki/Exponential_function#Continued_fractions_for_ex
  conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
  201bc8:	1e659003 	fmov	d3, #1.400000000000000000e+01
  201bcc:	1e649007 	fmov	d7, #1.000000000000000000e+01
  201bd0:	1e631011 	fmov	d17, #6.000000000000000000e+00
  201bd4:	1e601006 	fmov	d6, #2.000000000000000000e+00
  conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
  201bd8:	9240cc01 	and	x1, x0, #0xfffffffffffff
  int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;           // effectively log2
  201bdc:	d374f800 	ubfx	x0, x0, #52, #11
  201be0:	510ffc00 	sub	w0, w0, #0x3ff
  conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
  201be4:	b24c2421 	orr	x1, x1, #0x3ff0000000000000
  201be8:	9e670024 	fmov	d4, x1
  conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
  201bec:	1e6e1010 	fmov	d16, #1.000000000000000000e+00
  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
  201bf0:	1e620017 	scvtf	d23, w0
    prec = PRINTF_DEFAULT_FLOAT_PRECISION;
  201bf4:	721600c3 	ands	w3, w6, #0x400
  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
  201bf8:	1e783884 	fsub	d4, d4, d24
    prec = PRINTF_DEFAULT_FLOAT_PRECISION;
  201bfc:	528000c2 	mov	w2, #0x6                   	// #6
  201c00:	1a821084 	csel	w4, w4, w2, ne	// ne = any
  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
  201c04:	1f5606e1 	fmadd	d1, d23, d22, d1
  201c08:	1f550481 	fmadd	d1, d4, d21, d1
  201c0c:	1e780039 	fcvtzs	w25, d1
  exp2 = (int)(expval * 3.321928094887362 + 0.5);
  201c10:	1e620324 	scvtf	d4, w25
  201c14:	1f541481 	fmadd	d1, d4, d20, d5
  201c18:	1e780020 	fcvtzs	w0, d1
  const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
  201c1c:	1e620001 	scvtf	d1, w0
  conv.U = (uint64_t)(exp2 + 1023) << 52U;
  201c20:	110ffc00 	add	w0, w0, #0x3ff
  201c24:	9e670005 	fmov	d5, x0
  201c28:	5f7454a5 	shl	d5, d5, #52
  const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
  201c2c:	1e730821 	fmul	d1, d1, d19
  201c30:	1f728481 	fnmsub	d1, d4, d18, d1
  const double z2 = z * z;
  201c34:	1e610824 	fmul	d4, d1, d1
  conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
  201c38:	1e6138c6 	fsub	d6, d6, d1
  201c3c:	1e612821 	fadd	d1, d1, d1
  201c40:	1e631883 	fdiv	d3, d4, d3
  201c44:	1e672863 	fadd	d3, d3, d7
  201c48:	1e631883 	fdiv	d3, d4, d3
  201c4c:	1e712863 	fadd	d3, d3, d17
  201c50:	1e631884 	fdiv	d4, d4, d3
  201c54:	1e662884 	fadd	d4, d4, d6
  201c58:	1e641821 	fdiv	d1, d1, d4
  201c5c:	1e702821 	fadd	d1, d1, d16
  201c60:	1e650821 	fmul	d1, d1, d5
  // correct for rounding errors
  if (value < conv.F) {
  201c64:	1e612050 	fcmpe	d2, d1
  201c68:	54000be4 	b.mi	201de4 <_etoa+0x2c4>  // b.first
    expval--;
    conv.F /= 10;
  }

  // the exponent format is "%+03d" and largest value is "307", so set aside 4-5 characters
  unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
  201c6c:	11018f20 	add	w0, w25, #0x63
  201c70:	7103181f 	cmp	w0, #0xc6
  201c74:	1a9f97fc 	cset	w28, hi	// hi = pmore
  201c78:	1100139c 	add	w28, w28, #0x4

  // in "%g" mode, "prec" is the number of *significant figures* not decimals
  if (flags & FLAGS_ADAPT_EXP) {
  201c7c:	36580134 	tbz	w20, #11, 201ca0 <_etoa+0x180>
    // do we want to fall-back to "%f" mode?
    if ((value >= 1e-4) && (value < 1e6)) {
  201c80:	d0000000 	adrp	x0, 203000 <__FUNCTION__.0+0x68>
  201c84:	fd411c03 	ldr	d3, [x0, #568]
  201c88:	1e632050 	fcmpe	d2, d3
  201c8c:	54000cea 	b.ge	201e28 <_etoa+0x308>  // b.tcont
      minwidth = 0U;
      expval   = 0;
    }
    else {
      // we use one sigfig for the whole part
      if ((prec > 0) && (flags & FLAGS_PRECISION)) {
  201c90:	34000084 	cbz	w4, 201ca0 <_etoa+0x180>
        --prec;
  201c94:	7100007f 	cmp	w3, #0x0
  201c98:	1a9f07e0 	cset	w0, ne	// ne = any
  201c9c:	4b000084 	sub	w4, w4, w0

  // will everything fit?
  unsigned int fwidth = width;
  if (width > minwidth) {
    // we didn't fall-back so subtract the characters required for the exponent
    fwidth -= minwidth;
  201ca0:	6b1c0365 	subs	w5, w27, w28
  } else {
    // not enough characters, so go back to default sizing
    fwidth = 0U;
  }
  if ((flags & FLAGS_LEFT) && minwidth) {
  201ca4:	121f0280 	and	w0, w20, #0x2
    fwidth -= minwidth;
  201ca8:	1a9f80a5 	csel	w5, w5, wzr, hi	// hi = pmore
  if ((flags & FLAGS_LEFT) && minwidth) {
  201cac:	7100001f 	cmp	w0, #0x0
  201cb0:	1a9f07e0 	cset	w0, ne	// ne = any
  201cb4:	b9007fe0 	str	w0, [sp, #124]
  201cb8:	1a9f00a5 	csel	w5, w5, wzr, eq	// eq = none
    // if we're padding on the right, DON'T pad the floating part
    fwidth = 0U;
  }

  // rescale the float value
  if (expval) {
  201cbc:	5280003a 	mov	w26, #0x1                   	// #1
  201cc0:	34000059 	cbz	w25, 201cc8 <_etoa+0x1a8>
    value /= conv.F;
  201cc4:	1e611842 	fdiv	d2, d2, d1
  }

  // output the floating part
  const size_t start_idx = idx;
  idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
  201cc8:	1e602018 	fcmpe	d0, #0.0
  201ccc:	54000aa4 	b.mi	201e20 <_etoa+0x300>  // b.first
  201cd0:	1e604040 	fmov	d0, d2
  201cd4:	12147a86 	and	w6, w20, #0xfffff7ff
  201cd8:	aa1703e3 	mov	x3, x23
  201cdc:	aa1303e2 	mov	x2, x19
  201ce0:	aa1603e1 	mov	x1, x22
  201ce4:	aa1503e0 	mov	x0, x21
  201ce8:	97fffe8a 	bl	201710 <_ftoa>
  201cec:	aa0003f8 	mov	x24, x0

  // output the exponent part
  if (minwidth) {
  201cf0:	340004fa 	cbz	w26, 201d8c <_etoa+0x26c>
    // output the exponential symbol
    out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);
  201cf4:	f27b029f 	tst	x20, #0x20
  201cf8:	52800ca1 	mov	w1, #0x65                  	// #101
  201cfc:	aa1803e2 	mov	x2, x24
  201d00:	aa1703e3 	mov	x3, x23
  201d04:	528008a0 	mov	w0, #0x45                  	// #69
  201d08:	1a800020 	csel	w0, w1, w0, eq	// eq = none
  201d0c:	aa1603e1 	mov	x1, x22
  201d10:	d63f02a0 	blr	x21
    // output the exponent value
    idx = _ntoa_long(out, buffer, idx, maxlen, (expval < 0) ? -expval : expval, expval < 0, 10, 0, minwidth-1, FLAGS_ZEROPAD | FLAGS_PLUS);
  201d14:	7100033f 	cmp	w25, #0x0
  201d18:	528000a0 	mov	w0, #0x5                   	// #5
  201d1c:	5a99a724 	cneg	w4, w25, lt	// lt = tstop
  201d20:	5100079c 	sub	w28, w28, #0x1
  201d24:	b90003fc 	str	w28, [sp]
    out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);
  201d28:	91000702 	add	x2, x24, #0x1
    idx = _ntoa_long(out, buffer, idx, maxlen, (expval < 0) ? -expval : expval, expval < 0, 10, 0, minwidth-1, FLAGS_ZEROPAD | FLAGS_PLUS);
  201d2c:	b9000be0 	str	w0, [sp, #8]
  201d30:	93407c84 	sxtw	x4, w4
  201d34:	531f7f25 	lsr	w5, w25, #31
  201d38:	aa1703e3 	mov	x3, x23
  201d3c:	aa1603e1 	mov	x1, x22
  201d40:	aa1503e0 	mov	x0, x21
  201d44:	52800007 	mov	w7, #0x0                   	// #0
  201d48:	d2800146 	mov	x6, #0xa                   	// #10
  201d4c:	97fffd95 	bl	2013a0 <_ntoa_long>
  201d50:	aa0003f8 	mov	x24, x0
    // might need to right-pad spaces
    if (flags & FLAGS_LEFT) {
  201d54:	b9407fe0 	ldr	w0, [sp, #124]
  201d58:	340001a0 	cbz	w0, 201d8c <_etoa+0x26c>
      while (idx - start_idx < width) out(' ', buffer, idx++, maxlen);
  201d5c:	cb130313 	sub	x19, x24, x19
  201d60:	eb13037f 	cmp	x27, x19
  201d64:	54000149 	b.ls	201d8c <_etoa+0x26c>  // b.plast
  201d68:	aa1803e2 	mov	x2, x24
  201d6c:	91000673 	add	x19, x19, #0x1
  201d70:	aa1703e3 	mov	x3, x23
  201d74:	aa1603e1 	mov	x1, x22
  201d78:	52800400 	mov	w0, #0x20                  	// #32
  201d7c:	d63f02a0 	blr	x21
  201d80:	91000718 	add	x24, x24, #0x1
  201d84:	eb1b027f 	cmp	x19, x27
  201d88:	54ffff03 	b.cc	201d68 <_etoa+0x248>  // b.lo, b.ul, b.last
    }
  }
  return idx;
}
  201d8c:	a9417bfd 	ldp	x29, x30, [sp, #16]
  201d90:	aa1803e0 	mov	x0, x24
  201d94:	a94253f3 	ldp	x19, x20, [sp, #32]
  201d98:	a9435bf5 	ldp	x21, x22, [sp, #48]
  201d9c:	a94463f7 	ldp	x23, x24, [sp, #64]
  201da0:	a9456bf9 	ldp	x25, x26, [sp, #80]
  201da4:	a94673fb 	ldp	x27, x28, [sp, #96]
  201da8:	910203ff 	add	sp, sp, #0x80
  201dac:	d65f03c0 	ret
    return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);
  201db0:	2a1403e6 	mov	w6, w20
  201db4:	2a1b03e5 	mov	w5, w27
  201db8:	aa1703e3 	mov	x3, x23
  201dbc:	aa1303e2 	mov	x2, x19
  201dc0:	aa1603e1 	mov	x1, x22
  201dc4:	aa1503e0 	mov	x0, x21
}
  201dc8:	a9417bfd 	ldp	x29, x30, [sp, #16]
  201dcc:	a94253f3 	ldp	x19, x20, [sp, #32]
  201dd0:	a9435bf5 	ldp	x21, x22, [sp, #48]
  201dd4:	a94463f7 	ldp	x23, x24, [sp, #64]
  201dd8:	a94673fb 	ldp	x27, x28, [sp, #96]
  201ddc:	910203ff 	add	sp, sp, #0x80
  idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
  201de0:	17fffe4c 	b	201710 <_ftoa>
    conv.F /= 10;
  201de4:	1e671821 	fdiv	d1, d1, d7
    expval--;
  201de8:	51000739 	sub	w25, w25, #0x1
  unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
  201dec:	11018f20 	add	w0, w25, #0x63
  201df0:	7103181f 	cmp	w0, #0xc6
  201df4:	1a9f97fc 	cset	w28, hi	// hi = pmore
  201df8:	1100139c 	add	w28, w28, #0x4
  if (flags & FLAGS_ADAPT_EXP) {
  201dfc:	365ff534 	tbz	w20, #11, 201ca0 <_etoa+0x180>
  201e00:	17ffffa0 	b	201c80 <_etoa+0x160>
      flags |= FLAGS_PRECISION;   // make sure _ftoa respects precision
  201e04:	2a0103f4 	mov	w20, w1
    fwidth = 0U;
  201e08:	52800005 	mov	w5, #0x0                   	// #0
      minwidth = 0U;
  201e0c:	5280001c 	mov	w28, #0x0                   	// #0
  if ((flags & FLAGS_LEFT) && minwidth) {
  201e10:	5280001a 	mov	w26, #0x0                   	// #0
      expval   = 0;
  201e14:	52800019 	mov	w25, #0x0                   	// #0
  if ((flags & FLAGS_LEFT) && minwidth) {
  201e18:	b9007fff 	str	wzr, [sp, #124]
  201e1c:	d503201f 	nop
  idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
  201e20:	1e614042 	fneg	d2, d2
  201e24:	17ffffab 	b	201cd0 <_etoa+0x1b0>
    if ((value >= 1e-4) && (value < 1e6)) {
  201e28:	d2d09000 	mov	x0, #0x848000000000        	// #145685290680320
  201e2c:	f2e825c0 	movk	x0, #0x412e, lsl #48
  201e30:	9e670003 	fmov	d3, x0
  201e34:	1e632050 	fcmpe	d2, d3
  201e38:	54000044 	b.mi	201e40 <_etoa+0x320>  // b.first
  201e3c:	17ffff95 	b	201c90 <_etoa+0x170>
        prec = (unsigned)((int)prec - expval - 1);
  201e40:	4b190080 	sub	w0, w4, w25
  201e44:	6b04033f 	cmp	w25, w4
  201e48:	51000400 	sub	w0, w0, #0x1
      flags |= FLAGS_PRECISION;   // make sure _ftoa respects precision
  201e4c:	32160281 	orr	w1, w20, #0x400
        prec = (unsigned)((int)prec - expval - 1);
  201e50:	1a9fb004 	csel	w4, w0, wzr, lt	// lt = tstop
  if (width > minwidth) {
  201e54:	350001bb 	cbnz	w27, 201e88 <_etoa+0x368>
  idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
  201e58:	1e602018 	fcmpe	d0, #0.0
  201e5c:	54fffd44 	b.mi	201e04 <_etoa+0x2e4>  // b.first
  201e60:	12147a86 	and	w6, w20, #0xfffff7ff
  201e64:	1e604040 	fmov	d0, d2
  201e68:	a9456bf9 	ldp	x25, x26, [sp, #80]
  201e6c:	321600c6 	orr	w6, w6, #0x400
  201e70:	aa1703e3 	mov	x3, x23
  201e74:	aa1303e2 	mov	x2, x19
  201e78:	aa1603e1 	mov	x1, x22
  201e7c:	aa1503e0 	mov	x0, x21
  201e80:	52800005 	mov	w5, #0x0                   	// #0
  201e84:	17ffffd1 	b	201dc8 <_etoa+0x2a8>
      flags |= FLAGS_PRECISION;   // make sure _ftoa respects precision
  201e88:	2a0103f4 	mov	w20, w1
  if (width > minwidth) {
  201e8c:	2a1b03e5 	mov	w5, w27
      minwidth = 0U;
  201e90:	5280001c 	mov	w28, #0x0                   	// #0
  if (width > minwidth) {
  201e94:	52800019 	mov	w25, #0x0                   	// #0
  201e98:	5280001a 	mov	w26, #0x0                   	// #0
  201e9c:	b9007fff 	str	wzr, [sp, #124]
  201ea0:	17ffff8a 	b	201cc8 <_etoa+0x1a8>
  201ea4:	d503201f 	nop
  201ea8:	d503201f 	nop
  201eac:	d503201f 	nop

0000000000201eb0 <_vsnprintf>:
#endif  // PRINTF_SUPPORT_FLOAT


// internal vsnprintf
static int _vsnprintf(out_fct_type out, char* buffer, const size_t maxlen, const char* format, va_list va)
{
  201eb0:	d102c3ff 	sub	sp, sp, #0xb0
  unsigned int flags, width, precision, n;
  size_t idx = 0U;

  if (!buffer) {
    // use null output function
    out = _out_null;
  201eb4:	f100003f 	cmp	x1, #0x0
{
  201eb8:	a9017bfd 	stp	x29, x30, [sp, #16]
  201ebc:	910043fd 	add	x29, sp, #0x10
  201ec0:	a90253f3 	stp	x19, x20, [sp, #32]
    out = _out_null;
  201ec4:	90000013 	adrp	x19, 201000 <memcpy+0x100>
  201ec8:	910a0273 	add	x19, x19, #0x280
{
  201ecc:	a9035bf5 	stp	x21, x22, [sp, #48]
    out = _out_null;
  201ed0:	9a800273 	csel	x19, x19, x0, eq	// eq = none
{
  201ed4:	aa0103f5 	mov	x21, x1
  201ed8:	a90463f7 	stp	x23, x24, [sp, #64]
  201edc:	aa0203f4 	mov	x20, x2
  201ee0:	b9401898 	ldr	w24, [x4, #24]
  201ee4:	a90673fb 	stp	x27, x28, [sp, #96]
  }

  while (*format)
  201ee8:	d280001c 	mov	x28, #0x0                   	// #0
  201eec:	f9400880 	ldr	x0, [x4, #16]
  201ef0:	f9004fe0 	str	x0, [sp, #152]
  201ef4:	39400061 	ldrb	w1, [x3]
  201ef8:	a9400896 	ldp	x22, x2, [x4]
  201efc:	f90047e2 	str	x2, [sp, #136]
  201f00:	b9401c80 	ldr	w0, [x4, #28]
  201f04:	b90077e0 	str	w0, [sp, #116]
  201f08:	34004141 	cbz	w1, 202730 <_vsnprintf+0x880>
      default :
        break;
    }

    // evaluate specifier
    switch (*format) {
  201f0c:	d280003b 	mov	x27, #0x1                   	// #1
  201f10:	a9056bf9 	stp	x25, x26, [sp, #80]
  201f14:	b0000019 	adrp	x25, 202000 <_vsnprintf+0x150>
  201f18:	913ec320 	add	x0, x25, #0xfb0
  201f1c:	aa0303fa 	mov	x26, x3
  201f20:	f9003fe0 	str	x0, [sp, #120]
  201f24:	1400000a 	b	201f4c <_vsnprintf+0x9c>
      out(*format, buffer, idx++, maxlen);
  201f28:	91000784 	add	x4, x28, #0x1
  201f2c:	2a0103e0 	mov	w0, w1
        out('%', buffer, idx++, maxlen);
        format++;
        break;

      default :
        out(*format, buffer, idx++, maxlen);
  201f30:	aa1c03e2 	mov	x2, x28
  201f34:	aa1403e3 	mov	x3, x20
  201f38:	aa1503e1 	mov	x1, x21
  201f3c:	aa0403fc 	mov	x28, x4
  201f40:	d63f0260 	blr	x19
  while (*format)
  201f44:	39400341 	ldrb	w1, [x26]
  201f48:	34000cc1 	cbz	w1, 2020e0 <_vsnprintf+0x230>
      format++;
  201f4c:	9100075a 	add	x26, x26, #0x1
    if (*format != '%') {
  201f50:	7100943f 	cmp	w1, #0x25
  201f54:	54fffea1 	b.ne	201f28 <_vsnprintf+0x78>  // b.any
      switch (*format) {
  201f58:	aa1a03e1 	mov	x1, x26
    flags = 0U;
  201f5c:	52800006 	mov	w6, #0x0                   	// #0
      switch (*format) {
  201f60:	38401420 	ldrb	w0, [x1], #1
  201f64:	7100ac1f 	cmp	w0, #0x2b
  201f68:	540001a0 	b.eq	201f9c <_vsnprintf+0xec>  // b.none
  201f6c:	d503201f 	nop
  201f70:	540001c8 	b.hi	201fa8 <_vsnprintf+0xf8>  // b.pmore
  201f74:	7100801f 	cmp	w0, #0x20
  201f78:	54000260 	b.eq	201fc4 <_vsnprintf+0x114>  // b.none
  201f7c:	71008c1f 	cmp	w0, #0x23
  201f80:	540002e1 	b.ne	201fdc <_vsnprintf+0x12c>  // b.any
        case '#': flags |= FLAGS_HASH;    format++; n = 1U; break;
  201f84:	321c00c6 	orr	w6, w6, #0x10
      format++;
  201f88:	aa0103fa 	mov	x26, x1
      switch (*format) {
  201f8c:	aa1a03e1 	mov	x1, x26
  201f90:	38401420 	ldrb	w0, [x1], #1
  201f94:	7100ac1f 	cmp	w0, #0x2b
  201f98:	54fffec1 	b.ne	201f70 <_vsnprintf+0xc0>  // b.any
        case '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;
  201f9c:	321e00c6 	orr	w6, w6, #0x4
      format++;
  201fa0:	aa0103fa 	mov	x26, x1
  201fa4:	17fffffa 	b	201f8c <_vsnprintf+0xdc>
      switch (*format) {
  201fa8:	7100b41f 	cmp	w0, #0x2d
  201fac:	54000120 	b.eq	201fd0 <_vsnprintf+0x120>  // b.none
  201fb0:	7100c01f 	cmp	w0, #0x30
  201fb4:	54005fe1 	b.ne	202bb0 <_vsnprintf+0xd00>  // b.any
        case '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;
  201fb8:	320000c6 	orr	w6, w6, #0x1
      format++;
  201fbc:	aa0103fa 	mov	x26, x1
  201fc0:	17fffff3 	b	201f8c <_vsnprintf+0xdc>
        case ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;
  201fc4:	321d00c6 	orr	w6, w6, #0x8
      format++;
  201fc8:	aa0103fa 	mov	x26, x1
  201fcc:	17fffff0 	b	201f8c <_vsnprintf+0xdc>
        case '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;
  201fd0:	321f00c6 	orr	w6, w6, #0x2
      format++;
  201fd4:	aa0103fa 	mov	x26, x1
  201fd8:	17ffffed 	b	201f8c <_vsnprintf+0xdc>
    else if (*format == '*') {
  201fdc:	7100a81f 	cmp	w0, #0x2a
  201fe0:	54000ae0 	b.eq	20213c <_vsnprintf+0x28c>  // b.none
    width = 0U;
  201fe4:	52800019 	mov	w25, #0x0                   	// #0
    precision = 0U;
  201fe8:	52800017 	mov	w23, #0x0                   	// #0
    switch (*format) {
  201fec:	7101b01f 	cmp	w0, #0x6c
        format++;
  201ff0:	aa0103e2 	mov	x2, x1
    switch (*format) {
  201ff4:	54000de0 	b.eq	2021b0 <_vsnprintf+0x300>  // b.none
  201ff8:	54000969 	b.ls	202124 <_vsnprintf+0x274>  // b.plast
  201ffc:	7101d01f 	cmp	w0, #0x74
  202000:	54000060 	b.eq	20200c <_vsnprintf+0x15c>  // b.none
  202004:	7101e81f 	cmp	w0, #0x7a
  202008:	54000241 	b.ne	202050 <_vsnprintf+0x1a0>  // b.any
        if (*format == 'l') {
  20200c:	39400740 	ldrb	w0, [x26, #1]
        flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
  202010:	321800c6 	orr	w6, w6, #0x100
        format++;
  202014:	9100045a 	add	x26, x2, #0x1
    switch (*format) {
  202018:	71019c1f 	cmp	w0, #0x67
  20201c:	540001e8 	b.hi	202058 <_vsnprintf+0x1a8>  // b.pmore
  202020:	7100901f 	cmp	w0, #0x24
  202024:	54000089 	b.ls	202034 <_vsnprintf+0x184>  // b.plast
  202028:	51009401 	sub	w1, w0, #0x25
  20202c:	7101083f 	cmp	w1, #0x42
  202030:	54000069 	b.ls	20203c <_vsnprintf+0x18c>  // b.plast
        out(*format, buffer, idx++, maxlen);
  202034:	91000784 	add	x4, x28, #0x1
  202038:	17ffffbe 	b	201f30 <_vsnprintf+0x80>
    switch (*format) {
  20203c:	f9403fe2 	ldr	x2, [sp, #120]
  202040:	78615841 	ldrh	w1, [x2, w1, uxtw #1]
  202044:	10000062 	adr	x2, 202050 <_vsnprintf+0x1a0>
  202048:	8b21a841 	add	x1, x2, w1, sxth #2
  20204c:	d61f0020 	br	x1
        format++;
  202050:	aa0103fa 	mov	x26, x1
  202054:	d503201f 	nop
    switch (*format) {
  202058:	5101a401 	sub	w1, w0, #0x69
  20205c:	12001c21 	and	w1, w1, #0xff
  202060:	71003c3f 	cmp	w1, #0xf
  202064:	54fffe88 	b.hi	202034 <_vsnprintf+0x184>  // b.pmore
  202068:	9ac12362 	lsl	x2, x27, x1
  20206c:	d2920823 	mov	x3, #0x9041                	// #36929
  202070:	ea03005f 	tst	x2, x3
  202074:	54003021 	b.ne	202678 <_vsnprintf+0x7c8>  // b.any
  202078:	7100283f 	cmp	w1, #0xa
  20207c:	540014a0 	b.eq	202310 <_vsnprintf+0x460>  // b.none
  202080:	71001c3f 	cmp	w1, #0x7
  202084:	54fffd81 	b.ne	202034 <_vsnprintf+0x184>  // b.any
        flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
  202088:	52800420 	mov	w0, #0x21                  	// #33
  20208c:	2a0000c0 	orr	w0, w6, w0
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
  202090:	37f820f8 	tbnz	w24, #31, 2024ac <_vsnprintf+0x5fc>
  202094:	91003ec2 	add	x2, x22, #0xf
  202098:	aa1603e1 	mov	x1, x22
  20209c:	927df056 	and	x22, x2, #0xfffffffffffffff8
  2020a0:	2a1703e7 	mov	w7, w23
  2020a4:	aa1c03e2 	mov	x2, x28
  2020a8:	f9400024 	ldr	x4, [x1]
  2020ac:	d2800206 	mov	x6, #0x10                  	// #16
  2020b0:	52800201 	mov	w1, #0x10                  	// #16
  2020b4:	b90003e1 	str	w1, [sp]
  2020b8:	b9000be0 	str	w0, [sp, #8]
  2020bc:	52800005 	mov	w5, #0x0                   	// #0
  2020c0:	aa1503e1 	mov	x1, x21
  2020c4:	aa1403e3 	mov	x3, x20
  2020c8:	aa1303e0 	mov	x0, x19
  2020cc:	97fffcb5 	bl	2013a0 <_ntoa_long>
  while (*format)
  2020d0:	39400341 	ldrb	w1, [x26]
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
  2020d4:	aa0003fc 	mov	x28, x0
  while (*format)
  2020d8:	35fff3a1 	cbnz	w1, 201f4c <_vsnprintf+0x9c>
  2020dc:	d503201f 	nop
  2020e0:	a9456bf9 	ldp	x25, x26, [sp, #80]

  // termination
  out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);

  // return written chars without terminating \0
  return (int)idx;
  2020e4:	2a1c03f6 	mov	w22, w28
  out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
  2020e8:	eb1c029f 	cmp	x20, x28
  2020ec:	d1000682 	sub	x2, x20, #0x1
  2020f0:	aa1503e1 	mov	x1, x21
  2020f4:	9a9c9042 	csel	x2, x2, x28, ls	// ls = plast
  2020f8:	aa1403e3 	mov	x3, x20
  2020fc:	52800000 	mov	w0, #0x0                   	// #0
  202100:	d63f0260 	blr	x19
}
  202104:	a9417bfd 	ldp	x29, x30, [sp, #16]
  202108:	2a1603e0 	mov	w0, w22
  20210c:	a94253f3 	ldp	x19, x20, [sp, #32]
  202110:	a9435bf5 	ldp	x21, x22, [sp, #48]
  202114:	a94463f7 	ldp	x23, x24, [sp, #64]
  202118:	a94673fb 	ldp	x27, x28, [sp, #96]
  20211c:	9102c3ff 	add	sp, sp, #0xb0
  202120:	d65f03c0 	ret
    switch (*format) {
  202124:	7101a01f 	cmp	w0, #0x68
  202128:	54000ea0 	b.eq	2022fc <_vsnprintf+0x44c>  // b.none
  20212c:	7101a81f 	cmp	w0, #0x6a
  202130:	54fff6e0 	b.eq	20200c <_vsnprintf+0x15c>  // b.none
  202134:	aa1a03e2 	mov	x2, x26
  202138:	17ffffb7 	b	202014 <_vsnprintf+0x164>
      const int w = va_arg(va, int);
  20213c:	37f80498 	tbnz	w24, #31, 2021cc <_vsnprintf+0x31c>
  202140:	91002ec2 	add	x2, x22, #0xb
  202144:	aa1603e0 	mov	x0, x22
  202148:	927df056 	and	x22, x2, #0xfffffffffffffff8
  20214c:	b9400019 	ldr	w25, [x0]
      if (w < 0) {
  202150:	36f80079 	tbz	w25, #31, 20215c <_vsnprintf+0x2ac>
        flags |= FLAGS_LEFT;    // reverse padding
  202154:	321f00c6 	orr	w6, w6, #0x2
        width = (unsigned int)-w;
  202158:	4b1903f9 	neg	w25, w25
    if (*format == '.') {
  20215c:	39400740 	ldrb	w0, [x26, #1]
      format++;
  202160:	aa0103fa 	mov	x26, x1
  202164:	91000421 	add	x1, x1, #0x1
    if (*format == '.') {
  202168:	7100b81f 	cmp	w0, #0x2e
    precision = 0U;
  20216c:	52800017 	mov	w23, #0x0                   	// #0
    if (*format == '.') {
  202170:	54fff3e1 	b.ne	201fec <_vsnprintf+0x13c>  // b.any
      if (_is_digit(*format)) {
  202174:	39400740 	ldrb	w0, [x26, #1]
      flags |= FLAGS_PRECISION;
  202178:	321600c6 	orr	w6, w6, #0x400
      format++;
  20217c:	aa0103e2 	mov	x2, x1
  return (ch >= '0') && (ch <= '9');
  202180:	5100c003 	sub	w3, w0, #0x30
      if (_is_digit(*format)) {
  202184:	12001c63 	and	w3, w3, #0xff
  202188:	7100247f 	cmp	w3, #0x9
  20218c:	54001489 	b.ls	20241c <_vsnprintf+0x56c>  // b.plast
      else if (*format == '*') {
  202190:	7100a81f 	cmp	w0, #0x2a
  202194:	540025c0 	b.eq	20264c <_vsnprintf+0x79c>  // b.none
      format++;
  202198:	aa0103fa 	mov	x26, x1
  20219c:	91000421 	add	x1, x1, #0x1
    switch (*format) {
  2021a0:	7101b01f 	cmp	w0, #0x6c
        format++;
  2021a4:	aa0103e2 	mov	x2, x1
    switch (*format) {
  2021a8:	54fff281 	b.ne	201ff8 <_vsnprintf+0x148>  // b.any
  2021ac:	d503201f 	nop
        if (*format == 'l') {
  2021b0:	39400740 	ldrb	w0, [x26, #1]
  2021b4:	7101b01f 	cmp	w0, #0x6c
  2021b8:	54fff2c1 	b.ne	202010 <_vsnprintf+0x160>  // b.any
    switch (*format) {
  2021bc:	39400b40 	ldrb	w0, [x26, #2]
          flags |= FLAGS_LONG_LONG;
  2021c0:	321804c6 	orr	w6, w6, #0x300
          format++;
  2021c4:	91000b42 	add	x2, x26, #0x2
  2021c8:	17ffff93 	b	202014 <_vsnprintf+0x164>
      const int w = va_arg(va, int);
  2021cc:	11002302 	add	w2, w24, #0x8
  2021d0:	7100005f 	cmp	w2, #0x0
  2021d4:	540018ed 	b.le	2024f0 <_vsnprintf+0x640>
  2021d8:	91002ec3 	add	x3, x22, #0xb
  2021dc:	aa1603e0 	mov	x0, x22
  2021e0:	2a0203f8 	mov	w24, w2
  2021e4:	927df076 	and	x22, x3, #0xfffffffffffffff8
  2021e8:	17ffffd9 	b	20214c <_vsnprintf+0x29c>
        if ((*format == 'g')||(*format == 'G')) flags |= FLAGS_ADAPT_EXP;
  2021ec:	121a7801 	and	w1, w0, #0xffffffdf
        if ((*format == 'E')||(*format == 'G')) flags |= FLAGS_UPPERCASE;
  2021f0:	121e7800 	and	w0, w0, #0xfffffffd
        if ((*format == 'g')||(*format == 'G')) flags |= FLAGS_ADAPT_EXP;
  2021f4:	71011c3f 	cmp	w1, #0x47
  2021f8:	321500c1 	orr	w1, w6, #0x800
  2021fc:	1a860026 	csel	w6, w1, w6, eq	// eq = none
        if ((*format == 'E')||(*format == 'G')) flags |= FLAGS_UPPERCASE;
  202200:	7101141f 	cmp	w0, #0x45
  202204:	321b00c0 	orr	w0, w6, #0x20
  202208:	1a860006 	csel	w6, w0, w6, eq	// eq = none
        idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
  20220c:	b94077e0 	ldr	w0, [sp, #116]
  202210:	37f815e0 	tbnz	w0, #31, 2024cc <_vsnprintf+0x61c>
  202214:	91003ec1 	add	x1, x22, #0xf
  202218:	aa1603e0 	mov	x0, x22
  20221c:	927df036 	and	x22, x1, #0xfffffffffffffff8
  202220:	fd400000 	ldr	d0, [x0]
  202224:	aa1c03e2 	mov	x2, x28
  202228:	2a1903e5 	mov	w5, w25
  20222c:	2a1703e4 	mov	w4, w23
  202230:	aa1403e3 	mov	x3, x20
  202234:	aa1503e1 	mov	x1, x21
  202238:	aa1303e0 	mov	x0, x19
  20223c:	97fffe39 	bl	201b20 <_etoa>
  202240:	aa0003fc 	mov	x28, x0
        break;
  202244:	17ffff40 	b	201f44 <_vsnprintf+0x94>
        if (*format == 'F') flags |= FLAGS_UPPERCASE;
  202248:	7101181f 	cmp	w0, #0x46
  20224c:	321b00c0 	orr	w0, w6, #0x20
  202250:	1a860006 	csel	w6, w0, w6, eq	// eq = none
        idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
  202254:	b94077e0 	ldr	w0, [sp, #116]
  202258:	37f81180 	tbnz	w0, #31, 202488 <_vsnprintf+0x5d8>
  20225c:	91003ec1 	add	x1, x22, #0xf
  202260:	aa1603e0 	mov	x0, x22
  202264:	927df036 	and	x22, x1, #0xfffffffffffffff8
  202268:	fd400000 	ldr	d0, [x0]
  20226c:	aa1c03e2 	mov	x2, x28
  202270:	2a1903e5 	mov	w5, w25
  202274:	2a1703e4 	mov	w4, w23
  202278:	aa1403e3 	mov	x3, x20
  20227c:	aa1503e1 	mov	x1, x21
  202280:	aa1303e0 	mov	x0, x19
  202284:	97fffd23 	bl	201710 <_ftoa>
  202288:	aa0003fc 	mov	x28, x0
        break;
  20228c:	17ffff2e 	b	201f44 <_vsnprintf+0x94>
        unsigned int l = 1U;
  202290:	52800020 	mov	w0, #0x1                   	// #1
  202294:	b90083e0 	str	w0, [sp, #128]
        if (!(flags & FLAGS_LEFT)) {
  202298:	121f00c0 	and	w0, w6, #0x2
  20229c:	b90093e0 	str	w0, [sp, #144]
  2022a0:	36081ac6 	tbz	w6, #1, 2025f8 <_vsnprintf+0x748>
        out((char)va_arg(va, int), buffer, idx++, maxlen);
  2022a4:	37f80d38 	tbnz	w24, #31, 202448 <_vsnprintf+0x598>
  2022a8:	91002ec1 	add	x1, x22, #0xb
  2022ac:	aa1603e0 	mov	x0, x22
  2022b0:	927df036 	and	x22, x1, #0xfffffffffffffff8
  2022b4:	39400000 	ldrb	w0, [x0]
  2022b8:	aa1403e3 	mov	x3, x20
  2022bc:	aa1c03e2 	mov	x2, x28
  2022c0:	aa1503e1 	mov	x1, x21
  2022c4:	91000797 	add	x23, x28, #0x1
  2022c8:	d63f0260 	blr	x19
        if (flags & FLAGS_LEFT) {
  2022cc:	b94093e0 	ldr	w0, [sp, #144]
  2022d0:	35001700 	cbnz	w0, 2025b0 <_vsnprintf+0x700>
        break;
  2022d4:	aa1703fc 	mov	x28, x23
  2022d8:	17ffff1b 	b	201f44 <_vsnprintf+0x94>
        out('%', buffer, idx++, maxlen);
  2022dc:	91000780 	add	x0, x28, #0x1
  2022e0:	aa1c03e2 	mov	x2, x28
  2022e4:	aa1403e3 	mov	x3, x20
  2022e8:	aa0003fc 	mov	x28, x0
  2022ec:	aa1503e1 	mov	x1, x21
  2022f0:	528004a0 	mov	w0, #0x25                  	// #37
  2022f4:	d63f0260 	blr	x19
        break;
  2022f8:	17ffff13 	b	201f44 <_vsnprintf+0x94>
        if (*format == 'h') {
  2022fc:	39400740 	ldrb	w0, [x26, #1]
  202300:	7101a01f 	cmp	w0, #0x68
  202304:	54002020 	b.eq	202708 <_vsnprintf+0x858>  // b.none
        flags |= FLAGS_SHORT;
  202308:	321900c6 	orr	w6, w6, #0x80
  20230c:	17ffff42 	b	202014 <_vsnprintf+0x164>
        const char* p = va_arg(va, char*);
  202310:	37f80ad8 	tbnz	w24, #31, 202468 <_vsnprintf+0x5b8>
  202314:	91003ec1 	add	x1, x22, #0xf
  202318:	aa1603e0 	mov	x0, x22
  20231c:	927df036 	and	x22, x1, #0xfffffffffffffff8
  202320:	f940000a 	ldr	x10, [x0]
        unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
  202324:	710002ff 	cmp	w23, #0x0
  202328:	2a1703e3 	mov	w3, w23
  20232c:	da9f1063 	csinv	x3, x3, xzr, ne	// ne = any
  for (s = str; *s && maxsize--; ++s);
  202330:	39400140 	ldrb	w0, [x10]
  202334:	34003500 	cbz	w0, 2029d4 <_vsnprintf+0xb24>
  202338:	8b030143 	add	x3, x10, x3
  20233c:	aa0a03e1 	mov	x1, x10
  202340:	14000003 	b	20234c <_vsnprintf+0x49c>
  202344:	eb03003f 	cmp	x1, x3
  202348:	54000060 	b.eq	202354 <_vsnprintf+0x4a4>  // b.none
  20234c:	38401c22 	ldrb	w2, [x1, #1]!
  202350:	35ffffa2 	cbnz	w2, 202344 <_vsnprintf+0x494>
  return (unsigned int)(s - str);
  202354:	4b0a0021 	sub	w1, w1, w10
  202358:	b90093e1 	str	w1, [sp, #144]
        if (flags & FLAGS_PRECISION) {
  20235c:	121600c1 	and	w1, w6, #0x400
  202360:	b900abe1 	str	w1, [sp, #168]
  202364:	365000a6 	tbz	w6, #10, 202378 <_vsnprintf+0x4c8>
          l = (l < precision ? l : precision);
  202368:	b94093e1 	ldr	w1, [sp, #144]
  20236c:	6b17003f 	cmp	w1, w23
  202370:	1a979021 	csel	w1, w1, w23, ls	// ls = plast
  202374:	b90093e1 	str	w1, [sp, #144]
        if (!(flags & FLAGS_LEFT)) {
  202378:	121f00c1 	and	w1, w6, #0x2
  20237c:	b900afe1 	str	w1, [sp, #172]
  202380:	36081f26 	tbz	w6, #1, 202764 <_vsnprintf+0x8b4>
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  202384:	340002a0 	cbz	w0, 2023d8 <_vsnprintf+0x528>
  202388:	b940abe1 	ldr	w1, [sp, #168]
  20238c:	34001aa1 	cbz	w1, 2026e0 <_vsnprintf+0x830>
  202390:	8b374381 	add	x1, x28, w23, uxtw
            out(' ', buffer, idx++, maxlen);
  202394:	aa1c03e2 	mov	x2, x28
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  202398:	cb1c0157 	sub	x23, x10, x28
  20239c:	f90043e1 	str	x1, [sp, #128]
  2023a0:	14000008 	b	2023c0 <_vsnprintf+0x510>
          out(*(p++), buffer, idx++, maxlen);
  2023a4:	9100045c 	add	x28, x2, #0x1
  2023a8:	aa1403e3 	mov	x3, x20
  2023ac:	aa1503e1 	mov	x1, x21
  2023b0:	d63f0260 	blr	x19
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  2023b4:	387c6ae0 	ldrb	w0, [x23, x28]
  2023b8:	340000c0 	cbz	w0, 2023d0 <_vsnprintf+0x520>
          out(*(p++), buffer, idx++, maxlen);
  2023bc:	aa1c03e2 	mov	x2, x28
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  2023c0:	f94043e1 	ldr	x1, [sp, #128]
  2023c4:	eb02003f 	cmp	x1, x2
  2023c8:	54fffee1 	b.ne	2023a4 <_vsnprintf+0x4f4>  // b.any
  2023cc:	aa0103fc 	mov	x28, x1
        if (flags & FLAGS_LEFT) {
  2023d0:	b940afe0 	ldr	w0, [sp, #172]
  2023d4:	34ffdb80 	cbz	w0, 201f44 <_vsnprintf+0x94>
          while (l++ < width) {
  2023d8:	b94093e1 	ldr	w1, [sp, #144]
  2023dc:	aa1c03f7 	mov	x23, x28
  2023e0:	6b19003f 	cmp	w1, w25
  2023e4:	54ffdb02 	b.cs	201f44 <_vsnprintf+0x94>  // b.hs, b.nlast
  2023e8:	51000720 	sub	w0, w25, #0x1
  2023ec:	91000789 	add	x9, x28, #0x1
  2023f0:	4b010000 	sub	w0, w0, w1
  2023f4:	8b09001c 	add	x28, x0, x9
            out(' ', buffer, idx++, maxlen);
  2023f8:	aa1703e2 	mov	x2, x23
  2023fc:	aa1403e3 	mov	x3, x20
  202400:	910006f7 	add	x23, x23, #0x1
  202404:	aa1503e1 	mov	x1, x21
  202408:	52800400 	mov	w0, #0x20                  	// #32
  20240c:	d63f0260 	blr	x19
          while (l++ < width) {
  202410:	eb1c02ff 	cmp	x23, x28
  202414:	54ffff21 	b.ne	2023f8 <_vsnprintf+0x548>  // b.any
  202418:	17fffecb 	b	201f44 <_vsnprintf+0x94>
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
  20241c:	52800143 	mov	w3, #0xa                   	// #10
  202420:	1b0302e7 	madd	w7, w23, w3, w0
  while (_is_digit(**str)) {
  202424:	38401c40 	ldrb	w0, [x2, #1]!
  return (ch >= '0') && (ch <= '9');
  202428:	5100c001 	sub	w1, w0, #0x30
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
  20242c:	5100c0f7 	sub	w23, w7, #0x30
  while (_is_digit(**str)) {
  202430:	12001c21 	and	w1, w1, #0xff
  202434:	7100243f 	cmp	w1, #0x9
  202438:	54ffff49 	b.ls	202420 <_vsnprintf+0x570>  // b.plast
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
  20243c:	aa0203fa 	mov	x26, x2
  202440:	91000441 	add	x1, x2, #0x1
  202444:	17fffeea 	b	201fec <_vsnprintf+0x13c>
        out((char)va_arg(va, int), buffer, idx++, maxlen);
  202448:	11002301 	add	w1, w24, #0x8
  20244c:	7100003f 	cmp	w1, #0x0
  202450:	540024ed 	b.le	2028ec <_vsnprintf+0xa3c>
  202454:	91002ec2 	add	x2, x22, #0xb
  202458:	aa1603e0 	mov	x0, x22
  20245c:	2a0103f8 	mov	w24, w1
  202460:	927df056 	and	x22, x2, #0xfffffffffffffff8
  202464:	17ffff94 	b	2022b4 <_vsnprintf+0x404>
        const char* p = va_arg(va, char*);
  202468:	11002301 	add	w1, w24, #0x8
  20246c:	7100003f 	cmp	w1, #0x0
  202470:	540021ad 	b.le	2028a4 <_vsnprintf+0x9f4>
  202474:	91003ec2 	add	x2, x22, #0xf
  202478:	aa1603e0 	mov	x0, x22
  20247c:	2a0103f8 	mov	w24, w1
  202480:	927df056 	and	x22, x2, #0xfffffffffffffff8
  202484:	17ffffa7 	b	202320 <_vsnprintf+0x470>
        idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
  202488:	b94077e0 	ldr	w0, [sp, #116]
  20248c:	11004001 	add	w1, w0, #0x10
  202490:	7100003f 	cmp	w1, #0x0
  202494:	5400218d 	b.le	2028c4 <_vsnprintf+0xa14>
  202498:	91003ec2 	add	x2, x22, #0xf
  20249c:	aa1603e0 	mov	x0, x22
  2024a0:	927df056 	and	x22, x2, #0xfffffffffffffff8
  2024a4:	b90077e1 	str	w1, [sp, #116]
  2024a8:	17ffff70 	b	202268 <_vsnprintf+0x3b8>
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
  2024ac:	11002302 	add	w2, w24, #0x8
  2024b0:	7100005f 	cmp	w2, #0x0
  2024b4:	5400200d 	b.le	2028b4 <_vsnprintf+0xa04>
  2024b8:	91003ec3 	add	x3, x22, #0xf
  2024bc:	aa1603e1 	mov	x1, x22
  2024c0:	2a0203f8 	mov	w24, w2
  2024c4:	927df076 	and	x22, x3, #0xfffffffffffffff8
  2024c8:	17fffef6 	b	2020a0 <_vsnprintf+0x1f0>
        idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
  2024cc:	b94077e0 	ldr	w0, [sp, #116]
  2024d0:	11004001 	add	w1, w0, #0x10
  2024d4:	7100003f 	cmp	w1, #0x0
  2024d8:	5400200d 	b.le	2028d8 <_vsnprintf+0xa28>
  2024dc:	91003ec2 	add	x2, x22, #0xf
  2024e0:	aa1603e0 	mov	x0, x22
  2024e4:	927df056 	and	x22, x2, #0xfffffffffffffff8
  2024e8:	b90077e1 	str	w1, [sp, #116]
  2024ec:	17ffff4d 	b	202220 <_vsnprintf+0x370>
      const int w = va_arg(va, int);
  2024f0:	f94047e0 	ldr	x0, [sp, #136]
  2024f4:	8b38c000 	add	x0, x0, w24, sxtw
  2024f8:	2a0203f8 	mov	w24, w2
  2024fc:	17ffff14 	b	20214c <_vsnprintf+0x29c>
        if (*format == 'x' || *format == 'X') {
  202500:	121a7801 	and	w1, w0, #0xffffffdf
  202504:	7101603f 	cmp	w1, #0x58
  202508:	54001080 	b.eq	202718 <_vsnprintf+0x868>  // b.none
        else if (*format == 'b') {
  20250c:	7101881f 	cmp	w0, #0x62
  202510:	54001920 	b.eq	202834 <_vsnprintf+0x984>  // b.none
        if ((*format != 'i') && (*format != 'd')) {
  202514:	52800c81 	mov	w1, #0x64                  	// #100
  202518:	7101a41f 	cmp	w0, #0x69
  20251c:	7a411004 	ccmp	w0, w1, #0x4, ne	// ne = any
          flags &= ~FLAGS_HASH;   // no hash for dec format
  202520:	121b78c6 	and	w6, w6, #0xffffffef
        if ((*format != 'i') && (*format != 'd')) {
  202524:	d2800141 	mov	x1, #0xa                   	// #10
  202528:	54000b41 	b.ne	202690 <_vsnprintf+0x7e0>  // b.any
          flags &= ~FLAGS_ZEROPAD;
  20252c:	f27600df 	tst	x6, #0x400
  202530:	121f78c2 	and	w2, w6, #0xfffffffe
  202534:	1a861046 	csel	w6, w2, w6, ne	// ne = any
        if ((*format == 'i') || (*format == 'd')) {
  202538:	7101a41f 	cmp	w0, #0x69
  20253c:	52800c82 	mov	w2, #0x64                  	// #100
          if (flags & FLAGS_LONG_LONG) {
  202540:	121700c3 	and	w3, w6, #0x200
        if ((*format == 'i') || (*format == 'd')) {
  202544:	7a421004 	ccmp	w0, w2, #0x4, ne	// ne = any
  202548:	54000b81 	b.ne	2026b8 <_vsnprintf+0x808>  // b.any
          if (flags & FLAGS_LONG_LONG) {
  20254c:	35001903 	cbnz	w3, 20286c <_vsnprintf+0x9bc>
          else if (flags & FLAGS_LONG) {
  202550:	37401d66 	tbnz	w6, #8, 2028fc <_vsnprintf+0xa4c>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  202554:	37301626 	tbnz	w6, #6, 202818 <_vsnprintf+0x968>
  202558:	363822e6 	tbz	w6, #7, 2029b4 <_vsnprintf+0xb04>
  20255c:	37f82d58 	tbnz	w24, #31, 202b04 <_vsnprintf+0xc54>
  202560:	91002ec2 	add	x2, x22, #0xb
  202564:	aa1603e0 	mov	x0, x22
  202568:	927df056 	and	x22, x2, #0xfffffffffffffff8
  20256c:	79c00005 	ldrsh	w5, [x0]
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
  202570:	710000bf 	cmp	w5, #0x0
  202574:	5a85a4a4 	cneg	w4, w5, lt	// lt = tstop
  202578:	12003c84 	and	w4, w4, #0xffff
  20257c:	2a1703e7 	mov	w7, w23
  202580:	531f7ca5 	lsr	w5, w5, #31
  202584:	93407c84 	sxtw	x4, w4
  202588:	aa1c03e2 	mov	x2, x28
  20258c:	b9000be6 	str	w6, [sp, #8]
  202590:	aa0103e6 	mov	x6, x1
  202594:	b90003f9 	str	w25, [sp]
            idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
  202598:	aa1403e3 	mov	x3, x20
  20259c:	aa1503e1 	mov	x1, x21
  2025a0:	aa1303e0 	mov	x0, x19
  2025a4:	97fffb7f 	bl	2013a0 <_ntoa_long>
  2025a8:	aa0003fc 	mov	x28, x0
        break;
  2025ac:	17fffe66 	b	201f44 <_vsnprintf+0x94>
          while (l++ < width) {
  2025b0:	b94083e0 	ldr	w0, [sp, #128]
  2025b4:	6b19001f 	cmp	w0, w25
  2025b8:	54ffe8e2 	b.cs	2022d4 <_vsnprintf+0x424>  // b.hs, b.nlast
  2025bc:	51000725 	sub	w5, w25, #0x1
  2025c0:	91000b89 	add	x9, x28, #0x2
  2025c4:	4b0000a0 	sub	w0, w5, w0
  2025c8:	8b090019 	add	x25, x0, x9
  2025cc:	d503201f 	nop
            out(' ', buffer, idx++, maxlen);
  2025d0:	aa1703e2 	mov	x2, x23
  2025d4:	aa1403e3 	mov	x3, x20
  2025d8:	910006f7 	add	x23, x23, #0x1
  2025dc:	aa1503e1 	mov	x1, x21
  2025e0:	52800400 	mov	w0, #0x20                  	// #32
  2025e4:	d63f0260 	blr	x19
          while (l++ < width) {
  2025e8:	eb1902ff 	cmp	x23, x25
  2025ec:	54ffff21 	b.ne	2025d0 <_vsnprintf+0x720>  // b.any
        break;
  2025f0:	aa1703fc 	mov	x28, x23
  2025f4:	17fffe54 	b	201f44 <_vsnprintf+0x94>
          while (l++ < width) {
  2025f8:	7100073f 	cmp	w25, #0x1
  2025fc:	54002409 	b.ls	202a7c <_vsnprintf+0xbcc>  // b.plast
  202600:	91000784 	add	x4, x28, #0x1
  202604:	51000b20 	sub	w0, w25, #0x2
  202608:	8b000097 	add	x23, x4, x0
  20260c:	14000002 	b	202614 <_vsnprintf+0x764>
  202610:	91000484 	add	x4, x4, #0x1
  202614:	f90043e4 	str	x4, [sp, #128]
            out(' ', buffer, idx++, maxlen);
  202618:	aa1c03e2 	mov	x2, x28
  20261c:	aa1403e3 	mov	x3, x20
  202620:	aa1503e1 	mov	x1, x21
  202624:	52800400 	mov	w0, #0x20                  	// #32
  202628:	d63f0260 	blr	x19
  20262c:	f94043e4 	ldr	x4, [sp, #128]
  202630:	aa0403fc 	mov	x28, x4
          while (l++ < width) {
  202634:	eb17009f 	cmp	x4, x23
  202638:	54fffec1 	b.ne	202610 <_vsnprintf+0x760>  // b.any
  20263c:	11000720 	add	w0, w25, #0x1
  202640:	b90083e0 	str	w0, [sp, #128]
        out((char)va_arg(va, int), buffer, idx++, maxlen);
  202644:	36ffe338 	tbz	w24, #31, 2022a8 <_vsnprintf+0x3f8>
  202648:	17ffff80 	b	202448 <_vsnprintf+0x598>
        const int prec = (int)va_arg(va, int);
  20264c:	37f807d8 	tbnz	w24, #31, 202744 <_vsnprintf+0x894>
  202650:	91002ec1 	add	x1, x22, #0xb
  202654:	aa1603e0 	mov	x0, x22
  202658:	927df036 	and	x22, x1, #0xfffffffffffffff8
        precision = prec > 0 ? (unsigned int)prec : 0U;
  20265c:	b9400007 	ldr	w7, [x0]
        format++;
  202660:	91000b5a 	add	x26, x26, #0x2
    switch (*format) {
  202664:	39400340 	ldrb	w0, [x26]
  202668:	91000741 	add	x1, x26, #0x1
        precision = prec > 0 ? (unsigned int)prec : 0U;
  20266c:	710000ff 	cmp	w7, #0x0
  202670:	1a9fa0f7 	csel	w23, w7, wzr, ge	// ge = tcont
        format++;
  202674:	17fffe5e 	b	201fec <_vsnprintf+0x13c>
        if (*format == 'x' || *format == 'X') {
  202678:	121a7801 	and	w1, w0, #0xffffffdf
  20267c:	7101603f 	cmp	w1, #0x58
  202680:	540005c0 	b.eq	202738 <_vsnprintf+0x888>  // b.none
        else if (*format == 'o') {
  202684:	7101bc1f 	cmp	w0, #0x6f
  202688:	d2800101 	mov	x1, #0x8                   	// #8
  20268c:	54fff441 	b.ne	202514 <_vsnprintf+0x664>  // b.any
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
  202690:	121c74c6 	and	w6, w6, #0xfffffff3
  202694:	d503201f 	nop
          flags &= ~FLAGS_ZEROPAD;
  202698:	f27600df 	tst	x6, #0x400
  20269c:	121f78c2 	and	w2, w6, #0xfffffffe
  2026a0:	1a861046 	csel	w6, w2, w6, ne	// ne = any
        if ((*format == 'i') || (*format == 'd')) {
  2026a4:	7101a41f 	cmp	w0, #0x69
  2026a8:	52800c82 	mov	w2, #0x64                  	// #100
          if (flags & FLAGS_LONG_LONG) {
  2026ac:	121700c3 	and	w3, w6, #0x200
        if ((*format == 'i') || (*format == 'd')) {
  2026b0:	7a421004 	ccmp	w0, w2, #0x4, ne	// ne = any
  2026b4:	54fff4c0 	b.eq	20254c <_vsnprintf+0x69c>  // b.none
          if (flags & FLAGS_LONG_LONG) {
  2026b8:	35000c43 	cbnz	w3, 202840 <_vsnprintf+0x990>
          else if (flags & FLAGS_LONG) {
  2026bc:	374013c6 	tbnz	w6, #8, 202934 <_vsnprintf+0xa84>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  2026c0:	37300926 	tbnz	w6, #6, 2027e4 <_vsnprintf+0x934>
  2026c4:	363816c6 	tbz	w6, #7, 20299c <_vsnprintf+0xaec>
  2026c8:	37f822f8 	tbnz	w24, #31, 202b24 <_vsnprintf+0xc74>
  2026cc:	aa1603e0 	mov	x0, x22
  2026d0:	91002ec2 	add	x2, x22, #0xb
  2026d4:	927df056 	and	x22, x2, #0xfffffffffffffff8
  2026d8:	79400004 	ldrh	w4, [x0]
  2026dc:	14000047 	b	2027f8 <_vsnprintf+0x948>
  2026e0:	cb1c0157 	sub	x23, x10, x28
  2026e4:	d503201f 	nop
          out(*(p++), buffer, idx++, maxlen);
  2026e8:	aa1c03e2 	mov	x2, x28
  2026ec:	9100079c 	add	x28, x28, #0x1
  2026f0:	aa1403e3 	mov	x3, x20
  2026f4:	aa1503e1 	mov	x1, x21
  2026f8:	d63f0260 	blr	x19
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  2026fc:	387c6ae0 	ldrb	w0, [x23, x28]
  202700:	35ffff40 	cbnz	w0, 2026e8 <_vsnprintf+0x838>
  202704:	17ffff33 	b	2023d0 <_vsnprintf+0x520>
    switch (*format) {
  202708:	39400b40 	ldrb	w0, [x26, #2]
          flags |= FLAGS_CHAR;
  20270c:	321a04c6 	orr	w6, w6, #0xc0
          format++;
  202710:	91000b42 	add	x2, x26, #0x2
  202714:	17fffe40 	b	202014 <_vsnprintf+0x164>
        if (*format == 'X') {
  202718:	7101601f 	cmp	w0, #0x58
  20271c:	540000e1 	b.ne	202738 <_vsnprintf+0x888>  // b.any
          flags |= FLAGS_UPPERCASE;
  202720:	321b00c6 	orr	w6, w6, #0x20
  202724:	d2800201 	mov	x1, #0x10                  	// #16
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
  202728:	121c74c6 	and	w6, w6, #0xfffffff3
  20272c:	17ffffdb 	b	202698 <_vsnprintf+0x7e8>
  while (*format)
  202730:	52800016 	mov	w22, #0x0                   	// #0
  202734:	17fffe6d 	b	2020e8 <_vsnprintf+0x238>
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
  202738:	121c74c6 	and	w6, w6, #0xfffffff3
        if (*format == 'X') {
  20273c:	d2800201 	mov	x1, #0x10                  	// #16
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
  202740:	17ffffd6 	b	202698 <_vsnprintf+0x7e8>
        const int prec = (int)va_arg(va, int);
  202744:	11002301 	add	w1, w24, #0x8
  202748:	7100003f 	cmp	w1, #0x0
  20274c:	5400044d 	b.le	2027d4 <_vsnprintf+0x924>
  202750:	91002ec2 	add	x2, x22, #0xb
  202754:	aa1603e0 	mov	x0, x22
  202758:	2a0103f8 	mov	w24, w1
  20275c:	927df056 	and	x22, x2, #0xfffffffffffffff8
  202760:	17ffffbf 	b	20265c <_vsnprintf+0x7ac>
          while (l++ < width) {
  202764:	b94093e1 	ldr	w1, [sp, #144]
  202768:	6b19003f 	cmp	w1, w25
  20276c:	54001902 	b.cs	202a8c <_vsnprintf+0xbdc>  // b.hs, b.nlast
  202770:	51000720 	sub	w0, w25, #0x1
  202774:	91000784 	add	x4, x28, #0x1
  202778:	4b010000 	sub	w0, w0, w1
  20277c:	8b040000 	add	x0, x0, x4
  202780:	f90053e0 	str	x0, [sp, #160]
  202784:	14000002 	b	20278c <_vsnprintf+0x8dc>
  202788:	91000484 	add	x4, x4, #0x1
  20278c:	f90043ea 	str	x10, [sp, #128]
            out(' ', buffer, idx++, maxlen);
  202790:	aa1c03e2 	mov	x2, x28
  202794:	f9004be4 	str	x4, [sp, #144]
  202798:	52800400 	mov	w0, #0x20                  	// #32
  20279c:	aa1403e3 	mov	x3, x20
  2027a0:	aa1503e1 	mov	x1, x21
  2027a4:	d63f0260 	blr	x19
  2027a8:	f9404be4 	ldr	x4, [sp, #144]
          while (l++ < width) {
  2027ac:	f94053e0 	ldr	x0, [sp, #160]
            out(' ', buffer, idx++, maxlen);
  2027b0:	aa0403fc 	mov	x28, x4
          while (l++ < width) {
  2027b4:	f94043ea 	ldr	x10, [sp, #128]
  2027b8:	eb00009f 	cmp	x4, x0
  2027bc:	54fffe61 	b.ne	202788 <_vsnprintf+0x8d8>  // b.any
  2027c0:	11000720 	add	w0, w25, #0x1
  2027c4:	b90093e0 	str	w0, [sp, #144]
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  2027c8:	39400140 	ldrb	w0, [x10]
  2027cc:	35ffdde0 	cbnz	w0, 202388 <_vsnprintf+0x4d8>
  2027d0:	17fffddd 	b	201f44 <_vsnprintf+0x94>
        const int prec = (int)va_arg(va, int);
  2027d4:	f94047e0 	ldr	x0, [sp, #136]
  2027d8:	8b38c000 	add	x0, x0, w24, sxtw
  2027dc:	2a0103f8 	mov	w24, w1
  2027e0:	17ffff9f 	b	20265c <_vsnprintf+0x7ac>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  2027e4:	37f812d8 	tbnz	w24, #31, 202a3c <_vsnprintf+0xb8c>
  2027e8:	91002ec2 	add	x2, x22, #0xb
  2027ec:	aa1603e0 	mov	x0, x22
  2027f0:	927df056 	and	x22, x2, #0xfffffffffffffff8
  2027f4:	39400004 	ldrb	w4, [x0]
            idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
  2027f8:	2a1703e7 	mov	w7, w23
  2027fc:	2a0403e4 	mov	w4, w4
  202800:	b9000be6 	str	w6, [sp, #8]
  202804:	aa0103e6 	mov	x6, x1
  202808:	b90003f9 	str	w25, [sp]
  20280c:	aa1c03e2 	mov	x2, x28
  202810:	52800005 	mov	w5, #0x0                   	// #0
  202814:	17ffff61 	b	202598 <_vsnprintf+0x6e8>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  202818:	37f80e38 	tbnz	w24, #31, 2029dc <_vsnprintf+0xb2c>
  20281c:	91002ec2 	add	x2, x22, #0xb
  202820:	aa1603e0 	mov	x0, x22
  202824:	927df056 	and	x22, x2, #0xfffffffffffffff8
  202828:	39400005 	ldrb	w5, [x0]
  20282c:	2a0503e4 	mov	w4, w5
  202830:	17ffff53 	b	20257c <_vsnprintf+0x6cc>
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
  202834:	121c74c6 	and	w6, w6, #0xfffffff3
  202838:	d2800041 	mov	x1, #0x2                   	// #2
  20283c:	17ffff97 	b	202698 <_vsnprintf+0x7e8>
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
  202840:	37f808f8 	tbnz	w24, #31, 20295c <_vsnprintf+0xaac>
  202844:	91003ec2 	add	x2, x22, #0xf
  202848:	aa1603e0 	mov	x0, x22
  20284c:	927df056 	and	x22, x2, #0xfffffffffffffff8
  202850:	f9400004 	ldr	x4, [x0]
  202854:	2a1703e7 	mov	w7, w23
  202858:	aa1c03e2 	mov	x2, x28
  20285c:	b90003f9 	str	w25, [sp]
  202860:	b9000be6 	str	w6, [sp, #8]
  202864:	aa0103e6 	mov	x6, x1
  202868:	17fffe15 	b	2020bc <_vsnprintf+0x20c>
            const long long value = va_arg(va, long long);
  20286c:	37f80898 	tbnz	w24, #31, 20297c <_vsnprintf+0xacc>
  202870:	91003ec2 	add	x2, x22, #0xf
  202874:	aa1603e0 	mov	x0, x22
  202878:	927df056 	and	x22, x2, #0xfffffffffffffff8
  20287c:	f9400005 	ldr	x5, [x0]
            idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
  202880:	2a1703e7 	mov	w7, w23
  202884:	aa1c03e2 	mov	x2, x28
  202888:	b90003f9 	str	w25, [sp]
  20288c:	f10000bf 	cmp	x5, #0x0
  202890:	b9000be6 	str	w6, [sp, #8]
  202894:	da85a4a4 	cneg	x4, x5, lt	// lt = tstop
  202898:	aa0103e6 	mov	x6, x1
  20289c:	d37ffca5 	lsr	x5, x5, #63
  2028a0:	17fffe08 	b	2020c0 <_vsnprintf+0x210>
        const char* p = va_arg(va, char*);
  2028a4:	f94047e0 	ldr	x0, [sp, #136]
  2028a8:	8b38c000 	add	x0, x0, w24, sxtw
  2028ac:	2a0103f8 	mov	w24, w1
  2028b0:	17fffe9c 	b	202320 <_vsnprintf+0x470>
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
  2028b4:	f94047e1 	ldr	x1, [sp, #136]
  2028b8:	8b38c021 	add	x1, x1, w24, sxtw
  2028bc:	2a0203f8 	mov	w24, w2
  2028c0:	17fffdf8 	b	2020a0 <_vsnprintf+0x1f0>
        idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
  2028c4:	f9404fe2 	ldr	x2, [sp, #152]
  2028c8:	b94077e0 	ldr	w0, [sp, #116]
  2028cc:	b90077e1 	str	w1, [sp, #116]
  2028d0:	8b20c040 	add	x0, x2, w0, sxtw
  2028d4:	17fffe65 	b	202268 <_vsnprintf+0x3b8>
        idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
  2028d8:	f9404fe2 	ldr	x2, [sp, #152]
  2028dc:	b94077e0 	ldr	w0, [sp, #116]
  2028e0:	b90077e1 	str	w1, [sp, #116]
  2028e4:	8b20c040 	add	x0, x2, w0, sxtw
  2028e8:	17fffe4e 	b	202220 <_vsnprintf+0x370>
        out((char)va_arg(va, int), buffer, idx++, maxlen);
  2028ec:	f94047e0 	ldr	x0, [sp, #136]
  2028f0:	8b38c000 	add	x0, x0, w24, sxtw
  2028f4:	2a0103f8 	mov	w24, w1
  2028f8:	17fffe6f 	b	2022b4 <_vsnprintf+0x404>
            const long value = va_arg(va, long);
  2028fc:	37f80818 	tbnz	w24, #31, 2029fc <_vsnprintf+0xb4c>
  202900:	91003ec2 	add	x2, x22, #0xf
  202904:	aa1603e0 	mov	x0, x22
  202908:	927df056 	and	x22, x2, #0xfffffffffffffff8
  20290c:	f9400005 	ldr	x5, [x0]
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
  202910:	2a1703e7 	mov	w7, w23
  202914:	aa1c03e2 	mov	x2, x28
  202918:	b90003f9 	str	w25, [sp]
  20291c:	f10000bf 	cmp	x5, #0x0
  202920:	b9000be6 	str	w6, [sp, #8]
  202924:	da85a4a4 	cneg	x4, x5, lt	// lt = tstop
  202928:	aa0103e6 	mov	x6, x1
  20292c:	d37ffca5 	lsr	x5, x5, #63
  202930:	17ffff1a 	b	202598 <_vsnprintf+0x6e8>
            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
  202934:	37f80758 	tbnz	w24, #31, 202a1c <_vsnprintf+0xb6c>
  202938:	91003ec2 	add	x2, x22, #0xf
  20293c:	aa1603e0 	mov	x0, x22
  202940:	927df056 	and	x22, x2, #0xfffffffffffffff8
  202944:	f9400004 	ldr	x4, [x0]
  202948:	2a1703e7 	mov	w7, w23
  20294c:	b90003f9 	str	w25, [sp]
  202950:	b9000be6 	str	w6, [sp, #8]
  202954:	aa0103e6 	mov	x6, x1
  202958:	17ffffad 	b	20280c <_vsnprintf+0x95c>
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
  20295c:	11002302 	add	w2, w24, #0x8
  202960:	7100005f 	cmp	w2, #0x0
  202964:	540007cd 	b.le	202a5c <_vsnprintf+0xbac>
  202968:	91003ec3 	add	x3, x22, #0xf
  20296c:	aa1603e0 	mov	x0, x22
  202970:	2a0203f8 	mov	w24, w2
  202974:	927df076 	and	x22, x3, #0xfffffffffffffff8
  202978:	17ffffb6 	b	202850 <_vsnprintf+0x9a0>
            const long long value = va_arg(va, long long);
  20297c:	11002302 	add	w2, w24, #0x8
  202980:	7100005f 	cmp	w2, #0x0
  202984:	5400074d 	b.le	202a6c <_vsnprintf+0xbbc>
  202988:	91003ec3 	add	x3, x22, #0xf
  20298c:	aa1603e0 	mov	x0, x22
  202990:	2a0203f8 	mov	w24, w2
  202994:	927df076 	and	x22, x3, #0xfffffffffffffff8
  202998:	17ffffb9 	b	20287c <_vsnprintf+0x9cc>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  20299c:	37f808b8 	tbnz	w24, #31, 202ab0 <_vsnprintf+0xc00>
  2029a0:	aa1603e0 	mov	x0, x22
  2029a4:	91002ec2 	add	x2, x22, #0xb
  2029a8:	927df056 	and	x22, x2, #0xfffffffffffffff8
  2029ac:	b9400004 	ldr	w4, [x0]
  2029b0:	17ffff92 	b	2027f8 <_vsnprintf+0x948>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  2029b4:	37f80998 	tbnz	w24, #31, 202ae4 <_vsnprintf+0xc34>
  2029b8:	91002ec2 	add	x2, x22, #0xb
  2029bc:	aa1603e0 	mov	x0, x22
  2029c0:	927df056 	and	x22, x2, #0xfffffffffffffff8
  2029c4:	b9400005 	ldr	w5, [x0]
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
  2029c8:	710000bf 	cmp	w5, #0x0
  2029cc:	5a85a4a4 	cneg	w4, w5, lt	// lt = tstop
  2029d0:	17fffeeb 	b	20257c <_vsnprintf+0x6cc>
  for (s = str; *s && maxsize--; ++s);
  2029d4:	b90093ff 	str	wzr, [sp, #144]
  2029d8:	17fffe61 	b	20235c <_vsnprintf+0x4ac>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  2029dc:	11002302 	add	w2, w24, #0x8
  2029e0:	7100005f 	cmp	w2, #0x0
  2029e4:	5400078d 	b.le	202ad4 <_vsnprintf+0xc24>
  2029e8:	91002ec3 	add	x3, x22, #0xb
  2029ec:	aa1603e0 	mov	x0, x22
  2029f0:	2a0203f8 	mov	w24, w2
  2029f4:	927df076 	and	x22, x3, #0xfffffffffffffff8
  2029f8:	17ffff8c 	b	202828 <_vsnprintf+0x978>
            const long value = va_arg(va, long);
  2029fc:	11002302 	add	w2, w24, #0x8
  202a00:	7100005f 	cmp	w2, #0x0
  202a04:	54000aad 	b.le	202b58 <_vsnprintf+0xca8>
  202a08:	91003ec3 	add	x3, x22, #0xf
  202a0c:	aa1603e0 	mov	x0, x22
  202a10:	2a0203f8 	mov	w24, w2
  202a14:	927df076 	and	x22, x3, #0xfffffffffffffff8
  202a18:	17ffffbd 	b	20290c <_vsnprintf+0xa5c>
            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
  202a1c:	11002302 	add	w2, w24, #0x8
  202a20:	7100005f 	cmp	w2, #0x0
  202a24:	540003ed 	b.le	202aa0 <_vsnprintf+0xbf0>
  202a28:	91003ec3 	add	x3, x22, #0xf
  202a2c:	aa1603e0 	mov	x0, x22
  202a30:	2a0203f8 	mov	w24, w2
  202a34:	927df076 	and	x22, x3, #0xfffffffffffffff8
  202a38:	17ffffc3 	b	202944 <_vsnprintf+0xa94>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  202a3c:	11002302 	add	w2, w24, #0x8
  202a40:	7100005f 	cmp	w2, #0x0
  202a44:	5400082d 	b.le	202b48 <_vsnprintf+0xc98>
  202a48:	91002ec3 	add	x3, x22, #0xb
  202a4c:	aa1603e0 	mov	x0, x22
  202a50:	2a0203f8 	mov	w24, w2
  202a54:	927df076 	and	x22, x3, #0xfffffffffffffff8
  202a58:	17ffff67 	b	2027f4 <_vsnprintf+0x944>
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
  202a5c:	f94047e0 	ldr	x0, [sp, #136]
  202a60:	8b38c000 	add	x0, x0, w24, sxtw
  202a64:	2a0203f8 	mov	w24, w2
  202a68:	17ffff7a 	b	202850 <_vsnprintf+0x9a0>
            const long long value = va_arg(va, long long);
  202a6c:	f94047e0 	ldr	x0, [sp, #136]
  202a70:	8b38c000 	add	x0, x0, w24, sxtw
  202a74:	2a0203f8 	mov	w24, w2
  202a78:	17ffff81 	b	20287c <_vsnprintf+0x9cc>
          while (l++ < width) {
  202a7c:	52800040 	mov	w0, #0x2                   	// #2
  202a80:	b90083e0 	str	w0, [sp, #128]
        out((char)va_arg(va, int), buffer, idx++, maxlen);
  202a84:	36ffc138 	tbz	w24, #31, 2022a8 <_vsnprintf+0x3f8>
  202a88:	17fffe70 	b	202448 <_vsnprintf+0x598>
          while (l++ < width) {
  202a8c:	b94093e1 	ldr	w1, [sp, #144]
  202a90:	11000421 	add	w1, w1, #0x1
  202a94:	b90093e1 	str	w1, [sp, #144]
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  202a98:	35ffc780 	cbnz	w0, 202388 <_vsnprintf+0x4d8>
  202a9c:	17fffd2a 	b	201f44 <_vsnprintf+0x94>
            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
  202aa0:	f94047e0 	ldr	x0, [sp, #136]
  202aa4:	8b38c000 	add	x0, x0, w24, sxtw
  202aa8:	2a0203f8 	mov	w24, w2
  202aac:	17ffffa6 	b	202944 <_vsnprintf+0xa94>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  202ab0:	11002302 	add	w2, w24, #0x8
  202ab4:	7100005f 	cmp	w2, #0x0
  202ab8:	5400060d 	b.le	202b78 <_vsnprintf+0xcc8>
  202abc:	aa1603e0 	mov	x0, x22
  202ac0:	91002ec3 	add	x3, x22, #0xb
  202ac4:	2a0203f8 	mov	w24, w2
  202ac8:	927df076 	and	x22, x3, #0xfffffffffffffff8
  202acc:	b9400004 	ldr	w4, [x0]
  202ad0:	17ffff4a 	b	2027f8 <_vsnprintf+0x948>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  202ad4:	f94047e0 	ldr	x0, [sp, #136]
  202ad8:	8b38c000 	add	x0, x0, w24, sxtw
  202adc:	2a0203f8 	mov	w24, w2
  202ae0:	17ffff52 	b	202828 <_vsnprintf+0x978>
  202ae4:	11002302 	add	w2, w24, #0x8
  202ae8:	7100005f 	cmp	w2, #0x0
  202aec:	5400050d 	b.le	202b8c <_vsnprintf+0xcdc>
  202af0:	91002ec3 	add	x3, x22, #0xb
  202af4:	aa1603e0 	mov	x0, x22
  202af8:	2a0203f8 	mov	w24, w2
  202afc:	927df076 	and	x22, x3, #0xfffffffffffffff8
  202b00:	17ffffb1 	b	2029c4 <_vsnprintf+0xb14>
  202b04:	11002302 	add	w2, w24, #0x8
  202b08:	7100005f 	cmp	w2, #0x0
  202b0c:	540002ed 	b.le	202b68 <_vsnprintf+0xcb8>
  202b10:	91002ec3 	add	x3, x22, #0xb
  202b14:	aa1603e0 	mov	x0, x22
  202b18:	2a0203f8 	mov	w24, w2
  202b1c:	927df076 	and	x22, x3, #0xfffffffffffffff8
  202b20:	17fffe93 	b	20256c <_vsnprintf+0x6bc>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  202b24:	11002302 	add	w2, w24, #0x8
  202b28:	7100005f 	cmp	w2, #0x0
  202b2c:	5400038d 	b.le	202b9c <_vsnprintf+0xcec>
  202b30:	aa1603e0 	mov	x0, x22
  202b34:	91002ec3 	add	x3, x22, #0xb
  202b38:	2a0203f8 	mov	w24, w2
  202b3c:	927df076 	and	x22, x3, #0xfffffffffffffff8
  202b40:	79400004 	ldrh	w4, [x0]
  202b44:	17ffff2d 	b	2027f8 <_vsnprintf+0x948>
  202b48:	f94047e0 	ldr	x0, [sp, #136]
  202b4c:	8b38c000 	add	x0, x0, w24, sxtw
  202b50:	2a0203f8 	mov	w24, w2
  202b54:	17ffff28 	b	2027f4 <_vsnprintf+0x944>
            const long value = va_arg(va, long);
  202b58:	f94047e0 	ldr	x0, [sp, #136]
  202b5c:	8b38c000 	add	x0, x0, w24, sxtw
  202b60:	2a0203f8 	mov	w24, w2
  202b64:	17ffff6a 	b	20290c <_vsnprintf+0xa5c>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  202b68:	f94047e0 	ldr	x0, [sp, #136]
  202b6c:	8b38c000 	add	x0, x0, w24, sxtw
  202b70:	2a0203f8 	mov	w24, w2
  202b74:	17fffe7e 	b	20256c <_vsnprintf+0x6bc>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  202b78:	f94047e0 	ldr	x0, [sp, #136]
  202b7c:	8b38c000 	add	x0, x0, w24, sxtw
  202b80:	2a0203f8 	mov	w24, w2
  202b84:	b9400004 	ldr	w4, [x0]
  202b88:	17ffff1c 	b	2027f8 <_vsnprintf+0x948>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  202b8c:	f94047e0 	ldr	x0, [sp, #136]
  202b90:	8b38c000 	add	x0, x0, w24, sxtw
  202b94:	2a0203f8 	mov	w24, w2
  202b98:	17ffff8b 	b	2029c4 <_vsnprintf+0xb14>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  202b9c:	f94047e0 	ldr	x0, [sp, #136]
  202ba0:	8b38c000 	add	x0, x0, w24, sxtw
  202ba4:	2a0203f8 	mov	w24, w2
  202ba8:	79400004 	ldrh	w4, [x0]
  202bac:	17ffff13 	b	2027f8 <_vsnprintf+0x948>
  return (ch >= '0') && (ch <= '9');
  202bb0:	5100c002 	sub	w2, w0, #0x30
  unsigned int i = 0U;
  202bb4:	52800019 	mov	w25, #0x0                   	// #0
    if (_is_digit(*format)) {
  202bb8:	12001c42 	and	w2, w2, #0xff
  202bbc:	7100245f 	cmp	w2, #0x9
  202bc0:	54ffad48 	b.hi	202168 <_vsnprintf+0x2b8>  // b.pmore
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
  202bc4:	52800143 	mov	w3, #0xa                   	// #10
  202bc8:	1b030325 	madd	w5, w25, w3, w0
  while (_is_digit(**str)) {
  202bcc:	39400020 	ldrb	w0, [x1]
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
  202bd0:	aa0103fa 	mov	x26, x1
  202bd4:	91000421 	add	x1, x1, #0x1
  return (ch >= '0') && (ch <= '9');
  202bd8:	5100c002 	sub	w2, w0, #0x30
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
  202bdc:	5100c0b9 	sub	w25, w5, #0x30
  while (_is_digit(**str)) {
  202be0:	12001c42 	and	w2, w2, #0xff
  202be4:	7100245f 	cmp	w2, #0x9
  202be8:	54ffff09 	b.ls	202bc8 <_vsnprintf+0xd18>  // b.plast
  202bec:	17fffd5f 	b	202168 <_vsnprintf+0x2b8>

0000000000202bf0 <sddf_printf_>:


///////////////////////////////////////////////////////////////////////////////

int sddf_printf_(const char* format, ...)
{
  202bf0:	a9ae7bfd 	stp	x29, x30, [sp, #-288]!
  va_list va;
  va_start(va, format);
  202bf4:	12800fe9 	mov	w9, #0xffffff80            	// #-128
  202bf8:	128006ea 	mov	w10, #0xffffffc8            	// #-56
{
  202bfc:	910003fd 	mov	x29, sp
  va_start(va, format);
  202c00:	910383eb 	add	x11, sp, #0xe0
  202c04:	910483e8 	add	x8, sp, #0x120
  202c08:	a90423e8 	stp	x8, x8, [sp, #64]
{
  202c0c:	aa0003e8 	mov	x8, x0
  char buffer[1];
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  202c10:	f0ffffe0 	adrp	x0, 201000 <memcpy+0x100>
  202c14:	911b8000 	add	x0, x0, #0x6e0
  va_start(va, format);
  202c18:	f9002beb 	str	x11, [sp, #80]
  202c1c:	290b27ea 	stp	w10, w9, [sp, #88]
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  202c20:	a94437ec 	ldp	x12, x13, [sp, #64]
  202c24:	a90137ec 	stp	x12, x13, [sp, #16]
  202c28:	a9452fea 	ldp	x10, x11, [sp, #80]
  202c2c:	a9022fea 	stp	x10, x11, [sp, #32]
{
  202c30:	3d801be0 	str	q0, [sp, #96]
  202c34:	3d801fe1 	str	q1, [sp, #112]
  202c38:	3d8023e2 	str	q2, [sp, #128]
  202c3c:	3d8027e3 	str	q3, [sp, #144]
  202c40:	3d802be4 	str	q4, [sp, #160]
  202c44:	3d802fe5 	str	q5, [sp, #176]
  202c48:	3d8033e6 	str	q6, [sp, #192]
  202c4c:	3d8037e7 	str	q7, [sp, #208]
  202c50:	a90e8be1 	stp	x1, x2, [sp, #232]
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  202c54:	9100e3e1 	add	x1, sp, #0x38
  202c58:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
{
  202c5c:	a90f93e3 	stp	x3, x4, [sp, #248]
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  202c60:	910043e4 	add	x4, sp, #0x10
  202c64:	aa0803e3 	mov	x3, x8
{
  202c68:	a9109be5 	stp	x5, x6, [sp, #264]
  202c6c:	f9008fe7 	str	x7, [sp, #280]
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  202c70:	97fffc90 	bl	201eb0 <_vsnprintf>
  va_end(va);
  return ret;
}
  202c74:	a8d27bfd 	ldp	x29, x30, [sp], #288
  202c78:	d65f03c0 	ret
  202c7c:	d503201f 	nop

0000000000202c80 <sddf_sprintf_>:


int sddf_sprintf_(char* buffer, const char* format, ...)
{
  202c80:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
  va_list va;
  va_start(va, format);
  202c84:	12800fe9 	mov	w9, #0xffffff80            	// #-128
  202c88:	128005ea 	mov	w10, #0xffffffd0            	// #-48
{
  202c8c:	910003fd 	mov	x29, sp
  va_start(va, format);
  202c90:	910343e8 	add	x8, sp, #0xd0
  202c94:	910403eb 	add	x11, sp, #0x100
  202c98:	a9032feb 	stp	x11, x11, [sp, #48]
  202c9c:	f90023e8 	str	x8, [sp, #64]
{
  202ca0:	aa0103e8 	mov	x8, x1
  va_start(va, format);
  202ca4:	290927ea 	stp	w10, w9, [sp, #72]
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
  202ca8:	aa0003e1 	mov	x1, x0
  202cac:	a94337ec 	ldp	x12, x13, [sp, #48]
  202cb0:	f0ffffe0 	adrp	x0, 201000 <memcpy+0x100>
  202cb4:	a9442fea 	ldp	x10, x11, [sp, #64]
  202cb8:	91098000 	add	x0, x0, #0x260
  202cbc:	a90137ec 	stp	x12, x13, [sp, #16]
  202cc0:	a9022fea 	stp	x10, x11, [sp, #32]
{
  202cc4:	3d8017e0 	str	q0, [sp, #80]
  202cc8:	3d801be1 	str	q1, [sp, #96]
  202ccc:	3d801fe2 	str	q2, [sp, #112]
  202cd0:	3d8023e3 	str	q3, [sp, #128]
  202cd4:	3d8027e4 	str	q4, [sp, #144]
  202cd8:	3d802be5 	str	q5, [sp, #160]
  202cdc:	3d802fe6 	str	q6, [sp, #176]
  202ce0:	3d8033e7 	str	q7, [sp, #192]
  202ce4:	a90d0fe2 	stp	x2, x3, [sp, #208]
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
  202ce8:	aa0803e3 	mov	x3, x8
  202cec:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
{
  202cf0:	a90e17e4 	stp	x4, x5, [sp, #224]
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
  202cf4:	910043e4 	add	x4, sp, #0x10
{
  202cf8:	a90f1fe6 	stp	x6, x7, [sp, #240]
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
  202cfc:	97fffc6d 	bl	201eb0 <_vsnprintf>
  va_end(va);
  return ret;
}
  202d00:	a8d07bfd 	ldp	x29, x30, [sp], #256
  202d04:	d65f03c0 	ret
  202d08:	d503201f 	nop
  202d0c:	d503201f 	nop

0000000000202d10 <sddf_snprintf_>:


int sddf_snprintf_(char* buffer, size_t count, const char* format, ...)
{
  202d10:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
  va_list va;
  va_start(va, format);
  202d14:	128004e8 	mov	w8, #0xffffffd8            	// #-40
  202d18:	12800fea 	mov	w10, #0xffffff80            	// #-128
{
  202d1c:	910003fd 	mov	x29, sp
  va_start(va, format);
  202d20:	910343e9 	add	x9, sp, #0xd0
  202d24:	910403eb 	add	x11, sp, #0x100
  202d28:	a9032feb 	stp	x11, x11, [sp, #48]
  202d2c:	f90023e9 	str	x9, [sp, #64]
{
  202d30:	aa0103e9 	mov	x9, x1
  va_start(va, format);
  202d34:	29092be8 	stp	w8, w10, [sp, #72]
{
  202d38:	aa0203e8 	mov	x8, x2
  const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
  202d3c:	a94337ec 	ldp	x12, x13, [sp, #48]
  202d40:	aa0003e1 	mov	x1, x0
  202d44:	a9442fea 	ldp	x10, x11, [sp, #64]
  202d48:	aa0903e2 	mov	x2, x9
  202d4c:	f0ffffe0 	adrp	x0, 201000 <memcpy+0x100>
  202d50:	91098000 	add	x0, x0, #0x260
  202d54:	a90137ec 	stp	x12, x13, [sp, #16]
  202d58:	a9022fea 	stp	x10, x11, [sp, #32]
{
  202d5c:	3d8017e0 	str	q0, [sp, #80]
  202d60:	3d801be1 	str	q1, [sp, #96]
  202d64:	3d801fe2 	str	q2, [sp, #112]
  202d68:	3d8023e3 	str	q3, [sp, #128]
  202d6c:	3d8027e4 	str	q4, [sp, #144]
  202d70:	3d802be5 	str	q5, [sp, #160]
  202d74:	3d802fe6 	str	q6, [sp, #176]
  202d78:	3d8033e7 	str	q7, [sp, #192]
  202d7c:	a90d93e3 	stp	x3, x4, [sp, #216]
  const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
  202d80:	910043e4 	add	x4, sp, #0x10
  202d84:	aa0803e3 	mov	x3, x8
{
  202d88:	a90e9be5 	stp	x5, x6, [sp, #232]
  202d8c:	f9007fe7 	str	x7, [sp, #248]
  const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
  202d90:	97fffc48 	bl	201eb0 <_vsnprintf>
  va_end(va);
  return ret;
}
  202d94:	a8d07bfd 	ldp	x29, x30, [sp], #256
  202d98:	d65f03c0 	ret
  202d9c:	d503201f 	nop

0000000000202da0 <sddf_vprintf_>:


int sddf_vprintf_(const char* format, va_list va)
{
  202da0:	aa0103e5 	mov	x5, x1
  202da4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  char buffer[1];
  return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  202da8:	aa0003e3 	mov	x3, x0
{
  202dac:	910003fd 	mov	x29, sp
  return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  202db0:	a9401ca6 	ldp	x6, x7, [x5]
  202db4:	f9000be6 	str	x6, [sp, #16]
  202db8:	910043e4 	add	x4, sp, #0x10
  202dbc:	9100e3e1 	add	x1, sp, #0x38
  202dc0:	f94008a6 	ldr	x6, [x5, #16]
  202dc4:	f9000fe7 	str	x7, [sp, #24]
  202dc8:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
  202dcc:	f0ffffe0 	adrp	x0, 201000 <memcpy+0x100>
  202dd0:	f9400ca5 	ldr	x5, [x5, #24]
  202dd4:	911b8000 	add	x0, x0, #0x6e0
  202dd8:	a90217e6 	stp	x6, x5, [sp, #32]
  202ddc:	97fffc35 	bl	201eb0 <_vsnprintf>
}
  202de0:	a8c47bfd 	ldp	x29, x30, [sp], #64
  202de4:	d65f03c0 	ret
  202de8:	d503201f 	nop
  202dec:	d503201f 	nop

0000000000202df0 <sddf_vsnprintf_>:


int sddf_vsnprintf_(char* buffer, size_t count, const char* format, va_list va)
{
  202df0:	aa0303e5 	mov	x5, x3
  202df4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  202df8:	aa0103e4 	mov	x4, x1
  202dfc:	910003fd 	mov	x29, sp
  return _vsnprintf(_out_buffer, buffer, count, format, va);
  202e00:	a9401ca8 	ldp	x8, x7, [x5]
  202e04:	aa0003e1 	mov	x1, x0
  202e08:	a94114a6 	ldp	x6, x5, [x5, #16]
  202e0c:	aa0203e3 	mov	x3, x2
  202e10:	f0ffffe0 	adrp	x0, 201000 <memcpy+0x100>
  202e14:	91098000 	add	x0, x0, #0x260
  202e18:	aa0403e2 	mov	x2, x4
  202e1c:	910043e4 	add	x4, sp, #0x10
  202e20:	a9011fe8 	stp	x8, x7, [sp, #16]
  202e24:	a90217e6 	stp	x6, x5, [sp, #32]
  202e28:	97fffc22 	bl	201eb0 <_vsnprintf>
}
  202e2c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  202e30:	d65f03c0 	ret
  202e34:	d503201f 	nop
  202e38:	d503201f 	nop
  202e3c:	d503201f 	nop

0000000000202e40 <sddf_fctprintf>:


int sddf_fctprintf(void (*out)(char character, void* arg), void* arg, const char* format, ...)
{
  202e40:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  va_list va;
  va_start(va, format);
  202e44:	12800feb 	mov	w11, #0xffffff80            	// #-128
  202e48:	128004e9 	mov	w9, #0xffffffd8            	// #-40
{
  202e4c:	910003fd 	mov	x29, sp
  va_start(va, format);
  202e50:	910383ea 	add	x10, sp, #0xe0
  202e54:	910443e8 	add	x8, sp, #0x110
  202e58:	a90423e8 	stp	x8, x8, [sp, #64]
{
  202e5c:	aa0203e8 	mov	x8, x2
  const out_fct_wrap_type out_fct_wrap = { out, arg };
  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
  202e60:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
  va_start(va, format);
  202e64:	f9002bea 	str	x10, [sp, #80]
{
  202e68:	aa0003ea 	mov	x10, x0
  va_start(va, format);
  202e6c:	290b2fe9 	stp	w9, w11, [sp, #88]
{
  202e70:	aa0103e9 	mov	x9, x1
  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
  202e74:	a9443fee 	ldp	x14, x15, [sp, #64]
  202e78:	9100c3e1 	add	x1, sp, #0x30
  202e7c:	a94537ec 	ldp	x12, x13, [sp, #80]
  202e80:	f0ffffe0 	adrp	x0, 201000 <memcpy+0x100>
  202e84:	911bc000 	add	x0, x0, #0x6f0
  202e88:	a9013fee 	stp	x14, x15, [sp, #16]
  202e8c:	a90237ec 	stp	x12, x13, [sp, #32]
  const out_fct_wrap_type out_fct_wrap = { out, arg };
  202e90:	a90327ea 	stp	x10, x9, [sp, #48]
{
  202e94:	3d801be0 	str	q0, [sp, #96]
  202e98:	3d801fe1 	str	q1, [sp, #112]
  202e9c:	3d8023e2 	str	q2, [sp, #128]
  202ea0:	3d8027e3 	str	q3, [sp, #144]
  202ea4:	3d802be4 	str	q4, [sp, #160]
  202ea8:	3d802fe5 	str	q5, [sp, #176]
  202eac:	3d8033e6 	str	q6, [sp, #192]
  202eb0:	3d8037e7 	str	q7, [sp, #208]
  202eb4:	a90e93e3 	stp	x3, x4, [sp, #232]
  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
  202eb8:	910043e4 	add	x4, sp, #0x10
  202ebc:	aa0803e3 	mov	x3, x8
{
  202ec0:	a90f9be5 	stp	x5, x6, [sp, #248]
  202ec4:	f90087e7 	str	x7, [sp, #264]
  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
  202ec8:	97fffbfa 	bl	201eb0 <_vsnprintf>
  va_end(va);
  return ret;
}
  202ecc:	a8d17bfd 	ldp	x29, x30, [sp], #272
  202ed0:	d65f03c0 	ret
	...

0000000000202ee0 <_assert_fail>:
 */

#include <sddf/util/printf.h>

void _assert_fail(const char  *assertion, const char  *file, unsigned int line, const char  *function)
{
  202ee0:	2a0203e5 	mov	w5, w2
  202ee4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  202ee8:	aa0103e4 	mov	x4, x1
  202eec:	910003fd 	mov	x29, sp
    sddf_dprintf("Failed assertion '%s' at %s:%u in function %s\n", assertion, file, line, function);
  202ef0:	aa0003e1 	mov	x1, x0
  202ef4:	aa0403e2 	mov	x2, x4
  202ef8:	aa0303e4 	mov	x4, x3
  202efc:	b0000000 	adrp	x0, 203000 <__FUNCTION__.0+0x68>
  202f00:	91076000 	add	x0, x0, #0x1d8
  202f04:	2a0503e3 	mov	w3, w5
  202f08:	97ffff3a 	bl	202bf0 <sddf_printf_>
    __builtin_trap();
  202f0c:	d4207d00 	brk	#0x3e8

0000000000202f10 <_sddf_putchar>:

static char string_buffer[MAX_STRING_LENGTH + 1];
static uint32_t local_tail;

void _sddf_putchar(char character)
{
  202f10:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    string_buffer[local_tail] = character;
  202f14:	90000041 	adrp	x1, 20a000 <arp_table+0x2d40>
  202f18:	911cc021 	add	x1, x1, #0x730
{
  202f1c:	910003fd 	mov	x29, sp
  202f20:	f9000bf3 	str	x19, [sp, #16]
    string_buffer[local_tail] = character;
  202f24:	90000053 	adrp	x19, 20a000 <arp_table+0x2d40>
  202f28:	b9472263 	ldr	w3, [x19, #1824]
{
  202f2c:	12001c00 	and	w0, w0, #0xff
    local_tail++;
  202f30:	11000462 	add	w2, w3, #0x1
  202f34:	b9072262 	str	w2, [x19, #1824]

    if (character == FLUSH_CHAR || local_tail == MAX_STRING_LENGTH) {
  202f38:	7140045f 	cmp	w2, #0x1, lsl #12
    string_buffer[local_tail] = character;
  202f3c:	38234820 	strb	w0, [x1, w3, uxtw]
    if (character == FLUSH_CHAR || local_tail == MAX_STRING_LENGTH) {
  202f40:	7a4a1804 	ccmp	w0, #0xa, #0x4, ne	// ne = any
  202f44:	540000a1 	b.ne	202f58 <_sddf_putchar+0x48>  // b.any
        string_buffer[local_tail] = '\0';
        microkit_dbg_puts(string_buffer);
  202f48:	aa0103e0 	mov	x0, x1
        string_buffer[local_tail] = '\0';
  202f4c:	3822483f 	strb	wzr, [x1, w2, uxtw]
        microkit_dbg_puts(string_buffer);
  202f50:	97fff784 	bl	200d60 <microkit_dbg_puts>
        local_tail = 0;
  202f54:	b907227f 	str	wzr, [x19, #1824]
    }
  202f58:	f9400bf3 	ldr	x19, [sp, #16]
  202f5c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  202f60:	d65f03c0 	ret
  202f64:	00000000 	udf	#0

0000000000202f68 <__FUNCTION__.3>:
  202f68:	636f7270 5f737365 75716572 73747365     process_requests
	...

0000000000202f80 <__FUNCTION__.1>:
  202f80:	636f7270 5f737365 70736572 65736e6f     process_response
  202f90:	00000073 00000000                       s.......

0000000000202f98 <__FUNCTION__.0>:
  202f98:	5f74656e 66667562 5f737265 74696e69     net_buffers_init
	...
  202fb0:	fff900a3 fff9fff9 fff9fff9 fff9fff9     ................
  202fc0:	fff9fff9 fff9fff9 fff9fff9 fff9fff9     ................
  202fd0:	fff9fff9 fff9fff9 fff9fff9 fff9fff9     ................
  202fe0:	fff9fff9 fff9fff9 fff9fff9 fff9fff9     ................
  202ff0:	007e0067 fff90067 fff9fff9 fff9fff9     g.~.g...........
  203000:	fff9fff9 fff9fff9 fff9fff9 fff9fff9     ................
  203010:	fff9fff9 012cfff9 fff9fff9 fff9fff9     ......,.........
  203020:	fff9fff9 fff9fff9 012cfff9 012c0090     ..........,...,.
  203030:	007e0067 00000067 00000000 00000000     g.~.g...........

0000000000203040 <pow10.0>:
  203040:	00000000 3ff00000 00000000 40240000     .......?......$@
  203050:	00000000 40590000 00000000 408f4000     ......Y@.....@.@
  203060:	00000000 40c38800 00000000 40f86a00     .......@.....j.@
  203070:	00000000 412e8480 00000000 416312d0     .......A......cA
  203080:	00000000 4197d784 00000000 41cdcd65     .......A....e..A
