
build/eth_driver_virtio.elf:     file format elf64-littleaarch64


Disassembly of section .text:

0000000000200000 <_start>:
  200000:	14000594 	b	201650 <main>
	...

0000000000200010 <rx_provide>:
{
    return tx_last_desc_idx >= tx_virtq.num;
}

static void rx_provide(void)
{
  200010:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
  200014:	910003fd 	mov	x29, sp
  200018:	a90153f3 	stp	x19, x20, [sp, #16]
    return rx_last_desc_idx >= rx_virtq.num;
  20001c:	90000020 	adrp	x0, 204000 <__sel4_ipc_buffer>
  200020:	911ac013 	add	x19, x0, #0x6b0
    /* We need to take all of our sDDF free entries and place them in the virtIO 'free' ring. */
    bool transferred = false;
    bool reprocess = true;
    while (reprocess) {
        while (!virtio_avail_full_rx(&rx_virtq) && !net_queue_empty_free(&rx_queue)) {
  200024:	b946b001 	ldr	w1, [x0, #1712]
  200028:	b9402260 	ldr	w0, [x19, #32]
  20002c:	6b00003f 	cmp	w1, w0
  200030:	54001849 	b.ls	200338 <rx_provide+0x328>  // b.plast
  200034:	a90363f7 	stp	x23, x24, [sp, #48]
            uint32_t pkt_desc_idx = -1;
            err = ialloc_alloc(&rx_ialloc_desc, &pkt_desc_idx);
            assert(!err && pkt_desc_idx != -1);

            assert(hdr_desc_idx < rx_virtq.num);
            assert(pkt_desc_idx < rx_virtq.num);
  200038:	f0000018 	adrp	x24, 203000 <_vsnprintf+0x9f0>
  20003c:	9121c300 	add	x0, x24, #0x870
  200040:	5280000c 	mov	w12, #0x0                   	// #0
  200044:	a9025bf5 	stp	x21, x22, [sp, #32]
  200048:	a9046bf9 	stp	x25, x26, [sp, #64]
  20004c:	a90573fb 	stp	x27, x28, [sp, #80]
  200050:	f90033e0 	str	x0, [sp, #96]
            assert(hdr_desc_idx < rx_virtq.num);
  200054:	f0000017 	adrp	x23, 203000 <_vsnprintf+0x9f0>
  200058:	912142e0 	add	x0, x23, #0x850
  20005c:	f90037e0 	str	x0, [sp, #104]
  200060:	14000037 	b	20013c <rx_provide+0x12c>

            // Get the header address, which is an index into the virtio net headers memory region
            rx_virtq.desc[hdr_desc_idx].addr = virtio_net_rx_headers_paddr + (hdr_desc_idx * sizeof(virtio_net_hdr_t));
  200064:	52800155 	mov	w21, #0xa                   	// #10
  200068:	d37c7f7c 	ubfiz	x28, x27, #4, #32
            // The packet address will be the actual buffer that we have dequeued from the client
            rx_virtq.desc[pkt_desc_idx].addr = buffer.io_or_offset;
            rx_virtq.desc[pkt_desc_idx].len = NET_BUFFER_SIZE;
            rx_virtq.desc[pkt_desc_idx].flags = VIRTQ_DESC_F_WRITE;
            // Set the entry in the available ring to point to the desc entry for the header
            rx_virtq.avail->ring[rx_virtq.avail->idx % rx_virtq.num] = hdr_desc_idx;
  20006c:	12003f7a 	and	w26, w27, #0xffff
            rx_virtq.desc[hdr_desc_idx].addr = virtio_net_rx_headers_paddr + (hdr_desc_idx * sizeof(virtio_net_hdr_t));
  200070:	9bb57f75 	umull	x21, w27, w21
 *
 * @return 0 on success, -1 if index list is full.
 */
static inline int ialloc_alloc(ialloc_t *ia, uint32_t *id)
{
    if (ialloc_full(ia)) {
  200074:	34000c62 	cbz	w2, 200200 <rx_provide+0x1f0>
        return -1;
    }
    *id = ia->head + ia->offset;
  200078:	b9404a74 	ldr	w20, [x19, #72]
    ia->head = ia->idxlist[ia->head];
    ia->idxlist[*id - ia->offset] = -1;
  20007c:	12800003 	mov	w3, #0xffffffff            	// #-1
    *id = ia->head + ia->offset;
  200080:	b9405664 	ldr	w4, [x19, #84]
    ia->head = ia->idxlist[ia->head];
  200084:	2a1403e2 	mov	w2, w20
    *id = ia->head + ia->offset;
  200088:	0b040294 	add	w20, w20, w4
            assert(!err && pkt_desc_idx != -1);
  20008c:	6b03029f 	cmp	w20, w3
    ia->head = ia->idxlist[ia->head];
  200090:	b8627824 	ldr	w4, [x1, x2, lsl #2]
  200094:	b9004a64 	str	w4, [x19, #72]
    ia->idxlist[*id - ia->offset] = -1;
  200098:	b8227823 	str	w3, [x1, x2, lsl #2]
    ia->num_free--;
  20009c:	b9405261 	ldr	w1, [x19, #80]
  2000a0:	0b030021 	add	w1, w1, w3
  2000a4:	b9005261 	str	w1, [x19, #80]
  2000a8:	54000ac0 	b.eq	200200 <rx_provide+0x1f0>  // b.none
            assert(hdr_desc_idx < rx_virtq.num);
  2000ac:	b9400261 	ldr	w1, [x19]
  2000b0:	6b1b003f 	cmp	w1, w27
  2000b4:	54000d29 	b.ls	200258 <rx_provide+0x248>  // b.plast
            assert(pkt_desc_idx < rx_virtq.num);
  2000b8:	6b01029f 	cmp	w20, w1
            rx_virtq.desc[hdr_desc_idx].next = pkt_desc_idx;
  2000bc:	12003e99 	and	w25, w20, #0xffff
            rx_virtq.desc[pkt_desc_idx].addr = buffer.io_or_offset;
  2000c0:	d37c7e94 	ubfiz	x20, x20, #4, #32
            assert(pkt_desc_idx < rx_virtq.num);
  2000c4:	54000e22 	b.cs	200288 <rx_provide+0x278>  // b.hs, b.nlast
            rx_virtq.avail->ring[rx_virtq.avail->idx % rx_virtq.num] = hdr_desc_idx;
  2000c8:	a9408e62 	ldp	x2, x3, [x19, #8]
            rx_virtq.desc[hdr_desc_idx].len = sizeof(virtio_net_hdr_t);
  2000cc:	5280014c 	mov	w12, #0xa                   	// #10
            rx_virtq.desc[hdr_desc_idx].addr = virtio_net_rx_headers_paddr + (hdr_desc_idx * sizeof(virtio_net_hdr_t));
  2000d0:	f9403266 	ldr	x6, [x19, #96]
            rx_virtq.desc[hdr_desc_idx].flags = VIRTQ_DESC_F_NEXT | VIRTQ_DESC_F_WRITE;
  2000d4:	5280006b 	mov	w11, #0x3                   	// #3
            rx_virtq.desc[pkt_desc_idx].len = NET_BUFFER_SIZE;
  2000d8:	5281000a 	mov	w10, #0x800                 	// #2048
            rx_virtq.desc[pkt_desc_idx].flags = VIRTQ_DESC_F_WRITE;
  2000dc:	52800049 	mov	w9, #0x2                   	// #2
            rx_virtq.desc[hdr_desc_idx].addr = virtio_net_rx_headers_paddr + (hdr_desc_idx * sizeof(virtio_net_hdr_t));
  2000e0:	8b1500c6 	add	x6, x6, x21
            rx_virtq.avail->ring[rx_virtq.avail->idx % rx_virtq.num] = hdr_desc_idx;
  2000e4:	79400465 	ldrh	w5, [x3, #2]
            rx_virtq.desc[hdr_desc_idx].addr = virtio_net_rx_headers_paddr + (hdr_desc_idx * sizeof(virtio_net_hdr_t));
  2000e8:	8b1c0044 	add	x4, x2, x28
            rx_virtq.desc[pkt_desc_idx].addr = buffer.io_or_offset;
  2000ec:	8b140048 	add	x8, x2, x20
            rx_virtq.desc[hdr_desc_idx].addr = virtio_net_rx_headers_paddr + (hdr_desc_idx * sizeof(virtio_net_hdr_t));
  2000f0:	f83c6846 	str	x6, [x2, x28]
            // We only want to increment the avail ring by 1, as we are only increasing by one in
            // this list, but we are adding two desc entries.
            rx_virtq.avail->idx++;
  2000f4:	110004a6 	add	w6, w5, #0x1
            rx_virtq.desc[hdr_desc_idx].len = sizeof(virtio_net_hdr_t);
  2000f8:	b900088c 	str	w12, [x4, #8]
            rx_virtq.desc[pkt_desc_idx].addr = buffer.io_or_offset;
  2000fc:	5280002c 	mov	w12, #0x1                   	// #1
            rx_virtq.avail->ring[rx_virtq.avail->idx % rx_virtq.num] = hdr_desc_idx;
  200100:	1ac108a0 	udiv	w0, w5, w1
            rx_virtq.desc[hdr_desc_idx].flags = VIRTQ_DESC_F_NEXT | VIRTQ_DESC_F_WRITE;
  200104:	7900188b 	strh	w11, [x4, #12]
            rx_virtq.desc[hdr_desc_idx].next = pkt_desc_idx;
  200108:	79001c99 	strh	w25, [x4, #14]
            rx_virtq.desc[pkt_desc_idx].addr = buffer.io_or_offset;
  20010c:	f8346856 	str	x22, [x2, x20]
            rx_virtq.desc[pkt_desc_idx].len = NET_BUFFER_SIZE;
  200110:	b900090a 	str	w10, [x8, #8]
            rx_virtq.avail->ring[rx_virtq.avail->idx % rx_virtq.num] = hdr_desc_idx;
  200114:	1b019400 	msub	w0, w0, w1, w5
            rx_virtq.desc[pkt_desc_idx].flags = VIRTQ_DESC_F_WRITE;
  200118:	79001909 	strh	w9, [x8, #12]
            rx_last_desc_idx += 2;
  20011c:	b9402262 	ldr	w2, [x19, #32]
            rx_virtq.avail->ring[rx_virtq.avail->idx % rx_virtq.num] = hdr_desc_idx;
  200120:	8b000460 	add	x0, x3, x0, lsl #1
  200124:	7900081a 	strh	w26, [x0, #4]
            rx_last_desc_idx += 2;
  200128:	11000840 	add	w0, w2, #0x2
            rx_virtq.avail->idx++;
  20012c:	79000466 	strh	w6, [x3, #2]
        while (!virtio_avail_full_rx(&rx_virtq) && !net_queue_empty_free(&rx_queue)) {
  200130:	6b01001f 	cmp	w0, w1
            rx_last_desc_idx += 2;
  200134:	b9002260 	str	w0, [x19, #32]
        while (!virtio_avail_full_rx(&rx_virtq) && !net_queue_empty_free(&rx_queue)) {
  200138:	54000d82 	b.cs	2002e8 <rx_provide+0x2d8>  // b.hs, b.nlast
 *
 * @return true indicates the queue is empty, false otherwise.
 */
static inline bool net_queue_empty_free(net_queue_handle_t *queue)
{
    return queue->free->tail - queue->free->head == 0;
  20013c:	f9401662 	ldr	x2, [x19, #40]
  200140:	9100a261 	add	x1, x19, #0x28
  200144:	79400443 	ldrh	w3, [x2, #2]
  200148:	79400040 	ldrh	w0, [x2]
  20014c:	6b03001f 	cmp	w0, w3
  200150:	54000e20 	b.eq	200314 <rx_provide+0x304>  // b.none
{
    if (net_queue_empty_free(queue)) {
        return -1;
    }

    *buffer = queue->free->buffers[queue->free->head % queue->capacity];
  200154:	b9401024 	ldr	w4, [x1, #16]
#ifdef CONFIG_ENABLE_SMP_SUPPORT
    THREAD_MEMORY_RELEASE();
#endif
    queue->free->head++;
  200158:	11000466 	add	w6, w3, #0x1
    if (ialloc_full(ia)) {
  20015c:	b9405265 	ldr	w5, [x19, #80]
    return ia->num_free == 0;
  200160:	91010260 	add	x0, x19, #0x40
    *buffer = queue->free->buffers[queue->free->head % queue->capacity];
  200164:	1ac40861 	udiv	w1, w3, w4
  200168:	1b048c21 	msub	w1, w1, w4, w3
  20016c:	8b011041 	add	x1, x2, x1, lsl #4
  200170:	f9400436 	ldr	x22, [x1, #8]
    queue->free->head++;
  200174:	79000446 	strh	w6, [x2, #2]
    if (ialloc_full(ia)) {
  200178:	340001e5 	cbz	w5, 2001b4 <rx_provide+0x1a4>
    *id = ia->head + ia->offset;
  20017c:	b940081b 	ldr	w27, [x0, #8]
    ia->idxlist[*id - ia->offset] = -1;
  200180:	12800003 	mov	w3, #0xffffffff            	// #-1
    ia->head = ia->idxlist[ia->head];
  200184:	f9402261 	ldr	x1, [x19, #64]
  200188:	2a1b03e2 	mov	w2, w27
    *id = ia->head + ia->offset;
  20018c:	b9401405 	ldr	w5, [x0, #20]
    ia->head = ia->idxlist[ia->head];
  200190:	b8627824 	ldr	w4, [x1, x2, lsl #2]
    *id = ia->head + ia->offset;
  200194:	0b05037b 	add	w27, w27, w5
    ia->head = ia->idxlist[ia->head];
  200198:	b9000804 	str	w4, [x0, #8]
            assert(!err && hdr_desc_idx != -1);
  20019c:	6b03037f 	cmp	w27, w3
    ia->idxlist[*id - ia->offset] = -1;
  2001a0:	b8227823 	str	w3, [x1, x2, lsl #2]
    ia->num_free--;
  2001a4:	b9401002 	ldr	w2, [x0, #16]
  2001a8:	0b030042 	add	w2, w2, w3
  2001ac:	b9001002 	str	w2, [x0, #16]
  2001b0:	54fff5a1 	b.ne	200064 <rx_provide+0x54>  // b.any
  2001b4:	f0000018 	adrp	x24, 203000 <_vsnprintf+0x9f0>
  2001b8:	911a2318 	add	x24, x24, #0x688
  2001bc:	f0000017 	adrp	x23, 203000 <_vsnprintf+0x9f0>
  2001c0:	911f02f7 	add	x23, x23, #0x7c0
  2001c4:	aa1803e3 	mov	x3, x24
  2001c8:	aa1703e1 	mov	x1, x23
  2001cc:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  2001d0:	52800d42 	mov	w2, #0x6a                  	// #106
  2001d4:	91204000 	add	x0, x0, #0x810
  2001d8:	94000d0a 	bl	203600 <_assert_fail>
    if (ialloc_full(ia)) {
  2001dc:	b9405260 	ldr	w0, [x19, #80]
  2001e0:	340005e0 	cbz	w0, 20029c <rx_provide+0x28c>
    ia->head = ia->idxlist[ia->head];
  2001e4:	12800135 	mov	w21, #0xfffffff6            	// #-10
  2001e8:	529ffffa 	mov	w26, #0xffff                	// #65535
  2001ec:	f9402261 	ldr	x1, [x19, #64]
  2001f0:	b27c7ffc 	mov	x28, #0xffffffff0           	// #68719476720
  2001f4:	f2c00135 	movk	x21, #0x9, lsl #32
  2001f8:	1280001b 	mov	w27, #0xffffffff            	// #-1
  2001fc:	17ffff9f 	b	200078 <rx_provide+0x68>
            assert(!err && pkt_desc_idx != -1);
  200200:	f0000018 	adrp	x24, 203000 <_vsnprintf+0x9f0>
  200204:	911a2318 	add	x24, x24, #0x688
  200208:	f0000017 	adrp	x23, 203000 <_vsnprintf+0x9f0>
  20020c:	911f02f7 	add	x23, x23, #0x7c0
  200210:	aa1803e3 	mov	x3, x24
  200214:	aa1703e1 	mov	x1, x23
  200218:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  20021c:	52800da2 	mov	w2, #0x6d                  	// #109
  200220:	9120c000 	add	x0, x0, #0x830
  200224:	94000cf7 	bl	203600 <_assert_fail>
            assert(hdr_desc_idx < rx_virtq.num);
  200228:	b9400260 	ldr	w0, [x19]
  20022c:	b27c7ff4 	mov	x20, #0xffffffff0           	// #68719476720
  200230:	529ffff9 	mov	w25, #0xffff                	// #65535
  200234:	6b1b001f 	cmp	w0, w27
  200238:	54000489 	b.ls	2002c8 <rx_provide+0x2b8>  // b.plast
            assert(pkt_desc_idx < rx_virtq.num);
  20023c:	f94033e0 	ldr	x0, [sp, #96]
  200240:	aa1703e1 	mov	x1, x23
  200244:	aa1803e3 	mov	x3, x24
  200248:	52800e02 	mov	w2, #0x70                  	// #112
  20024c:	94000ced 	bl	203600 <_assert_fail>
            rx_virtq.avail->ring[rx_virtq.avail->idx % rx_virtq.num] = hdr_desc_idx;
  200250:	b9400261 	ldr	w1, [x19]
  200254:	17ffff9d 	b	2000c8 <rx_provide+0xb8>
            assert(hdr_desc_idx < rx_virtq.num);
  200258:	f94037e0 	ldr	x0, [sp, #104]
  20025c:	f0000018 	adrp	x24, 203000 <_vsnprintf+0x9f0>
  200260:	f0000017 	adrp	x23, 203000 <_vsnprintf+0x9f0>
  200264:	911a2303 	add	x3, x24, #0x688
  200268:	911f02e1 	add	x1, x23, #0x7c0
  20026c:	52800de2 	mov	w2, #0x6f                  	// #111
  200270:	94000ce4 	bl	203600 <_assert_fail>
            rx_virtq.desc[hdr_desc_idx].next = pkt_desc_idx;
  200274:	12003e99 	and	w25, w20, #0xffff
            assert(pkt_desc_idx < rx_virtq.num);
  200278:	b9400261 	ldr	w1, [x19]
  20027c:	6b01029f 	cmp	w20, w1
            rx_virtq.desc[pkt_desc_idx].addr = buffer.io_or_offset;
  200280:	d37c7e94 	ubfiz	x20, x20, #4, #32
            assert(pkt_desc_idx < rx_virtq.num);
  200284:	54fff223 	b.cc	2000c8 <rx_provide+0xb8>  // b.lo, b.ul, b.last
  200288:	f0000003 	adrp	x3, 203000 <_vsnprintf+0x9f0>
  20028c:	911a2078 	add	x24, x3, #0x688
  200290:	f0000001 	adrp	x1, 203000 <_vsnprintf+0x9f0>
  200294:	911f0037 	add	x23, x1, #0x7c0
  200298:	17ffffe9 	b	20023c <rx_provide+0x22c>
            assert(!err && pkt_desc_idx != -1);
  20029c:	12800135 	mov	w21, #0xfffffff6            	// #-10
  2002a0:	529ffffa 	mov	w26, #0xffff                	// #65535
  2002a4:	b27c7ffc 	mov	x28, #0xffffffff0           	// #68719476720
  2002a8:	f2c00135 	movk	x21, #0x9, lsl #32
  2002ac:	aa1803e3 	mov	x3, x24
  2002b0:	aa1703e1 	mov	x1, x23
  2002b4:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  2002b8:	52800da2 	mov	w2, #0x6d                  	// #109
  2002bc:	9120c000 	add	x0, x0, #0x830
  2002c0:	94000cd0 	bl	203600 <_assert_fail>
            assert(hdr_desc_idx < rx_virtq.num);
  2002c4:	d503201f 	nop
  2002c8:	f94037e0 	ldr	x0, [sp, #104]
  2002cc:	aa1803e3 	mov	x3, x24
  2002d0:	aa1703e1 	mov	x1, x23
  2002d4:	52800de2 	mov	w2, #0x6f                  	// #111
  2002d8:	b27c7ff4 	mov	x20, #0xffffffff0           	// #68719476720
  2002dc:	529ffff9 	mov	w25, #0xffff                	// #65535
  2002e0:	94000cc8 	bl	203600 <_assert_fail>
            assert(pkt_desc_idx < rx_virtq.num);
  2002e4:	17ffffd6 	b	20023c <rx_provide+0x22c>
 *
 * @param queue queue handle of free queue that requires signalling upon enqueuing.
 */
static inline void net_request_signal_free(net_queue_handle_t *queue)
{
    queue->free->consumer_signalled = 0;
  2002e8:	f9401660 	ldr	x0, [x19, #40]
  2002ec:	b900041f 	str	wzr, [x0, #4]
        }
    }

    if (transferred) {
        /* We have added more avail buffers, so notify the device */
        regs->QueueNotify = VIRTIO_NET_RX_QUEUE;
  2002f0:	f9403660 	ldr	x0, [x19, #104]
    }
}
  2002f4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  2002f8:	a94363f7 	ldp	x23, x24, [sp, #48]
  2002fc:	a9446bf9 	ldp	x25, x26, [sp, #64]
  200300:	a94573fb 	ldp	x27, x28, [sp, #80]
        regs->QueueNotify = VIRTIO_NET_RX_QUEUE;
  200304:	b900501f 	str	wzr, [x0, #80]
}
  200308:	a94153f3 	ldp	x19, x20, [sp, #16]
  20030c:	a8c77bfd 	ldp	x29, x30, [sp], #112
  200310:	d65f03c0 	ret
  200314:	b900045f 	str	wzr, [x2, #4]
    if (transferred) {
  200318:	35fffecc 	cbnz	w12, 2002f0 <rx_provide+0x2e0>
}
  20031c:	a94153f3 	ldp	x19, x20, [sp, #16]
  200320:	a9425bf5 	ldp	x21, x22, [sp, #32]
  200324:	a94363f7 	ldp	x23, x24, [sp, #48]
  200328:	a9446bf9 	ldp	x25, x26, [sp, #64]
  20032c:	a94573fb 	ldp	x27, x28, [sp, #80]
  200330:	a8c77bfd 	ldp	x29, x30, [sp], #112
  200334:	d65f03c0 	ret
  200338:	f9401660 	ldr	x0, [x19, #40]
  20033c:	b900041f 	str	wzr, [x0, #4]
    if (transferred) {
  200340:	17fffff2 	b	200308 <rx_provide+0x2f8>
  200344:	d503201f 	nop
  200348:	d503201f 	nop
  20034c:	d503201f 	nop

0000000000200350 <tx_provide>:
        microkit_notify(config.virt_rx.id);
    }
}

static void tx_provide(void)
{
  200350:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  200354:	910003fd 	mov	x29, sp
  200358:	a90153f3 	stp	x19, x20, [sp, #16]
    return tx_last_desc_idx >= tx_virtq.num;
  20035c:	90000033 	adrp	x19, 204000 <__sel4_ipc_buffer>
  200360:	911ac273 	add	x19, x19, #0x6b0
    bool reprocess = true;
    bool packets_transferred = false;
    while (reprocess) {
        while (!virtio_avail_full_tx(&tx_virtq) && !net_queue_empty_active(&tx_queue)) {
  200364:	b9407261 	ldr	w1, [x19, #112]
  200368:	b9409260 	ldr	w0, [x19, #144]
  20036c:	6b00003f 	cmp	w1, w0
  200370:	54001969 	b.ls	20069c <tx_provide+0x34c>  // b.plast
  200374:	a90363f7 	stp	x23, x24, [sp, #48]
            uint32_t hdr_desc_idx = -1;
            err = ialloc_alloc(&tx_ialloc_desc, &hdr_desc_idx);
            assert(!err && hdr_desc_idx != -1);
            uint32_t pkt_desc_idx = -1;
            err = ialloc_alloc(&tx_ialloc_desc, &pkt_desc_idx);
            assert(!err && pkt_desc_idx != -1);
  200378:	f0000017 	adrp	x23, 203000 <_vsnprintf+0x9f0>
  20037c:	911a22e0 	add	x0, x23, #0x688
  200380:	f90037e0 	str	x0, [sp, #104]
  200384:	91004000 	add	x0, x0, #0x10
  200388:	5280000a 	mov	w10, #0x0                   	// #0
  20038c:	a9025bf5 	stp	x21, x22, [sp, #32]
  200390:	a9046bf9 	stp	x25, x26, [sp, #64]
  200394:	a90573fb 	stp	x27, x28, [sp, #80]
  200398:	f90033e0 	str	x0, [sp, #96]
            /* We should not run out of descriptors assuming that the avail ring is not full. */
            assert(hdr_desc_idx < tx_virtq.num);
            assert(pkt_desc_idx < tx_virtq.num);
  20039c:	f0000018 	adrp	x24, 203000 <_vsnprintf+0x9f0>
  2003a0:	9122c300 	add	x0, x24, #0x8b0
  2003a4:	f9003fe0 	str	x0, [sp, #120]
  2003a8:	1400003d 	b	20049c <tx_provide+0x14c>
            tx_virtq.avail->ring[tx_virtq.avail->idx % tx_virtq.num] = hdr_desc_idx;

            virtio_net_hdr_t *hdr = &virtio_net_tx_headers[hdr_desc_idx];
  2003ac:	52800144 	mov	w4, #0xa                   	// #10
            tx_virtq.avail->ring[tx_virtq.avail->idx % tx_virtq.num] = hdr_desc_idx;
  2003b0:	12003e9b 	and	w27, w20, #0xffff
            hdr->gso_type = VIRTIO_NET_HDR_GSO_NONE;
            hdr->hdr_len = 0;  /* not used unless we have segmentation offload */
            hdr->gso_size = 0; /* same */
            hdr->csum_start = 0;
            hdr->csum_offset = 0;
            tx_virtq.desc[hdr_desc_idx].addr = virtio_net_tx_headers_paddr + (hdr_desc_idx * sizeof(virtio_net_hdr_t));
  2003b4:	d37c7e96 	ubfiz	x22, x20, #4, #32
            virtio_net_hdr_t *hdr = &virtio_net_tx_headers[hdr_desc_idx];
  2003b8:	9ba47e98 	umull	x24, w20, w4
    if (ialloc_full(ia)) {
  2003bc:	34000d00 	cbz	w0, 20055c <tx_provide+0x20c>
    *id = ia->head + ia->offset;
  2003c0:	b940ba75 	ldr	w21, [x19, #184]
    ia->idxlist[*id - ia->offset] = -1;
  2003c4:	12800003 	mov	w3, #0xffffffff            	// #-1
    *id = ia->head + ia->offset;
  2003c8:	b940c666 	ldr	w6, [x19, #196]
    ia->head = ia->idxlist[ia->head];
  2003cc:	2a1503e1 	mov	w1, w21
    *id = ia->head + ia->offset;
  2003d0:	0b0602b5 	add	w21, w21, w6
            assert(!err && pkt_desc_idx != -1);
  2003d4:	6b0302bf 	cmp	w21, w3
    ia->head = ia->idxlist[ia->head];
  2003d8:	b8617846 	ldr	w6, [x2, x1, lsl #2]
  2003dc:	b900ba66 	str	w6, [x19, #184]
    ia->idxlist[*id - ia->offset] = -1;
  2003e0:	b8217843 	str	w3, [x2, x1, lsl #2]
    ia->num_free--;
  2003e4:	b940c261 	ldr	w1, [x19, #192]
  2003e8:	0b030021 	add	w1, w1, w3
  2003ec:	b900c261 	str	w1, [x19, #192]
  2003f0:	54000b60 	b.eq	20055c <tx_provide+0x20c>  // b.none
            assert(hdr_desc_idx < tx_virtq.num);
  2003f4:	b9407261 	ldr	w1, [x19, #112]
  2003f8:	6b14003f 	cmp	w1, w20
  2003fc:	54000dc9 	b.ls	2005b4 <tx_provide+0x264>  // b.plast
            assert(pkt_desc_idx < tx_virtq.num);
  200400:	6b0102bf 	cmp	w21, w1
            tx_virtq.desc[hdr_desc_idx].len = sizeof(virtio_net_hdr_t);
            tx_virtq.desc[hdr_desc_idx].next = pkt_desc_idx;
  200404:	12003ea7 	and	w7, w21, #0xffff
            tx_virtq.desc[hdr_desc_idx].flags = VIRTQ_DESC_F_NEXT;
            tx_virtq.desc[pkt_desc_idx].addr = buffer.io_or_offset;
  200408:	d37c7eb5 	ubfiz	x21, x21, #4, #32
            assert(pkt_desc_idx < tx_virtq.num);
  20040c:	54000ec2 	b.cs	2005e4 <tx_provide+0x294>  // b.hs, b.nlast
            tx_virtq.avail->ring[tx_virtq.avail->idx % tx_virtq.num] = hdr_desc_idx;
  200410:	f9404266 	ldr	x6, [x19, #128]
  200414:	5280002a 	mov	w10, #0x1                   	// #1
            virtio_net_hdr_t *hdr = &virtio_net_tx_headers[hdr_desc_idx];
  200418:	f9406a69 	ldr	x9, [x19, #208]
            tx_virtq.desc[hdr_desc_idx].len = sizeof(virtio_net_hdr_t);
  20041c:	5280014d 	mov	w13, #0xa                   	// #10
            tx_virtq.avail->ring[tx_virtq.avail->idx % tx_virtq.num] = hdr_desc_idx;
  200420:	794004c8 	ldrh	w8, [x6, #2]
            tx_virtq.desc[hdr_desc_idx].flags = VIRTQ_DESC_F_NEXT;
  200424:	5280002c 	mov	w12, #0x1                   	// #1
            virtio_net_hdr_t *hdr = &virtio_net_tx_headers[hdr_desc_idx];
  200428:	8b180122 	add	x2, x9, x24
            tx_virtq.desc[pkt_desc_idx].len = buffer.len;
            tx_virtq.desc[pkt_desc_idx].flags = 0;

            tx_virtq.avail->idx++;
  20042c:	0b0a010b 	add	w11, w8, w10
            tx_virtq.avail->ring[tx_virtq.avail->idx % tx_virtq.num] = hdr_desc_idx;
  200430:	1ac10900 	udiv	w0, w8, w1
  200434:	1b01a000 	msub	w0, w0, w1, w8
  200438:	8b0004c0 	add	x0, x6, x0, lsl #1
  20043c:	7900081b 	strh	w27, [x0, #4]
            hdr->flags = 0;
  200440:	7838693f 	strh	wzr, [x9, x24]
            hdr->hdr_len = 0;  /* not used unless we have segmentation offload */
  200444:	7900045f 	strh	wzr, [x2, #2]
            tx_virtq.desc[hdr_desc_idx].addr = virtio_net_tx_headers_paddr + (hdr_desc_idx * sizeof(virtio_net_hdr_t));
  200448:	f9403e60 	ldr	x0, [x19, #120]
            hdr->csum_offset = 0;
  20044c:	7900105f 	strh	wzr, [x2, #8]
            tx_virtq.desc[hdr_desc_idx].addr = virtio_net_tx_headers_paddr + (hdr_desc_idx * sizeof(virtio_net_hdr_t));
  200450:	f9406e68 	ldr	x8, [x19, #216]
  200454:	8b160003 	add	x3, x0, x22
            hdr->gso_size = 0; /* same */
  200458:	7900085f 	strh	wzr, [x2, #4]
            tx_virtq.desc[pkt_desc_idx].addr = buffer.io_or_offset;
  20045c:	8b150009 	add	x9, x0, x21
            hdr->csum_start = 0;
  200460:	79000c5f 	strh	wzr, [x2, #6]
            tx_virtq.desc[hdr_desc_idx].addr = virtio_net_tx_headers_paddr + (hdr_desc_idx * sizeof(virtio_net_hdr_t));
  200464:	8b180102 	add	x2, x8, x24
  200468:	f8366802 	str	x2, [x0, x22]
            tx_virtq.desc[hdr_desc_idx].len = sizeof(virtio_net_hdr_t);
  20046c:	b900086d 	str	w13, [x3, #8]
            tx_virtq.desc[hdr_desc_idx].flags = VIRTQ_DESC_F_NEXT;
  200470:	7900186c 	strh	w12, [x3, #12]
            tx_virtq.desc[hdr_desc_idx].next = pkt_desc_idx;
  200474:	79001c67 	strh	w7, [x3, #14]
            tx_virtq.desc[pkt_desc_idx].addr = buffer.io_or_offset;
  200478:	f8356819 	str	x25, [x0, x21]
            tx_last_desc_idx += 2;
  20047c:	b9409260 	ldr	w0, [x19, #144]
            tx_virtq.desc[pkt_desc_idx].len = buffer.len;
  200480:	b900093a 	str	w26, [x9, #8]
            tx_virtq.desc[pkt_desc_idx].flags = 0;
  200484:	7900193f 	strh	wzr, [x9, #12]
            tx_last_desc_idx += 2;
  200488:	11000800 	add	w0, w0, #0x2
            tx_virtq.avail->idx++;
  20048c:	790004cb 	strh	w11, [x6, #2]
        while (!virtio_avail_full_tx(&tx_virtq) && !net_queue_empty_active(&tx_queue)) {
  200490:	6b01001f 	cmp	w0, w1
            tx_last_desc_idx += 2;
  200494:	b9009260 	str	w0, [x19, #144]
        while (!virtio_avail_full_tx(&tx_virtq) && !net_queue_empty_active(&tx_queue)) {
  200498:	54000ea2 	b.cs	20066c <tx_provide+0x31c>  // b.hs, b.nlast
    return queue->active->tail - queue->active->head == 0;
  20049c:	f9405262 	ldr	x2, [x19, #160]
  2004a0:	91026260 	add	x0, x19, #0x98
  2004a4:	79400443 	ldrh	w3, [x2, #2]
  2004a8:	79400041 	ldrh	w1, [x2]
  2004ac:	6b03003f 	cmp	w1, w3
  2004b0:	54000cc0 	b.eq	200648 <tx_provide+0x2f8>  // b.none
    *buffer = queue->active->buffers[queue->active->head % queue->capacity];
  2004b4:	b9401004 	ldr	w4, [x0, #16]
    queue->active->head++;
  2004b8:	11000466 	add	w6, w3, #0x1
    if (ialloc_full(ia)) {
  2004bc:	b940c265 	ldr	w5, [x19, #192]
    return ia->num_free == 0;
  2004c0:	9102c261 	add	x1, x19, #0xb0
    *buffer = queue->active->buffers[queue->active->head % queue->capacity];
  2004c4:	1ac40860 	udiv	w0, w3, w4
  2004c8:	1b048c00 	msub	w0, w0, w4, w3
  2004cc:	8b001040 	add	x0, x2, x0, lsl #4
  2004d0:	f9400419 	ldr	x25, [x0, #8]
  2004d4:	7940201a 	ldrh	w26, [x0, #16]
    queue->active->head++;
  2004d8:	79000446 	strh	w6, [x2, #2]
    if (ialloc_full(ia)) {
  2004dc:	340001e5 	cbz	w5, 200518 <tx_provide+0x1c8>
    *id = ia->head + ia->offset;
  2004e0:	b9400834 	ldr	w20, [x1, #8]
    ia->idxlist[*id - ia->offset] = -1;
  2004e4:	12800003 	mov	w3, #0xffffffff            	// #-1
    ia->head = ia->idxlist[ia->head];
  2004e8:	f9405a62 	ldr	x2, [x19, #176]
  2004ec:	2a1403e0 	mov	w0, w20
    *id = ia->head + ia->offset;
  2004f0:	b9401425 	ldr	w5, [x1, #20]
    ia->head = ia->idxlist[ia->head];
  2004f4:	b8607844 	ldr	w4, [x2, x0, lsl #2]
    *id = ia->head + ia->offset;
  2004f8:	0b050294 	add	w20, w20, w5
    ia->head = ia->idxlist[ia->head];
  2004fc:	b9000824 	str	w4, [x1, #8]
            assert(!err && hdr_desc_idx != -1);
  200500:	6b03029f 	cmp	w20, w3
    ia->idxlist[*id - ia->offset] = -1;
  200504:	b8207843 	str	w3, [x2, x0, lsl #2]
    ia->num_free--;
  200508:	b9401020 	ldr	w0, [x1, #16]
  20050c:	0b030000 	add	w0, w0, w3
  200510:	b9001020 	str	w0, [x1, #16]
  200514:	54fff4c1 	b.ne	2003ac <tx_provide+0x5c>  // b.any
  200518:	a94673e3 	ldp	x3, x28, [sp, #96]
  20051c:	f0000017 	adrp	x23, 203000 <_vsnprintf+0x9f0>
  200520:	911f02f7 	add	x23, x23, #0x7c0
  200524:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  200528:	91204000 	add	x0, x0, #0x810
  20052c:	aa1703e1 	mov	x1, x23
  200530:	52801942 	mov	w2, #0xca                  	// #202
  200534:	94000c33 	bl	203600 <_assert_fail>
    if (ialloc_full(ia)) {
  200538:	b940c260 	ldr	w0, [x19, #192]
  20053c:	340005e0 	cbz	w0, 2005f8 <tx_provide+0x2a8>
    ia->head = ia->idxlist[ia->head];
  200540:	12800138 	mov	w24, #0xfffffff6            	// #-10
  200544:	b27c7ff6 	mov	x22, #0xffffffff0           	// #68719476720
  200548:	f9405a62 	ldr	x2, [x19, #176]
  20054c:	f2c00138 	movk	x24, #0x9, lsl #32
  200550:	529ffffb 	mov	w27, #0xffff                	// #65535
  200554:	12800014 	mov	w20, #0xffffffff            	// #-1
  200558:	17ffff9a 	b	2003c0 <tx_provide+0x70>
            assert(!err && pkt_desc_idx != -1);
  20055c:	a94673e3 	ldp	x3, x28, [sp, #96]
  200560:	f0000017 	adrp	x23, 203000 <_vsnprintf+0x9f0>
  200564:	911f02f7 	add	x23, x23, #0x7c0
  200568:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  20056c:	9120c000 	add	x0, x0, #0x830
  200570:	aa1703e1 	mov	x1, x23
  200574:	528019a2 	mov	w2, #0xcd                  	// #205
            assert(hdr_desc_idx < tx_virtq.num);
  200578:	b27c7ff5 	mov	x21, #0xffffffff0           	// #68719476720
            assert(!err && pkt_desc_idx != -1);
  20057c:	94000c21 	bl	203600 <_assert_fail>
            assert(hdr_desc_idx < tx_virtq.num);
  200580:	b9407260 	ldr	w0, [x19, #112]
  200584:	529fffe7 	mov	w7, #0xffff                	// #65535
  200588:	6b14001f 	cmp	w0, w20
  20058c:	540004a9 	b.ls	200620 <tx_provide+0x2d0>  // b.plast
            assert(pkt_desc_idx < tx_virtq.num);
  200590:	f9403fe0 	ldr	x0, [sp, #120]
  200594:	aa1703e1 	mov	x1, x23
  200598:	91004383 	add	x3, x28, #0x10
  20059c:	52801a02 	mov	w2, #0xd0                  	// #208
  2005a0:	b90077e7 	str	w7, [sp, #116]
  2005a4:	94000c17 	bl	203600 <_assert_fail>
            tx_virtq.avail->ring[tx_virtq.avail->idx % tx_virtq.num] = hdr_desc_idx;
  2005a8:	b9407261 	ldr	w1, [x19, #112]
  2005ac:	b94077e7 	ldr	w7, [sp, #116]
  2005b0:	17ffff98 	b	200410 <tx_provide+0xc0>
            assert(hdr_desc_idx < tx_virtq.num);
  2005b4:	f94033e3 	ldr	x3, [sp, #96]
  2005b8:	f0000017 	adrp	x23, 203000 <_vsnprintf+0x9f0>
  2005bc:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  2005c0:	911f02e1 	add	x1, x23, #0x7c0
  2005c4:	91224000 	add	x0, x0, #0x890
  2005c8:	528019e2 	mov	w2, #0xcf                  	// #207
  2005cc:	94000c0d 	bl	203600 <_assert_fail>
            assert(pkt_desc_idx < tx_virtq.num);
  2005d0:	b9407261 	ldr	w1, [x19, #112]
            tx_virtq.desc[hdr_desc_idx].next = pkt_desc_idx;
  2005d4:	12003ea7 	and	w7, w21, #0xffff
            assert(pkt_desc_idx < tx_virtq.num);
  2005d8:	6b0102bf 	cmp	w21, w1
            tx_virtq.desc[pkt_desc_idx].addr = buffer.io_or_offset;
  2005dc:	d37c7eb5 	ubfiz	x21, x21, #4, #32
            assert(pkt_desc_idx < tx_virtq.num);
  2005e0:	54fff183 	b.cc	200410 <tx_provide+0xc0>  // b.lo, b.ul, b.last
  2005e4:	f000001c 	adrp	x28, 203000 <_vsnprintf+0x9f0>
  2005e8:	911a239c 	add	x28, x28, #0x688
  2005ec:	f0000001 	adrp	x1, 203000 <_vsnprintf+0x9f0>
  2005f0:	911f0037 	add	x23, x1, #0x7c0
  2005f4:	17ffffe7 	b	200590 <tx_provide+0x240>
            assert(!err && pkt_desc_idx != -1);
  2005f8:	f94033e3 	ldr	x3, [sp, #96]
  2005fc:	12800138 	mov	w24, #0xfffffff6            	// #-10
  200600:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  200604:	9120c000 	add	x0, x0, #0x830
  200608:	aa1703e1 	mov	x1, x23
  20060c:	528019a2 	mov	w2, #0xcd                  	// #205
  200610:	b27c7ff6 	mov	x22, #0xffffffff0           	// #68719476720
  200614:	f2c00138 	movk	x24, #0x9, lsl #32
  200618:	529ffffb 	mov	w27, #0xffff                	// #65535
  20061c:	94000bf9 	bl	203600 <_assert_fail>
            assert(hdr_desc_idx < tx_virtq.num);
  200620:	f94037e1 	ldr	x1, [sp, #104]
  200624:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  200628:	91224000 	add	x0, x0, #0x890
  20062c:	528019e2 	mov	w2, #0xcf                  	// #207
  200630:	91004023 	add	x3, x1, #0x10
  200634:	aa1703e1 	mov	x1, x23
  200638:	94000bf2 	bl	203600 <_assert_fail>
  20063c:	b27c7ff5 	mov	x21, #0xffffffff0           	// #68719476720
  200640:	529fffe7 	mov	w7, #0xffff                	// #65535
  200644:	17ffffd3 	b	200590 <tx_provide+0x240>
 *
 * @param queue queue handle of active queue that requires signalling upon enqueuing.
 */
static inline void net_request_signal_active(net_queue_handle_t *queue)
{
    queue->active->consumer_signalled = 0;
  200648:	b900045f 	str	wzr, [x2, #4]
            net_cancel_signal_active(&tx_queue);
            reprocess = true;
        }
    }

    if (packets_transferred) {
  20064c:	3500014a 	cbnz	w10, 200674 <tx_provide+0x324>
  200650:	a9425bf5 	ldp	x21, x22, [sp, #32]
  200654:	a94363f7 	ldp	x23, x24, [sp, #48]
  200658:	a9446bf9 	ldp	x25, x26, [sp, #64]
  20065c:	a94573fb 	ldp	x27, x28, [sp, #80]
        /* Finally, need to notify the queue if we have transferred data */
        /* This assumes VIRTIO_F_NOTIFICATION_DATA has not been negotiated */
        regs->QueueNotify = VIRTIO_NET_TX_QUEUE;
    }
}
  200660:	a94153f3 	ldp	x19, x20, [sp, #16]
  200664:	a8c87bfd 	ldp	x29, x30, [sp], #128
  200668:	d65f03c0 	ret
  20066c:	f9405260 	ldr	x0, [x19, #160]
  200670:	b900041f 	str	wzr, [x0, #4]
        regs->QueueNotify = VIRTIO_NET_TX_QUEUE;
  200674:	f9403660 	ldr	x0, [x19, #104]
  200678:	52800021 	mov	w1, #0x1                   	// #1
}
  20067c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  200680:	a94363f7 	ldp	x23, x24, [sp, #48]
  200684:	a9446bf9 	ldp	x25, x26, [sp, #64]
  200688:	a94573fb 	ldp	x27, x28, [sp, #80]
        regs->QueueNotify = VIRTIO_NET_TX_QUEUE;
  20068c:	b9005001 	str	w1, [x0, #80]
}
  200690:	a94153f3 	ldp	x19, x20, [sp, #16]
  200694:	a8c87bfd 	ldp	x29, x30, [sp], #128
  200698:	d65f03c0 	ret
  20069c:	f9405260 	ldr	x0, [x19, #160]
  2006a0:	b900041f 	str	wzr, [x0, #4]
    if (packets_transferred) {
  2006a4:	17ffffef 	b	200660 <tx_provide+0x310>
  2006a8:	d503201f 	nop
  2006ac:	d503201f 	nop

00000000002006b0 <virtio_mmio_check_magic>:
    uint32_t Config[0];
} virtio_mmio_regs_t;

bool virtio_mmio_check_magic(virtio_mmio_regs_t *regs)
{
    return regs->MagicValue == 0x74726976;
  2006b0:	b9400000 	ldr	w0, [x0]
  2006b4:	528d2ec1 	mov	w1, #0x6976                	// #26998
  2006b8:	72ae8e41 	movk	w1, #0x7472, lsl #16
  2006bc:	6b01001f 	cmp	w0, w1
}
  2006c0:	1a9f17e0 	cset	w0, eq	// eq = none
  2006c4:	d65f03c0 	ret
  2006c8:	d503201f 	nop
  2006cc:	d503201f 	nop

00000000002006d0 <virtio_mmio_check_device_id>:

bool virtio_mmio_check_device_id(virtio_mmio_regs_t *regs, virtio_device_id_t id)
{
    return regs->DeviceID == id;
  2006d0:	b9400800 	ldr	w0, [x0, #8]
  2006d4:	6b01001f 	cmp	w0, w1
}
  2006d8:	1a9f17e0 	cset	w0, eq	// eq = none
  2006dc:	d65f03c0 	ret

00000000002006e0 <virtio_mmio_version>:

uint32_t virtio_mmio_version(virtio_mmio_regs_t *regs)
{
    return regs->Version;
  2006e0:	b9400400 	ldr	w0, [x0, #4]
}
  2006e4:	d65f03c0 	ret
  2006e8:	d503201f 	nop
  2006ec:	d503201f 	nop

00000000002006f0 <virtio_print_reserved_feature_bits>:

void virtio_print_reserved_feature_bits(uint64_t feature)
{
  2006f0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  2006f4:	910003fd 	mov	x29, sp
  2006f8:	f9000bf3 	str	x19, [sp, #16]
  2006fc:	aa0003f3 	mov	x19, x0
    if (feature & ((uint64_t)1 << VIRTIO_F_INDIRECT_DESC)) {
  200700:	37e007e0 	tbnz	w0, #28, 2007fc <virtio_print_reserved_feature_bits+0x10c>
        sddf_dprintf("    VIRTIO_F_INDIRECT_DESC\n");
    }
    if (feature & ((uint64_t)1 << VIRTIO_F_EVENT_IDX)) {
  200704:	37e80733 	tbnz	w19, #29, 2007e8 <virtio_print_reserved_feature_bits+0xf8>
        sddf_dprintf("    VIRTIO_F_EVENT_IDX\n");
    }
    if (feature & ((uint64_t)1 << VIRTIO_F_VERSION_1)) {
  200708:	b7000673 	tbnz	x19, #32, 2007d4 <virtio_print_reserved_feature_bits+0xe4>
        sddf_dprintf("    VIRTIO_F_VERSION_1\n");
    }
    if (feature & ((uint64_t)1 << VIRTIO_F_ACCESS_PLATFORM)) {
  20070c:	b70805b3 	tbnz	x19, #33, 2007c0 <virtio_print_reserved_feature_bits+0xd0>
        sddf_dprintf("    VIRTIO_F_ACCESS_PLATFORM\n");
    }
    if (feature & ((uint64_t)1 << VIRTIO_F_RING_PACKED)) {
  200710:	b71004f3 	tbnz	x19, #34, 2007ac <virtio_print_reserved_feature_bits+0xbc>
        sddf_dprintf("    VIRTIO_F_RING_PACKED\n");
    }
    if (feature & ((uint64_t)1 << VIRTIO_F_IN_ORDER)) {
  200714:	b7180433 	tbnz	x19, #35, 200798 <virtio_print_reserved_feature_bits+0xa8>
        sddf_dprintf("    VIRTIO_F_IN_ORDER\n");
    }
    if (feature & ((uint64_t)1 << VIRTIO_F_ORDER_PLATFORM)) {
  200718:	b7200373 	tbnz	x19, #36, 200784 <virtio_print_reserved_feature_bits+0x94>
        sddf_dprintf("    VIRTIO_F_ORDER_PLATFORM\n");
    }
    if (feature & ((uint64_t)1 << VIRTIO_F_SR_IOV)) {
  20071c:	b72802b3 	tbnz	x19, #37, 200770 <virtio_print_reserved_feature_bits+0x80>
        sddf_dprintf("    VIRTIO_F_SR_IOV\n");
    }
    if (feature & ((uint64_t)1 << VIRTIO_F_NOTIFICATION_DATA)) {
  200720:	b73001f3 	tbnz	x19, #38, 20075c <virtio_print_reserved_feature_bits+0x6c>
        sddf_dprintf("    VIRTIO_F_NOTIFICATION_DATA\n");
    }
    if (feature & ((uint64_t)1 << VIRTIO_F_NOTIF_CONFIG_DATA)) {
  200724:	b73800b3 	tbnz	x19, #39, 200738 <virtio_print_reserved_feature_bits+0x48>
        sddf_dprintf("    VIRTIO_F_NOTIF_CONFIG_DATA\n");
    }
    if (feature & ((uint64_t)1 << VIRTIO_F_RING_RESET)) {
  200728:	b7400113 	tbnz	x19, #40, 200748 <virtio_print_reserved_feature_bits+0x58>
        sddf_dprintf("    VIRTIO_F_RING_RESET\n");
    }
}
  20072c:	f9400bf3 	ldr	x19, [sp, #16]
  200730:	a8c27bfd 	ldp	x29, x30, [sp], #32
  200734:	d65f03c0 	ret
        sddf_dprintf("    VIRTIO_F_NOTIF_CONFIG_DATA\n");
  200738:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  20073c:	91274000 	add	x0, x0, #0x9d0
  200740:	94000af4 	bl	203310 <sddf_printf_>
    if (feature & ((uint64_t)1 << VIRTIO_F_RING_RESET)) {
  200744:	b647ff53 	tbz	x19, #40, 20072c <virtio_print_reserved_feature_bits+0x3c>
}
  200748:	f9400bf3 	ldr	x19, [sp, #16]
        sddf_dprintf("    VIRTIO_F_RING_RESET\n");
  20074c:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  200750:	9127c000 	add	x0, x0, #0x9f0
}
  200754:	a8c27bfd 	ldp	x29, x30, [sp], #32
        sddf_dprintf("    VIRTIO_F_RING_RESET\n");
  200758:	14000aee 	b	203310 <sddf_printf_>
        sddf_dprintf("    VIRTIO_F_NOTIFICATION_DATA\n");
  20075c:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  200760:	9126c000 	add	x0, x0, #0x9b0
  200764:	94000aeb 	bl	203310 <sddf_printf_>
    if (feature & ((uint64_t)1 << VIRTIO_F_NOTIF_CONFIG_DATA)) {
  200768:	b63ffe13 	tbz	x19, #39, 200728 <virtio_print_reserved_feature_bits+0x38>
  20076c:	17fffff3 	b	200738 <virtio_print_reserved_feature_bits+0x48>
        sddf_dprintf("    VIRTIO_F_SR_IOV\n");
  200770:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  200774:	91266000 	add	x0, x0, #0x998
  200778:	94000ae6 	bl	203310 <sddf_printf_>
    if (feature & ((uint64_t)1 << VIRTIO_F_NOTIFICATION_DATA)) {
  20077c:	b637fd53 	tbz	x19, #38, 200724 <virtio_print_reserved_feature_bits+0x34>
  200780:	17fffff7 	b	20075c <virtio_print_reserved_feature_bits+0x6c>
        sddf_dprintf("    VIRTIO_F_ORDER_PLATFORM\n");
  200784:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  200788:	9125e000 	add	x0, x0, #0x978
  20078c:	94000ae1 	bl	203310 <sddf_printf_>
    if (feature & ((uint64_t)1 << VIRTIO_F_SR_IOV)) {
  200790:	b62ffc93 	tbz	x19, #37, 200720 <virtio_print_reserved_feature_bits+0x30>
  200794:	17fffff7 	b	200770 <virtio_print_reserved_feature_bits+0x80>
        sddf_dprintf("    VIRTIO_F_IN_ORDER\n");
  200798:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  20079c:	91258000 	add	x0, x0, #0x960
  2007a0:	94000adc 	bl	203310 <sddf_printf_>
    if (feature & ((uint64_t)1 << VIRTIO_F_ORDER_PLATFORM)) {
  2007a4:	b627fbd3 	tbz	x19, #36, 20071c <virtio_print_reserved_feature_bits+0x2c>
  2007a8:	17fffff7 	b	200784 <virtio_print_reserved_feature_bits+0x94>
        sddf_dprintf("    VIRTIO_F_RING_PACKED\n");
  2007ac:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  2007b0:	91250000 	add	x0, x0, #0x940
  2007b4:	94000ad7 	bl	203310 <sddf_printf_>
    if (feature & ((uint64_t)1 << VIRTIO_F_IN_ORDER)) {
  2007b8:	b61ffb13 	tbz	x19, #35, 200718 <virtio_print_reserved_feature_bits+0x28>
  2007bc:	17fffff7 	b	200798 <virtio_print_reserved_feature_bits+0xa8>
        sddf_dprintf("    VIRTIO_F_ACCESS_PLATFORM\n");
  2007c0:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  2007c4:	91248000 	add	x0, x0, #0x920
  2007c8:	94000ad2 	bl	203310 <sddf_printf_>
    if (feature & ((uint64_t)1 << VIRTIO_F_RING_PACKED)) {
  2007cc:	b617fa53 	tbz	x19, #34, 200714 <virtio_print_reserved_feature_bits+0x24>
  2007d0:	17fffff7 	b	2007ac <virtio_print_reserved_feature_bits+0xbc>
        sddf_dprintf("    VIRTIO_F_VERSION_1\n");
  2007d4:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  2007d8:	91242000 	add	x0, x0, #0x908
  2007dc:	94000acd 	bl	203310 <sddf_printf_>
    if (feature & ((uint64_t)1 << VIRTIO_F_ACCESS_PLATFORM)) {
  2007e0:	b60ff993 	tbz	x19, #33, 200710 <virtio_print_reserved_feature_bits+0x20>
  2007e4:	17fffff7 	b	2007c0 <virtio_print_reserved_feature_bits+0xd0>
        sddf_dprintf("    VIRTIO_F_EVENT_IDX\n");
  2007e8:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  2007ec:	9123c000 	add	x0, x0, #0x8f0
  2007f0:	94000ac8 	bl	203310 <sddf_printf_>
    if (feature & ((uint64_t)1 << VIRTIO_F_VERSION_1)) {
  2007f4:	b607f8d3 	tbz	x19, #32, 20070c <virtio_print_reserved_feature_bits+0x1c>
  2007f8:	17fffff7 	b	2007d4 <virtio_print_reserved_feature_bits+0xe4>
        sddf_dprintf("    VIRTIO_F_INDIRECT_DESC\n");
  2007fc:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  200800:	91234000 	add	x0, x0, #0x8d0
  200804:	94000ac3 	bl	203310 <sddf_printf_>
    if (feature & ((uint64_t)1 << VIRTIO_F_EVENT_IDX)) {
  200808:	36eff813 	tbz	w19, #29, 200708 <virtio_print_reserved_feature_bits+0x18>
  20080c:	17fffff7 	b	2007e8 <virtio_print_reserved_feature_bits+0xf8>

0000000000200810 <init>:
    regs->Status = VIRTIO_DEVICE_STATUS_DRIVER_OK;
    regs->InterruptACK = VIRTIO_MMIO_IRQ_VQUEUE;
}

void init(void)
{
  200810:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  200814:	910003fd 	mov	x29, sp
  200818:	a9025bf5 	stp	x21, x22, [sp, #32]

static bool net_config_check_magic(void *config)
{
    char *magic = (char *)config;
    for (int i = 0; i < SDDF_NET_MAGIC_LEN; i++) {
        if (magic[i] != SDDF_NET_MAGIC[i]) {
  20081c:	90000020 	adrp	x0, 204000 <__sel4_ipc_buffer>
  200820:	91194016 	add	x22, x0, #0x650
  200824:	39594000 	ldrb	w0, [x0, #1616]
  200828:	a90153f3 	stp	x19, x20, [sp, #16]
  20082c:	7101cc1f 	cmp	w0, #0x73
  200830:	a90363f7 	stp	x23, x24, [sp, #48]
  200834:	54002961 	b.ne	200d60 <init+0x550>  // b.any
  200838:	394006c0 	ldrb	w0, [x22, #1]
  20083c:	7101101f 	cmp	w0, #0x44
  200840:	54002901 	b.ne	200d60 <init+0x550>  // b.any
  200844:	39400ac0 	ldrb	w0, [x22, #2]
  200848:	7101101f 	cmp	w0, #0x44
  20084c:	540028a1 	b.ne	200d60 <init+0x550>  // b.any
  200850:	39400ec0 	ldrb	w0, [x22, #3]
  200854:	7101181f 	cmp	w0, #0x46
  200858:	54002841 	b.ne	200d60 <init+0x550>  // b.any
  20085c:	394012c0 	ldrb	w0, [x22, #4]
  200860:	7100141f 	cmp	w0, #0x5
  200864:	540027e1 	b.ne	200d60 <init+0x550>  // b.any
} device_resources_t;

static bool device_resources_check_magic(device_resources_t *device)
{
    for (int i = 0; i < DEVICE_MAGIC_LEN; i++) {
        if (device->magic[i] != DEVICE_MAGIC[i]) {
  200868:	90000020 	adrp	x0, 204000 <__sel4_ipc_buffer>
  20086c:	91002015 	add	x21, x0, #0x8
  200870:	39402000 	ldrb	w0, [x0, #8]
  200874:	7101cc1f 	cmp	w0, #0x73
  200878:	54002601 	b.ne	200d38 <init+0x528>  // b.any
  20087c:	394006a0 	ldrb	w0, [x21, #1]
  200880:	7101101f 	cmp	w0, #0x44
  200884:	540025a1 	b.ne	200d38 <init+0x528>  // b.any
  200888:	39400aa0 	ldrb	w0, [x21, #2]
  20088c:	7101101f 	cmp	w0, #0x44
  200890:	54002541 	b.ne	200d38 <init+0x528>  // b.any
  200894:	39400ea0 	ldrb	w0, [x21, #3]
  200898:	7101181f 	cmp	w0, #0x46
  20089c:	540024e1 	b.ne	200d38 <init+0x528>  // b.any
  2008a0:	394012a0 	ldrb	w0, [x21, #4]
  2008a4:	7100041f 	cmp	w0, #0x1
  2008a8:	54002481 	b.ne	200d38 <init+0x528>  // b.any
    assert(net_config_check_magic((void *)&config));
    assert(device_resources_check_magic(&device_resources));
    assert(device_resources.num_irqs == 1);
  2008ac:	39401aa0 	ldrb	w0, [x21, #6]
  2008b0:	7100041f 	cmp	w0, #0x1
  2008b4:	54000140 	b.eq	2008dc <init+0xcc>  // b.none
  2008b8:	f0000003 	adrp	x3, 203000 <_vsnprintf+0x9f0>
  2008bc:	911a2063 	add	x3, x3, #0x688
  2008c0:	f0000001 	adrp	x1, 203000 <_vsnprintf+0x9f0>
  2008c4:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  2008c8:	91008063 	add	x3, x3, #0x20
  2008cc:	911f0021 	add	x1, x1, #0x7c0
  2008d0:	9129a000 	add	x0, x0, #0xa68
  2008d4:	52803762 	mov	w2, #0x1bb                 	// #443
  2008d8:	94000b4a 	bl	203600 <_assert_fail>
    assert(device_resources.num_regions == 2);
  2008dc:	394016a0 	ldrb	w0, [x21, #5]
  2008e0:	7100081f 	cmp	w0, #0x2
  2008e4:	54000140 	b.eq	20090c <init+0xfc>  // b.none
  2008e8:	f0000003 	adrp	x3, 203000 <_vsnprintf+0x9f0>
  2008ec:	911a2063 	add	x3, x3, #0x688
  2008f0:	f0000001 	adrp	x1, 203000 <_vsnprintf+0x9f0>
  2008f4:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  2008f8:	91008063 	add	x3, x3, #0x20
  2008fc:	911f0021 	add	x1, x1, #0x7c0
  200900:	912a2000 	add	x0, x0, #0xa88
  200904:	52803782 	mov	w2, #0x1bc                 	// #444
  200908:	94000b3e 	bl	203600 <_assert_fail>

    regs = (volatile virtio_mmio_regs_t *)device_resources.regions[0].region.vaddr;
  20090c:	90000037 	adrp	x23, 204000 <__sel4_ipc_buffer>
  200910:	911ac2f3 	add	x19, x23, #0x6b0
 * @param size number of indices that can be allocated.
 */
static void ialloc_init(ialloc_t *ia, uint32_t *idxlist, uint32_t size)
{
    assert(size < -1);
    ia->idxlist = idxlist;
  200914:	9103c263 	add	x3, x19, #0xf0
    ia->head = 0;
    ia->tail = size - 1;
    ia->num_free = size;
    ia->size = size;
  200918:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  20091c:	3dc3a001 	ldr	q1, [x0, #3712]
    ia->head = 0;
  200920:	d2c03fe5 	mov	x5, #0x1ff00000000         	// #2194728288256
  200924:	4f000483 	movi	v3.4s, #0x4
  200928:	aa0303e0 	mov	x0, x3
    ia->offset = 0;
    for (uint32_t i = 0; i < size - 1; i++) {
        ia->idxlist[i] = i + 1;
  20092c:	4f000422 	movi	v2.4s, #0x1
  200930:	91238261 	add	x1, x19, #0x8e0
  200934:	f94006b4 	ldr	x20, [x21, #8]
    ia->head = 0;
  200938:	a9041663 	stp	x3, x5, [x19, #64]
    ia->num_free = size;
  20093c:	d2804004 	mov	x4, #0x200                 	// #512
    hw_ring_buffer_vaddr = (uintptr_t)device_resources.regions[1].region.vaddr;
  200940:	f94012a6 	ldr	x6, [x21, #32]
  200944:	f9002a64 	str	x4, [x19, #80]
    hw_ring_buffer_paddr = device_resources.regions[1].io_addr;
  200948:	f9401aa5 	ldr	x5, [x21, #48]
    ia->size = size;
  20094c:	b9005a64 	str	w4, [x19, #88]
    regs = (volatile virtio_mmio_regs_t *)device_resources.regions[0].region.vaddr;
  200950:	f9003674 	str	x20, [x19, #104]
    hw_ring_buffer_vaddr = (uintptr_t)device_resources.regions[1].region.vaddr;
  200954:	f9007266 	str	x6, [x19, #224]
    hw_ring_buffer_paddr = device_resources.regions[1].io_addr;
  200958:	f9007665 	str	x5, [x19, #232]
    for (uint32_t i = 0; i < size - 1; i++) {
  20095c:	d503201f 	nop
  200960:	4ea11c20 	mov	v0.16b, v1.16b
  200964:	4ea38421 	add	v1.4s, v1.4s, v3.4s
        ia->idxlist[i] = i + 1;
  200968:	4ea28400 	add	v0.4s, v0.4s, v2.4s
  20096c:	3c810400 	str	q0, [x0], #16
    for (uint32_t i = 0; i < size - 1; i++) {
  200970:	eb00003f 	cmp	x1, x0
  200974:	54ffff61 	b.ne	200960 <init+0x150>  // b.any
    ia->idxlist = idxlist;
  200978:	9123c263 	add	x3, x19, #0x8f0
        ia->idxlist[i] = i + 1;
  20097c:	f0000001 	adrp	x1, 203000 <_vsnprintf+0x9f0>
  200980:	3dc3a420 	ldr	q0, [x1, #3728]
    ia->size = size;
  200984:	f0000004 	adrp	x4, 203000 <_vsnprintf+0x9f0>
  200988:	3dc3a081 	ldr	q1, [x4, #3712]
  20098c:	aa0303e0 	mov	x0, x3
  200990:	4f000483 	movi	v3.4s, #0x4
  200994:	911fc061 	add	x1, x3, #0x7f0
        ia->idxlist[i] = i + 1;
  200998:	4f000422 	movi	v2.4s, #0x1
    ia->num_free = size;
  20099c:	d2804004 	mov	x4, #0x200                 	// #512
    ia->head = 0;
  2009a0:	d2c03fe5 	mov	x5, #0x1ff00000000         	// #2194728288256
  2009a4:	a90b1663 	stp	x3, x5, [x19, #176]
    ia->num_free = size;
  2009a8:	f9006264 	str	x4, [x19, #192]
    ia->size = size;
  2009ac:	b900ca64 	str	w4, [x19, #200]
        ia->idxlist[i] = i + 1;
  2009b0:	3d823a60 	str	q0, [x19, #2272]
    for (uint32_t i = 0; i < size - 1; i++) {
  2009b4:	d503201f 	nop
  2009b8:	4ea11c20 	mov	v0.16b, v1.16b
  2009bc:	4ea38421 	add	v1.4s, v1.4s, v3.4s
        ia->idxlist[i] = i + 1;
  2009c0:	4ea28400 	add	v0.4s, v0.4s, v2.4s
  2009c4:	3c810400 	str	q0, [x0], #16
    for (uint32_t i = 0; i < size - 1; i++) {
  2009c8:	eb00003f 	cmp	x1, x0
  2009cc:	54ffff61 	b.ne	2009b8 <init+0x1a8>  // b.any
        ia->idxlist[i] = i + 1;
  2009d0:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  2009d4:	3dc3a400 	ldr	q0, [x0, #3728]
    queue->free = free;
  2009d8:	f94006c3 	ldr	x3, [x22, #8]

    ialloc_init(&rx_ialloc_desc, rx_descriptors, RX_COUNT);
    ialloc_init(&tx_ialloc_desc, tx_descriptors, TX_COUNT);

    net_queue_init(&rx_queue, config.virt_rx.free_queue.vaddr, config.virt_rx.active_queue.vaddr,
  2009dc:	f9400ec2 	ldr	x2, [x22, #24]
  2009e0:	3d843a60 	str	q0, [x19, #4320]
  2009e4:	794052c5 	ldrh	w5, [x22, #40]
    return regs->MagicValue == 0x74726976;
  2009e8:	b9400284 	ldr	w4, [x20]
                   config.virt_rx.num_buffers);
    net_queue_init(&tx_queue, config.virt_tx.free_queue.vaddr, config.virt_tx.active_queue.vaddr,
  2009ec:	f94022c0 	ldr	x0, [x22, #64]
    queue->active = active;
  2009f0:	a9028a63 	stp	x3, x2, [x19, #40]
    queue->free = free;
  2009f4:	f9401ac2 	ldr	x2, [x22, #48]
    queue->capacity = capacity;
  2009f8:	b9003a65 	str	w5, [x19, #56]
  2009fc:	7940a2c5 	ldrh	w5, [x22, #80]
    queue->free = free;
  200a00:	f9004e62 	str	x2, [x19, #152]
    queue->active = active;
  200a04:	f9005260 	str	x0, [x19, #160]
    if (!virtio_mmio_check_magic(regs)) {
  200a08:	528d2ec0 	mov	w0, #0x6976                	// #26998
  200a0c:	72ae8e40 	movk	w0, #0x7472, lsl #16
    queue->capacity = capacity;
  200a10:	b900aa65 	str	w5, [x19, #168]
  200a14:	6b00009f 	cmp	w4, w0
  200a18:	54000220 	b.eq	200a5c <init+0x24c>  // b.none
        LOG_DRIVER_ERR("invalid virtIO magic value!\n");
  200a1c:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  200a20:	912ac000 	add	x0, x0, #0xab0
  200a24:	94000a3b 	bl	203310 <sddf_printf_>
  200a28:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  200a2c:	912b2000 	add	x0, x0, #0xac8
  200a30:	94000a38 	bl	203310 <sddf_printf_>
        assert(false);
  200a34:	f0000003 	adrp	x3, 203000 <_vsnprintf+0x9f0>
  200a38:	911a2063 	add	x3, x3, #0x688
  200a3c:	9100a063 	add	x3, x3, #0x28
  200a40:	f0000001 	adrp	x1, 203000 <_vsnprintf+0x9f0>
  200a44:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  200a48:	911f0021 	add	x1, x1, #0x7c0
  200a4c:	912ba000 	add	x0, x0, #0xae8
  200a50:	52802702 	mov	w2, #0x138                 	// #312
  200a54:	94000aeb 	bl	203600 <_assert_fail>
    if (virtio_mmio_version(regs) != VIRTIO_VERSION) {
  200a58:	f9403674 	ldr	x20, [x19, #104]
    return regs->Version;
  200a5c:	b9400680 	ldr	w0, [x20, #4]
  200a60:	7100081f 	cmp	w0, #0x2
  200a64:	54000220 	b.eq	200aa8 <init+0x298>  // b.none
        LOG_DRIVER_ERR("not correct virtIO version!\n");
  200a68:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  200a6c:	912ac000 	add	x0, x0, #0xab0
  200a70:	94000a28 	bl	203310 <sddf_printf_>
  200a74:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  200a78:	912bc000 	add	x0, x0, #0xaf0
  200a7c:	94000a25 	bl	203310 <sddf_printf_>
        assert(false);
  200a80:	f0000003 	adrp	x3, 203000 <_vsnprintf+0x9f0>
  200a84:	911a2063 	add	x3, x3, #0x688
  200a88:	9100a063 	add	x3, x3, #0x28
  200a8c:	f0000001 	adrp	x1, 203000 <_vsnprintf+0x9f0>
  200a90:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  200a94:	911f0021 	add	x1, x1, #0x7c0
  200a98:	912ba000 	add	x0, x0, #0xae8
  200a9c:	528027a2 	mov	w2, #0x13d                 	// #317
  200aa0:	94000ad8 	bl	203600 <_assert_fail>
    if (!virtio_mmio_check_device_id(regs, VIRTIO_DEVICE_ID_NET)) {
  200aa4:	f9403674 	ldr	x20, [x19, #104]
    return regs->DeviceID == id;
  200aa8:	b9400a80 	ldr	w0, [x20, #8]
  200aac:	7100041f 	cmp	w0, #0x1
  200ab0:	54000220 	b.eq	200af4 <init+0x2e4>  // b.none
        LOG_DRIVER_ERR("not a virtIO network device!\n");
  200ab4:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  200ab8:	912ac000 	add	x0, x0, #0xab0
  200abc:	94000a15 	bl	203310 <sddf_printf_>
  200ac0:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  200ac4:	912c4000 	add	x0, x0, #0xb10
  200ac8:	94000a12 	bl	203310 <sddf_printf_>
        assert(false);
  200acc:	f0000003 	adrp	x3, 203000 <_vsnprintf+0x9f0>
  200ad0:	911a2063 	add	x3, x3, #0x688
  200ad4:	9100a063 	add	x3, x3, #0x28
  200ad8:	f0000001 	adrp	x1, 203000 <_vsnprintf+0x9f0>
  200adc:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  200ae0:	911f0021 	add	x1, x1, #0x7c0
  200ae4:	912ba000 	add	x0, x0, #0xae8
  200ae8:	52802842 	mov	w2, #0x142                 	// #322
  200aec:	94000ac5 	bl	203600 <_assert_fail>
    regs->Status = 0;
  200af0:	f9403674 	ldr	x20, [x19, #104]
  200af4:	b900729f 	str	wzr, [x20, #112]
    regs->Status = VIRTIO_DEVICE_STATUS_ACKNOWLEDGE;
  200af8:	52800020 	mov	w0, #0x1                   	// #1
  200afc:	b9007280 	str	w0, [x20, #112]
    regs->Status = VIRTIO_DEVICE_STATUS_DRIVER;
  200b00:	52800041 	mov	w1, #0x2                   	// #2
  200b04:	b9007281 	str	w1, [x20, #112]
    regs->DriverFeatures = VIRTIO_NET_F_MAC;
  200b08:	528000a1 	mov	w1, #0x5                   	// #5
  200b0c:	b9002281 	str	w1, [x20, #32]
    regs->DriverFeaturesSel = 1;
  200b10:	b9002680 	str	w0, [x20, #36]
    regs->DriverFeatures = VIRTIO_F_VERSION_1;
  200b14:	52800400 	mov	w0, #0x20                  	// #32
  200b18:	b9002280 	str	w0, [x20, #32]
    regs->Status = VIRTIO_DEVICE_STATUS_FEATURES_OK;
  200b1c:	52800100 	mov	w0, #0x8                   	// #8
  200b20:	b9007280 	str	w0, [x20, #112]
    if (!(regs->Status & VIRTIO_DEVICE_STATUS_FEATURES_OK)) {
  200b24:	b9407280 	ldr	w0, [x20, #112]
  200b28:	36181d80 	tbz	w0, #3, 200ed8 <init+0x6c8>
    rx_virtq.desc = (struct virtq_desc *)(hw_ring_buffer_vaddr + rx_desc_off);
  200b2c:	f9407260 	ldr	x0, [x19, #224]
    rx_virtq.num = RX_COUNT;
  200b30:	52804001 	mov	w1, #0x200                 	// #512
    rx_virtq.used = (struct virtq_used *)(hw_ring_buffer_vaddr + rx_used_off);
  200b34:	d2848111 	mov	x17, #0x2408                	// #9224
    rx_virtq.num = RX_COUNT;
  200b38:	b906b2e1 	str	w1, [x23, #1712]
    rx_virtq.avail = (struct virtq_avail *)(hw_ring_buffer_vaddr + rx_avail_off);
  200b3c:	91400802 	add	x2, x0, #0x2, lsl #12
    rx_virtq.used = (struct virtq_used *)(hw_ring_buffer_vaddr + rx_used_off);
  200b40:	8b110001 	add	x1, x0, x17
    rx_virtq.avail = (struct virtq_avail *)(hw_ring_buffer_vaddr + rx_avail_off);
  200b44:	a9008a60 	stp	x0, x2, [x19, #8]
    assert((uintptr_t)rx_virtq.desc % 16 == 0);
  200b48:	92400c00 	and	x0, x0, #0xf
    rx_virtq.used = (struct virtq_used *)(hw_ring_buffer_vaddr + rx_used_off);
  200b4c:	f9000e61 	str	x1, [x19, #24]
    assert((uintptr_t)rx_virtq.desc % 16 == 0);
  200b50:	b50019c0 	cbnz	x0, 200e88 <init+0x678>
    assert((uintptr_t)rx_virtq.used % 4 == 0);
  200b54:	f9400e60 	ldr	x0, [x19, #24]
  200b58:	92400400 	and	x0, x0, #0x3
  200b5c:	b5001820 	cbnz	x0, 200e60 <init+0x650>
    tx_virtq.desc = (struct virtq_desc *)(hw_ring_buffer_vaddr + tx_desc_off);
  200b60:	f9407260 	ldr	x0, [x19, #224]
    tx_virtq.num = TX_COUNT;
  200b64:	52804001 	mov	w1, #0x200                 	// #512
    tx_virtq.avail = (struct virtq_avail *)(hw_ring_buffer_vaddr + tx_avail_off);
  200b68:	d28a820e 	mov	x14, #0x5410                	// #21520
    tx_virtq.desc = (struct virtq_desc *)(hw_ring_buffer_vaddr + tx_desc_off);
  200b6c:	d286820f 	mov	x15, #0x3410                	// #13328
    tx_virtq.avail = (struct virtq_avail *)(hw_ring_buffer_vaddr + tx_avail_off);
  200b70:	8b0e0002 	add	x2, x0, x14
    tx_virtq.used = (struct virtq_used *)(hw_ring_buffer_vaddr + tx_used_off);
  200b74:	d28b0310 	mov	x16, #0x5818                	// #22552
    tx_virtq.num = TX_COUNT;
  200b78:	b9007261 	str	w1, [x19, #112]
    tx_virtq.desc = (struct virtq_desc *)(hw_ring_buffer_vaddr + tx_desc_off);
  200b7c:	8b0f0001 	add	x1, x0, x15
    tx_virtq.used = (struct virtq_used *)(hw_ring_buffer_vaddr + tx_used_off);
  200b80:	8b100000 	add	x0, x0, x16
    tx_virtq.desc = (struct virtq_desc *)(hw_ring_buffer_vaddr + tx_desc_off);
  200b84:	f9003e61 	str	x1, [x19, #120]
    tx_virtq.avail = (struct virtq_avail *)(hw_ring_buffer_vaddr + tx_avail_off);
  200b88:	f9004262 	str	x2, [x19, #128]
    assert((uintptr_t)tx_virtq.desc % 16 == 0);
  200b8c:	92400c21 	and	x1, x1, #0xf
    tx_virtq.used = (struct virtq_used *)(hw_ring_buffer_vaddr + tx_used_off);
  200b90:	f9004660 	str	x0, [x19, #136]
    assert((uintptr_t)tx_virtq.desc % 16 == 0);
  200b94:	b50013e1 	cbnz	x1, 200e10 <init+0x600>
    assert((uintptr_t)tx_virtq.used % 4 == 0);
  200b98:	f9404660 	ldr	x0, [x19, #136]
  200b9c:	92400400 	and	x0, x0, #0x3
  200ba0:	b5001240 	cbnz	x0, 200de8 <init+0x5d8>
    virtio_net_tx_headers_paddr = hw_ring_buffer_paddr + virtq_size;
  200ba4:	a94e0a61 	ldp	x1, x2, [x19, #224]
    virtio_net_rx_headers_paddr = virtio_net_tx_headers_paddr + tx_headers_size;
  200ba8:	d28e43cd 	mov	x13, #0x721e                	// #29214
    virtio_net_tx_headers_vaddr = hw_ring_buffer_vaddr + virtq_size;
  200bac:	d28d03c0 	mov	x0, #0x681e                	// #26654
  200bb0:	b0000023 	adrp	x3, 205000 <tx_descriptors+0x60>
  200bb4:	8b000021 	add	x1, x1, x0
    virtio_net_tx_headers_paddr = hw_ring_buffer_paddr + virtq_size;
  200bb8:	8b000040 	add	x0, x2, x0
    virtio_net_rx_headers_paddr = virtio_net_tx_headers_paddr + tx_headers_size;
  200bbc:	8b0d0042 	add	x2, x2, x13
    virtio_net_tx_headers_vaddr = hw_ring_buffer_vaddr + virtq_size;
  200bc0:	f903d061 	str	x1, [x3, #1952]
    virtio_net_rx_headers_paddr = virtio_net_tx_headers_paddr + tx_headers_size;
  200bc4:	f9003262 	str	x2, [x19, #96]
    virtio_net_tx_headers_paddr = hw_ring_buffer_paddr + virtq_size;
  200bc8:	a90d0261 	stp	x1, x0, [x19, #208]
    rx_provide();
  200bcc:	97fffd11 	bl	200010 <rx_provide>
    tx_provide();
  200bd0:	97fffde0 	bl	200350 <tx_provide>
    assert(regs->QueueNumMax >= RX_COUNT);
  200bd4:	f9403660 	ldr	x0, [x19, #104]
  200bd8:	b9403401 	ldr	w1, [x0, #52]
  200bdc:	7107fc3f 	cmp	w1, #0x1ff
  200be0:	54000ee9 	b.ls	200dbc <init+0x5ac>  // b.plast
    regs->QueueDescLow = (hw_ring_buffer_paddr + rx_desc_off) & 0xFFFFFFFF;
  200be4:	f9407661 	ldr	x1, [x19, #232]
    regs->QueueSel = VIRTIO_NET_RX_QUEUE;
  200be8:	b900301f 	str	wzr, [x0, #48]
    regs->QueueNum = RX_COUNT;
  200bec:	52804002 	mov	w2, #0x200                 	// #512
  200bf0:	b9003802 	str	w2, [x0, #56]
    regs->QueueDescLow = (hw_ring_buffer_paddr + rx_desc_off) & 0xFFFFFFFF;
  200bf4:	b9008001 	str	w1, [x0, #128]
    regs->QueueDriverHigh = (hw_ring_buffer_paddr + rx_avail_off) >> 32;
  200bf8:	91400823 	add	x3, x1, #0x2, lsl #12
    regs->QueueDescHigh = (hw_ring_buffer_paddr + rx_desc_off) >> 32;
  200bfc:	d360fc22 	lsr	x2, x1, #32
  200c00:	b9008402 	str	w2, [x0, #132]
    regs->QueueDriverLow = (hw_ring_buffer_paddr + rx_avail_off) & 0xFFFFFFFF;
  200c04:	11400822 	add	w2, w1, #0x2, lsl #12
  200c08:	b9009002 	str	w2, [x0, #144]
    regs->QueueDriverHigh = (hw_ring_buffer_paddr + rx_avail_off) >> 32;
  200c0c:	d360fc63 	lsr	x3, x3, #32
    regs->QueueDeviceHigh = (hw_ring_buffer_paddr + rx_used_off) >> 32;
  200c10:	d284810b 	mov	x11, #0x2408                	// #9224
  200c14:	8b0b0022 	add	x2, x1, x11
    regs->QueueDriverHigh = (hw_ring_buffer_paddr + rx_avail_off) >> 32;
  200c18:	b9009403 	str	w3, [x0, #148]
    regs->QueueDeviceLow = (hw_ring_buffer_paddr + rx_used_off) & 0xFFFFFFFF;
  200c1c:	5284810c 	mov	w12, #0x2408                	// #9224
  200c20:	0b0c0023 	add	w3, w1, w12
  200c24:	b900a003 	str	w3, [x0, #160]
    regs->QueueDeviceHigh = (hw_ring_buffer_paddr + rx_used_off) >> 32;
  200c28:	d360fc42 	lsr	x2, x2, #32
  200c2c:	b900a402 	str	w2, [x0, #164]
    regs->QueueReady = 1;
  200c30:	52800024 	mov	w4, #0x1                   	// #1
  200c34:	b9004404 	str	w4, [x0, #68]
    regs->QueueDescLow = (hw_ring_buffer_paddr + rx_desc_off) & 0xFFFFFFFF;
  200c38:	2a0103e2 	mov	w2, w1
    assert(regs->QueueNumMax >= TX_COUNT);
  200c3c:	b9403403 	ldr	w3, [x0, #52]
  200c40:	7107fc7f 	cmp	w3, #0x1ff
  200c44:	54000a29 	b.ls	200d88 <init+0x578>  // b.plast
    regs->QueueSel = VIRTIO_NET_TX_QUEUE;
  200c48:	52800023 	mov	w3, #0x1                   	// #1
  200c4c:	b9003003 	str	w3, [x0, #48]
    regs->QueueNum = TX_COUNT;
  200c50:	52804004 	mov	w4, #0x200                 	// #512
    regs->QueueDescHigh = (hw_ring_buffer_paddr + tx_desc_off) >> 32;
  200c54:	d2868205 	mov	x5, #0x3410                	// #13328
  200c58:	8b050025 	add	x5, x1, x5
    regs->QueueNum = TX_COUNT;
  200c5c:	b9003804 	str	w4, [x0, #56]
    regs->QueueDescLow = (hw_ring_buffer_paddr + tx_desc_off) & 0xFFFFFFFF;
  200c60:	52868206 	mov	w6, #0x3410                	// #13328
  200c64:	0b060044 	add	w4, w2, w6
  200c68:	b9008004 	str	w4, [x0, #128]
    regs->QueueDescHigh = (hw_ring_buffer_paddr + tx_desc_off) >> 32;
  200c6c:	d360fca5 	lsr	x5, x5, #32
    regs->QueueDriverHigh = (hw_ring_buffer_paddr + tx_avail_off) >> 32;
  200c70:	d28a8207 	mov	x7, #0x5410                	// #21520
  200c74:	8b070024 	add	x4, x1, x7
    regs->QueueDescHigh = (hw_ring_buffer_paddr + tx_desc_off) >> 32;
  200c78:	b9008405 	str	w5, [x0, #132]
    regs->QueueDriverLow = (hw_ring_buffer_paddr + tx_avail_off) & 0xFFFFFFFF;
  200c7c:	528a8208 	mov	w8, #0x5410                	// #21520
  200c80:	0b080045 	add	w5, w2, w8
  200c84:	b9009005 	str	w5, [x0, #144]
    regs->QueueDriverHigh = (hw_ring_buffer_paddr + tx_avail_off) >> 32;
  200c88:	d360fc84 	lsr	x4, x4, #32
    regs->QueueDeviceHigh = (hw_ring_buffer_paddr + tx_used_off) >> 32;
  200c8c:	d28b0309 	mov	x9, #0x5818                	// #22552
  200c90:	8b090021 	add	x1, x1, x9
    regs->QueueDriverHigh = (hw_ring_buffer_paddr + tx_avail_off) >> 32;
  200c94:	b9009404 	str	w4, [x0, #148]
    regs->QueueDeviceLow = (hw_ring_buffer_paddr + tx_used_off) & 0xFFFFFFFF;
  200c98:	528b030a 	mov	w10, #0x5818                	// #22552
  200c9c:	0b0a0042 	add	w2, w2, w10
  200ca0:	b900a002 	str	w2, [x0, #160]
    regs->QueueDeviceHigh = (hw_ring_buffer_paddr + tx_used_off) >> 32;
  200ca4:	d360fc21 	lsr	x1, x1, #32
  200ca8:	b900a401 	str	w1, [x0, #164]
    config->mac[0] = 0x52;
  200cac:	52800a41 	mov	w1, #0x52                  	// #82
    regs->QueueReady = 1;
  200cb0:	b9004403 	str	w3, [x0, #68]
    config->mac[5] = 0x07;
  200cb4:	528000e4 	mov	w4, #0x7                   	// #7
    config->mac[0] = 0x52;
  200cb8:	39040281 	strb	w1, [x20, #256]
    config->mac[1] = 0x54;
  200cbc:	52800a81 	mov	w1, #0x54                  	// #84
  200cc0:	39040681 	strb	w1, [x20, #257]
    regs->Status = VIRTIO_DEVICE_STATUS_DRIVER_OK;
  200cc4:	52800081 	mov	w1, #0x4                   	// #4
    config->mac[2] = 0x01;
  200cc8:	39040a83 	strb	w3, [x20, #258]
    config->mac[3] = 0x00;
  200ccc:	39040e9f 	strb	wzr, [x20, #259]
    config->mac[4] = 0x00;
  200cd0:	3904129f 	strb	wzr, [x20, #260]
    config->mac[5] = 0x07;
  200cd4:	39041684 	strb	w4, [x20, #261]
    regs->Status = VIRTIO_DEVICE_STATUS_DRIVER_OK;
  200cd8:	b9007001 	str	w1, [x0, #112]
    regs->InterruptACK = VIRTIO_MMIO_IRQ_VQUEUE;
  200cdc:	b9006403 	str	w3, [x0, #100]
    seL4_Signal(BASE_OUTPUT_NOTIFICATION_CAP + ch);
}

static inline void microkit_irq_ack(microkit_channel ch)
{
    seL4_IRQHandler_Ack(BASE_IRQ_CAP + ch);
  200ce0:	395822a0 	ldrb	w0, [x21, #1544]
static inline void arm_sys_send_recv(seL4_Word sys, seL4_Word dest, seL4_Word *out_badge, seL4_Word info_arg,
                                     seL4_Word *out_info, seL4_Word *in_out_mr0, seL4_Word *in_out_mr1, seL4_Word *in_out_mr2, seL4_Word *in_out_mr3,
                                     LIBSEL4_UNUSED seL4_Word reply)
{
    register seL4_Word destptr asm("x0") = dest;
    register seL4_Word info asm("x1") = info_arg;
  200ce4:	d2940001 	mov	x1, #0xa000                	// #40960
  200ce8:	f2a00021 	movk	x1, #0x1, lsl #16

    /* Load beginning of the message into registers. */
    register seL4_Word msg0 asm("x2") = *in_out_mr0;
  200cec:	d2800002 	mov	x2, #0x0                   	// #0
  200cf0:	91022800 	add	x0, x0, #0x8a
    register seL4_Word msg1 asm("x3") = *in_out_mr1;
  200cf4:	d2800003 	mov	x3, #0x0                   	// #0
    register seL4_Word msg2 asm("x4") = *in_out_mr2;
  200cf8:	d2800004 	mov	x4, #0x0                   	// #0
    register seL4_Word msg3 asm("x5") = *in_out_mr3;
  200cfc:	d2800005 	mov	x5, #0x0                   	// #0
    MCS_PARAM_DECL("x6");
  200d00:	d2800006 	mov	x6, #0x0                   	// #0

    /* Perform the system call. */
    register seL4_Word scno asm("x7") = sys;
  200d04:	92800007 	mov	x7, #0xffffffffffffffff    	// #-1
    asm volatile(
  200d08:	d4000001 	svc	#0x0
	output_tag = seL4_CallWithMRs(_service, tag,
		&mr0, &mr1, &mr2, &mr3);
	result = (seL4_Error) seL4_MessageInfo_get_label(output_tag);

	/* Unmarshal registers into IPC buffer on error. */
	if (result != seL4_NoError) {
  200d0c:	f2747c3f 	tst	x1, #0xffffffff000
  200d10:	540000a0 	b.eq	200d24 <init+0x514>  // b.none
    return;
}

LIBSEL4_INLINE_FUNC seL4_IPCBuffer *seL4_GetIPCBuffer(void)
{
    return __sel4_ipc_buffer;
  200d14:	90000020 	adrp	x0, 204000 <__sel4_ipc_buffer>
  200d18:	f9400000 	ldr	x0, [x0]
    return seL4_GetIPCBuffer()->msg[i];
}

LIBSEL4_INLINE_FUNC void seL4_SetMR(int i, seL4_Word mr)
{
    seL4_GetIPCBuffer()->msg[i] = mr;
  200d1c:	a9008c02 	stp	x2, x3, [x0, #8]
  200d20:	a9019404 	stp	x4, x5, [x0, #24]
                   config.virt_tx.num_buffers);

    eth_setup();

    microkit_irq_ack(device_resources.irqs[0].id);
}
  200d24:	a94153f3 	ldp	x19, x20, [sp, #16]
  200d28:	a9425bf5 	ldp	x21, x22, [sp, #32]
  200d2c:	a94363f7 	ldp	x23, x24, [sp, #48]
  200d30:	a8c47bfd 	ldp	x29, x30, [sp], #64
  200d34:	d65f03c0 	ret
    assert(device_resources_check_magic(&device_resources));
  200d38:	f0000003 	adrp	x3, 203000 <_vsnprintf+0x9f0>
  200d3c:	911a2063 	add	x3, x3, #0x688
  200d40:	91008063 	add	x3, x3, #0x20
  200d44:	f0000001 	adrp	x1, 203000 <_vsnprintf+0x9f0>
  200d48:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  200d4c:	911f0021 	add	x1, x1, #0x7c0
  200d50:	9128e000 	add	x0, x0, #0xa38
  200d54:	52803742 	mov	w2, #0x1ba                 	// #442
  200d58:	94000a2a 	bl	203600 <_assert_fail>
  200d5c:	17fffed4 	b	2008ac <init+0x9c>
    assert(net_config_check_magic((void *)&config));
  200d60:	f0000003 	adrp	x3, 203000 <_vsnprintf+0x9f0>
  200d64:	911a2063 	add	x3, x3, #0x688
  200d68:	91008063 	add	x3, x3, #0x20
  200d6c:	f0000001 	adrp	x1, 203000 <_vsnprintf+0x9f0>
  200d70:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  200d74:	911f0021 	add	x1, x1, #0x7c0
  200d78:	91284000 	add	x0, x0, #0xa10
  200d7c:	52803722 	mov	w2, #0x1b9                 	// #441
  200d80:	94000a20 	bl	203600 <_assert_fail>
  200d84:	17fffeb9 	b	200868 <init+0x58>
    assert(regs->QueueNumMax >= TX_COUNT);
  200d88:	f0000003 	adrp	x3, 203000 <_vsnprintf+0x9f0>
  200d8c:	911a2063 	add	x3, x3, #0x688
  200d90:	528033e2 	mov	w2, #0x19f                 	// #415
  200d94:	9100a063 	add	x3, x3, #0x28
  200d98:	f0000001 	adrp	x1, 203000 <_vsnprintf+0x9f0>
  200d9c:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  200da0:	911f0021 	add	x1, x1, #0x7c0
  200da4:	9131a000 	add	x0, x0, #0xc68
  200da8:	94000a16 	bl	203600 <_assert_fail>
    regs->QueueDescLow = (hw_ring_buffer_paddr + tx_desc_off) & 0xFFFFFFFF;
  200dac:	f9407661 	ldr	x1, [x19, #232]
    regs->QueueSel = VIRTIO_NET_TX_QUEUE;
  200db0:	f9403660 	ldr	x0, [x19, #104]
    regs->QueueDescLow = (hw_ring_buffer_paddr + tx_desc_off) & 0xFFFFFFFF;
  200db4:	2a0103e2 	mov	w2, w1
  200db8:	17ffffa4 	b	200c48 <init+0x438>
    assert(regs->QueueNumMax >= RX_COUNT);
  200dbc:	f0000003 	adrp	x3, 203000 <_vsnprintf+0x9f0>
  200dc0:	911a2063 	add	x3, x3, #0x688
  200dc4:	9100a063 	add	x3, x3, #0x28
  200dc8:	f0000001 	adrp	x1, 203000 <_vsnprintf+0x9f0>
  200dcc:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  200dd0:	911f0021 	add	x1, x1, #0x7c0
  200dd4:	91312000 	add	x0, x0, #0xc48
  200dd8:	52803262 	mov	w2, #0x193                 	// #403
  200ddc:	94000a09 	bl	203600 <_assert_fail>
    regs->QueueSel = VIRTIO_NET_RX_QUEUE;
  200de0:	f9403660 	ldr	x0, [x19, #104]
  200de4:	17ffff80 	b	200be4 <init+0x3d4>
    assert((uintptr_t)tx_virtq.used % 4 == 0);
  200de8:	f0000003 	adrp	x3, 203000 <_vsnprintf+0x9f0>
  200dec:	911a2063 	add	x3, x3, #0x688
  200df0:	9100a063 	add	x3, x3, #0x28
  200df4:	f0000001 	adrp	x1, 203000 <_vsnprintf+0x9f0>
  200df8:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  200dfc:	911f0021 	add	x1, x1, #0x7c0
  200e00:	91308000 	add	x0, x0, #0xc20
  200e04:	52803062 	mov	w2, #0x183                 	// #387
  200e08:	940009fe 	bl	203600 <_assert_fail>
  200e0c:	17ffff66 	b	200ba4 <init+0x394>
    assert((uintptr_t)tx_virtq.desc % 16 == 0);
  200e10:	f0000017 	adrp	x23, 203000 <_vsnprintf+0x9f0>
  200e14:	911a22f7 	add	x23, x23, #0x688
  200e18:	9100a2f7 	add	x23, x23, #0x28
  200e1c:	f0000018 	adrp	x24, 203000 <_vsnprintf+0x9f0>
  200e20:	911f0318 	add	x24, x24, #0x7c0
  200e24:	aa1703e3 	mov	x3, x23
  200e28:	aa1803e1 	mov	x1, x24
  200e2c:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  200e30:	52803022 	mov	w2, #0x181                 	// #385
  200e34:	912f4000 	add	x0, x0, #0xbd0
  200e38:	940009f2 	bl	203600 <_assert_fail>
    assert((uintptr_t)tx_virtq.avail % 2 == 0);
  200e3c:	f9404260 	ldr	x0, [x19, #128]
  200e40:	3607eac0 	tbz	w0, #0, 200b98 <init+0x388>
  200e44:	aa1703e3 	mov	x3, x23
  200e48:	aa1803e1 	mov	x1, x24
  200e4c:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  200e50:	52803042 	mov	w2, #0x182                 	// #386
  200e54:	912fe000 	add	x0, x0, #0xbf8
  200e58:	940009ea 	bl	203600 <_assert_fail>
  200e5c:	17ffff4f 	b	200b98 <init+0x388>
    assert((uintptr_t)rx_virtq.used % 4 == 0);
  200e60:	f0000003 	adrp	x3, 203000 <_vsnprintf+0x9f0>
  200e64:	911a2063 	add	x3, x3, #0x688
  200e68:	9100a063 	add	x3, x3, #0x28
  200e6c:	f0000001 	adrp	x1, 203000 <_vsnprintf+0x9f0>
  200e70:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  200e74:	911f0021 	add	x1, x1, #0x7c0
  200e78:	912ea000 	add	x0, x0, #0xba8
  200e7c:	52802f42 	mov	w2, #0x17a                 	// #378
  200e80:	940009e0 	bl	203600 <_assert_fail>
  200e84:	17ffff37 	b	200b60 <init+0x350>
    assert((uintptr_t)rx_virtq.desc % 16 == 0);
  200e88:	f0000016 	adrp	x22, 203000 <_vsnprintf+0x9f0>
  200e8c:	911a22d6 	add	x22, x22, #0x688
  200e90:	9100a2d6 	add	x22, x22, #0x28
  200e94:	f0000017 	adrp	x23, 203000 <_vsnprintf+0x9f0>
  200e98:	911f02f7 	add	x23, x23, #0x7c0
  200e9c:	aa1603e3 	mov	x3, x22
  200ea0:	aa1703e1 	mov	x1, x23
  200ea4:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  200ea8:	52802f02 	mov	w2, #0x178                 	// #376
  200eac:	912d6000 	add	x0, x0, #0xb58
  200eb0:	940009d4 	bl	203600 <_assert_fail>
    assert((uintptr_t)rx_virtq.avail % 2 == 0);
  200eb4:	f9400a60 	ldr	x0, [x19, #16]
  200eb8:	3607e4e0 	tbz	w0, #0, 200b54 <init+0x344>
  200ebc:	aa1603e3 	mov	x3, x22
  200ec0:	aa1703e1 	mov	x1, x23
  200ec4:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  200ec8:	52802f22 	mov	w2, #0x179                 	// #377
  200ecc:	912e0000 	add	x0, x0, #0xb80
  200ed0:	940009cc 	bl	203600 <_assert_fail>
  200ed4:	17ffff20 	b	200b54 <init+0x344>
        LOG_DRIVER_ERR("device status features is not OK!\n");
  200ed8:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  200edc:	912ac000 	add	x0, x0, #0xab0
  200ee0:	9400090c 	bl	203310 <sddf_printf_>
  200ee4:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  200ee8:	912cc000 	add	x0, x0, #0xb30
  200eec:	94000909 	bl	203310 <sddf_printf_>
        return;
  200ef0:	17ffff7c 	b	200ce0 <init+0x4d0>
  200ef4:	d503201f 	nop
  200ef8:	d503201f 	nop
  200efc:	d503201f 	nop

0000000000200f00 <notified>:

void notified(microkit_channel ch)
{
  200f00:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  200f04:	910003fd 	mov	x29, sp
    if (ch == device_resources.irqs[0].id) {
  200f08:	90000021 	adrp	x1, 204000 <__sel4_ipc_buffer>
  200f0c:	39584021 	ldrb	w1, [x1, #1552]
{
  200f10:	a90153f3 	stp	x19, x20, [sp, #16]
  200f14:	2a0003f4 	mov	w20, w0
    if (ch == device_resources.irqs[0].id) {
  200f18:	6b00003f 	cmp	w1, w0
  200f1c:	540002a0 	b.eq	200f70 <notified+0x70>  // b.none
        handle_irq();
        microkit_deferred_irq_ack(ch);
    } else if (ch == config.virt_rx.id) {
  200f20:	90000020 	adrp	x0, 204000 <__sel4_ipc_buffer>
  200f24:	91194000 	add	x0, x0, #0x650
  200f28:	3940a801 	ldrb	w1, [x0, #42]
  200f2c:	6b14003f 	cmp	w1, w20
  200f30:	54001960 	b.eq	20125c <notified+0x35c>  // b.none
        rx_provide();
    } else if (ch == config.virt_tx.id) {
  200f34:	39414800 	ldrb	w0, [x0, #82]
  200f38:	6b14001f 	cmp	w0, w20
  200f3c:	54000140 	b.eq	200f64 <notified+0x64>  // b.none
        tx_provide();
    } else {
        LOG_DRIVER_ERR("received notification on unexpected channel %u\n", ch);
  200f40:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  200f44:	912ac000 	add	x0, x0, #0xab0
  200f48:	940008f2 	bl	203310 <sddf_printf_>
  200f4c:	2a1403e1 	mov	w1, w20
  200f50:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  200f54:	91364000 	add	x0, x0, #0xd90
    }
}
  200f58:	a94153f3 	ldp	x19, x20, [sp, #16]
  200f5c:	a8c87bfd 	ldp	x29, x30, [sp], #128
        LOG_DRIVER_ERR("received notification on unexpected channel %u\n", ch);
  200f60:	140008ec 	b	203310 <sddf_printf_>
}
  200f64:	a94153f3 	ldp	x19, x20, [sp, #16]
  200f68:	a8c87bfd 	ldp	x29, x30, [sp], #128
        tx_provide();
  200f6c:	17fffcf9 	b	200350 <tx_provide>
    uint32_t irq_status = regs->InterruptStatus;
  200f70:	90000033 	adrp	x19, 204000 <__sel4_ipc_buffer>
  200f74:	911ac273 	add	x19, x19, #0x6b0
  200f78:	a90363f7 	stp	x23, x24, [sp, #48]
  200f7c:	f9403660 	ldr	x0, [x19, #104]
  200f80:	b9406017 	ldr	w23, [x0, #96]
    if (irq_status & VIRTIO_MMIO_IRQ_VQUEUE) {
  200f84:	37000317 	tbnz	w23, #0, 200fe4 <notified+0xe4>
    if (irq_status & VIRTIO_MMIO_IRQ_CONFIG) {
  200f88:	370801f7 	tbnz	w23, #1, 200fc4 <notified+0xc4>

static inline void microkit_deferred_irq_ack(microkit_channel ch)
{
    microkit_have_signal = seL4_True;
    microkit_signal_msg = seL4_MessageInfo_new(IRQAckIRQ, 0, 0, 0);
    microkit_signal_cap = (BASE_IRQ_CAP + ch);
  200f8c:	b0000023 	adrp	x3, 205000 <tx_descriptors+0x60>
    microkit_have_signal = seL4_True;
  200f90:	b0000021 	adrp	x1, 205000 <tx_descriptors+0x60>
    microkit_signal_msg = seL4_MessageInfo_new(IRQAckIRQ, 0, 0, 0);
  200f94:	b0000020 	adrp	x0, 205000 <tx_descriptors+0x60>
    microkit_signal_cap = (BASE_IRQ_CAP + ch);
  200f98:	11022a94 	add	w20, w20, #0x8a
    microkit_have_signal = seL4_True;
  200f9c:	52800022 	mov	w2, #0x1                   	// #1
    microkit_signal_cap = (BASE_IRQ_CAP + ch);
  200fa0:	f9041074 	str	x20, [x3, #2080]
    microkit_have_signal = seL4_True;
  200fa4:	39204422 	strb	w2, [x1, #2065]
    microkit_signal_msg = seL4_MessageInfo_new(IRQAckIRQ, 0, 0, 0);
  200fa8:	d2940001 	mov	x1, #0xa000                	// #40960
  200fac:	f2a00021 	movk	x1, #0x1, lsl #16
  200fb0:	f9040c01 	str	x1, [x0, #2072]
}
  200fb4:	a94153f3 	ldp	x19, x20, [sp, #16]
  200fb8:	a94363f7 	ldp	x23, x24, [sp, #48]
  200fbc:	a8c87bfd 	ldp	x29, x30, [sp], #128
  200fc0:	d65f03c0 	ret
        LOG_DRIVER_ERR("ETH|ERROR: unexpected change in configuration %u\n", irq_status);
  200fc4:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  200fc8:	912ac000 	add	x0, x0, #0xab0
  200fcc:	940008d1 	bl	203310 <sddf_printf_>
  200fd0:	2a1703e1 	mov	w1, w23
  200fd4:	f0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  200fd8:	91356000 	add	x0, x0, #0xd58
  200fdc:	940008cd 	bl	203310 <sddf_printf_>
  200fe0:	17ffffeb 	b	200f8c <notified+0x8c>
    uint16_t curr_idx = rx_virtq.used->idx;
  200fe4:	f9400e63 	ldr	x3, [x19, #24]
    uint16_t i = rx_last_seen_used;
  200fe8:	b0000038 	adrp	x24, 205000 <tx_descriptors+0x60>
  200fec:	911ec300 	add	x0, x24, #0x7b0
  200ff0:	f9003be0 	str	x0, [sp, #112]
  200ff4:	a9025bf5 	stp	x21, x22, [sp, #32]
  200ff8:	785f8000 	ldurh	w0, [x0, #-8]
  200ffc:	a9046bf9 	stp	x25, x26, [sp, #64]
    uint16_t curr_idx = rx_virtq.used->idx;
  201000:	79400479 	ldrh	w25, [x3, #2]
  201004:	a90573fb 	stp	x27, x28, [sp, #80]
    uint16_t i = rx_last_seen_used;
  201008:	2a0003fc 	mov	w28, w0
    while (i != curr_idx) {
  20100c:	6b19001f 	cmp	w0, w25
    uint16_t i = rx_last_seen_used;
  201010:	b9007fe0 	str	w0, [sp, #124]
    while (i != curr_idx) {
  201014:	540013c0 	b.eq	20128c <notified+0x38c>  // b.none
        assert(rx_virtq.desc[hdr_used.id].flags & VIRTQ_DESC_F_NEXT);
  201018:	d0000015 	adrp	x21, 203000 <_vsnprintf+0x9f0>
  20101c:	911a22b5 	add	x21, x21, #0x688
  201020:	d0000016 	adrp	x22, 203000 <_vsnprintf+0x9f0>
  201024:	911f02d6 	add	x22, x22, #0x7c0
  201028:	9100e2b5 	add	x21, x21, #0x38
  20102c:	1400001f 	b	2010a8 <notified+0x1a8>
        ia->tail = id - ia->offset;
  201030:	29011826 	stp	w6, w6, [x1, #8]
    ia->num_free++;
  201034:	11000463 	add	w3, w3, #0x1
  201038:	b9005263 	str	w3, [x19, #80]
        err = ialloc_free(&rx_ialloc_desc, rx_virtq.desc[hdr_used.id].next);
  20103c:	f9400661 	ldr	x1, [x19, #8]
  201040:	8b180021 	add	x1, x1, x24
  201044:	79401c21 	ldrh	w1, [x1, #14]
    if (id >= ia->size + ia->offset || id < ia->offset || !ialloc_in_use(ia, id)) {
  201048:	6b02003f 	cmp	w1, w2
  20104c:	7a402022 	ccmp	w1, w0, #0x2, cs	// cs = hs, nlast
  201050:	54000be2 	b.cs	2011cc <notified+0x2cc>  // b.hs, b.nlast
    return ia->idxlist[id - ia->offset] == -1;
  201054:	f9402264 	ldr	x4, [x19, #64]
  201058:	4b020020 	sub	w0, w1, w2
  20105c:	91010263 	add	x3, x19, #0x40
  201060:	4b020022 	sub	w2, w1, w2
    if (id >= ia->size + ia->offset || id < ia->offset || !ialloc_in_use(ia, id)) {
  201064:	b8607880 	ldr	w0, [x4, x0, lsl #2]
  201068:	3100041f 	cmn	w0, #0x1
  20106c:	54000b01 	b.ne	2011cc <notified+0x2cc>  // b.any
    return ia->num_free == 0;
  201070:	b9401060 	ldr	w0, [x3, #16]
    if (ialloc_full(ia)) {
  201074:	350008e0 	cbnz	w0, 201190 <notified+0x290>
        ia->tail = id - ia->offset;
  201078:	29010862 	stp	w2, w2, [x3, #8]
    ia->num_free++;
  20107c:	11000400 	add	w0, w0, #0x1
  201080:	b9005260 	str	w0, [x19, #80]
        rx_last_desc_idx -= 2;
  201084:	b9402260 	ldr	w0, [x19, #32]
  201088:	51000800 	sub	w0, w0, #0x2
  20108c:	b9002260 	str	w0, [x19, #32]
        assert(rx_last_desc_idx >= 0);
  201090:	37f80b20 	tbnz	w0, #31, 2011f4 <notified+0x2f4>
        i++;
  201094:	11000780 	add	w0, w28, #0x1
  201098:	12003c1c 	and	w28, w0, #0xffff
    while (i != curr_idx) {
  20109c:	6b20233f 	cmp	w25, w0, uxth
  2010a0:	54000e40 	b.eq	201268 <notified+0x368>  // b.none
        struct virtq_used_elem hdr_used = rx_virtq.used->ring[i % rx_virtq.num];
  2010a4:	f9400e63 	ldr	x3, [x19, #24]
  2010a8:	b9400261 	ldr	w1, [x19]
        assert(rx_virtq.desc[hdr_used.id].flags & VIRTQ_DESC_F_NEXT);
  2010ac:	f9400662 	ldr	x2, [x19, #8]
        struct virtq_used_elem hdr_used = rx_virtq.used->ring[i % rx_virtq.num];
  2010b0:	1ac10b80 	udiv	w0, w28, w1
  2010b4:	1b01f000 	msub	w0, w0, w1, w28
  2010b8:	8b000c60 	add	x0, x3, x0, lsl #3
  2010bc:	b940041b 	ldr	w27, [x0, #4]
        assert(rx_virtq.desc[hdr_used.id].flags & VIRTQ_DESC_F_NEXT);
  2010c0:	d37c7f78 	ubfiz	x24, x27, #4, #32
  2010c4:	8b180040 	add	x0, x2, x24
  2010c8:	79401803 	ldrh	w3, [x0, #12]
  2010cc:	36000b43 	tbz	w3, #0, 201234 <notified+0x334>
        struct virtq_desc pkt = rx_virtq.desc[rx_virtq.desc[hdr_used.id].next % rx_virtq.num];
  2010d0:	79401c03 	ldrh	w3, [x0, #14]
  2010d4:	1ac10860 	udiv	w0, w3, w1
  2010d8:	1b018c00 	msub	w0, w0, w1, w3
  2010dc:	d37cec00 	lsl	x0, x0, #4
  2010e0:	8b000041 	add	x1, x2, x0
  2010e4:	f860685a 	ldr	x26, [x2, x0]
        assert(!(pkt.flags & VIRTQ_DESC_F_NEXT));
  2010e8:	79401820 	ldrh	w0, [x1, #12]
        struct virtq_desc pkt = rx_virtq.desc[rx_virtq.desc[hdr_used.id].next % rx_virtq.num];
  2010ec:	b9400825 	ldr	w5, [x1, #8]
        assert(!(pkt.flags & VIRTQ_DESC_F_NEXT));
  2010f0:	37000900 	tbnz	w0, #0, 201210 <notified+0x310>
    return queue->active->tail - queue->active->head == queue->capacity;
  2010f4:	f9401a61 	ldr	x1, [x19, #48]
        net_buff_desc_t buffer = { addr, len };
  2010f8:	12003ca5 	and	w5, w5, #0xffff
  2010fc:	b9403a63 	ldr	w3, [x19, #56]
  201100:	79400022 	ldrh	w2, [x1]
  201104:	79400420 	ldrh	w0, [x1, #2]
  201108:	4b000040 	sub	w0, w2, w0
    if (net_queue_full_active(queue)) {
  20110c:	6b03001f 	cmp	w0, w3
  201110:	540025c0 	b.eq	2015c8 <notified+0x6c8>  // b.none
    queue->active->buffers[queue->active->tail % queue->capacity] = buffer;
  201114:	1ac30840 	udiv	w0, w2, w3
  201118:	d2800108 	mov	x8, #0x8                   	// #8
    queue->active->tail++;
  20111c:	11000447 	add	w7, w2, #0x1
    queue->active->buffers[queue->active->tail % queue->capacity] = buffer;
  201120:	1b038800 	msub	w0, w0, w3, w2
  201124:	8b205100 	add	x0, x8, w0, uxtw #4
  201128:	8b000022 	add	x2, x1, x0
  20112c:	f820683a 	str	x26, [x1, x0]
  201130:	79001045 	strh	w5, [x2, #8]
    queue->active->tail++;
  201134:	79000027 	strh	w7, [x1]
    if (id >= ia->size + ia->offset || id < ia->offset || !ialloc_in_use(ia, id)) {
  201138:	91010261 	add	x1, x19, #0x40
  20113c:	29428022 	ldp	w2, w0, [x1, #20]
  201140:	0b000040 	add	w0, w2, w0
  201144:	6b00037f 	cmp	w27, w0
  201148:	7a423360 	ccmp	w27, w2, #0x0, cc	// cc = lo, ul, last
  20114c:	540002e3 	b.cc	2011a8 <notified+0x2a8>  // b.lo, b.ul, b.last
    return ia->idxlist[id - ia->offset] == -1;
  201150:	f9402265 	ldr	x5, [x19, #64]
  201154:	4b020363 	sub	w3, w27, w2
  201158:	4b020366 	sub	w6, w27, w2
    if (id >= ia->size + ia->offset || id < ia->offset || !ialloc_in_use(ia, id)) {
  20115c:	b86378a3 	ldr	w3, [x5, x3, lsl #2]
  201160:	3100047f 	cmn	w3, #0x1
  201164:	54000221 	b.ne	2011a8 <notified+0x2a8>  // b.any
    return ia->num_free == 0;
  201168:	b9401023 	ldr	w3, [x1, #16]
    if (ialloc_full(ia)) {
  20116c:	34fff623 	cbz	w3, 201030 <notified+0x130>
        ia->idxlist[ia->tail] = id - ia->offset;
  201170:	b9400c20 	ldr	w0, [x1, #12]
  201174:	b82078a6 	str	w6, [x5, x0, lsl #2]
        ia->tail = id - ia->offset;
  201178:	29420823 	ldp	w3, w2, [x1, #16]
    if (id >= ia->size + ia->offset || id < ia->offset || !ialloc_in_use(ia, id)) {
  20117c:	b9401820 	ldr	w0, [x1, #24]
        ia->tail = id - ia->offset;
  201180:	4b02037b 	sub	w27, w27, w2
  201184:	b9000c3b 	str	w27, [x1, #12]
    if (id >= ia->size + ia->offset || id < ia->offset || !ialloc_in_use(ia, id)) {
  201188:	0b000040 	add	w0, w2, w0
  20118c:	17ffffaa 	b	201034 <notified+0x134>
        ia->idxlist[ia->tail] = id - ia->offset;
  201190:	b9400c60 	ldr	w0, [x3, #12]
  201194:	b8207882 	str	w2, [x4, x0, lsl #2]
        ia->tail = id - ia->offset;
  201198:	29420860 	ldp	w0, w2, [x3, #16]
  20119c:	4b020021 	sub	w1, w1, w2
  2011a0:	b9000c61 	str	w1, [x3, #12]
  2011a4:	17ffffb6 	b	20107c <notified+0x17c>
        assert(!err);
  2011a8:	52801562 	mov	w2, #0xab                  	// #171
  2011ac:	aa1503e3 	mov	x3, x21
  2011b0:	aa1603e1 	mov	x1, x22
  2011b4:	d0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  2011b8:	9133a000 	add	x0, x0, #0xce8
  2011bc:	94000911 	bl	203600 <_assert_fail>
    if (id >= ia->size + ia->offset || id < ia->offset || !ialloc_in_use(ia, id)) {
  2011c0:	294a8262 	ldp	w2, w0, [x19, #84]
  2011c4:	0b000040 	add	w0, w2, w0
  2011c8:	17ffff9d 	b	20103c <notified+0x13c>
        assert(!err);
  2011cc:	aa1503e3 	mov	x3, x21
  2011d0:	aa1603e1 	mov	x1, x22
  2011d4:	d0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  2011d8:	528015a2 	mov	w2, #0xad                  	// #173
  2011dc:	9133a000 	add	x0, x0, #0xce8
  2011e0:	94000908 	bl	203600 <_assert_fail>
        rx_last_desc_idx -= 2;
  2011e4:	b9402260 	ldr	w0, [x19, #32]
  2011e8:	51000800 	sub	w0, w0, #0x2
  2011ec:	b9002260 	str	w0, [x19, #32]
        assert(rx_last_desc_idx >= 0);
  2011f0:	36fff520 	tbz	w0, #31, 201094 <notified+0x194>
  2011f4:	aa1503e3 	mov	x3, x21
  2011f8:	aa1603e1 	mov	x1, x22
  2011fc:	d0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  201200:	52801602 	mov	w2, #0xb0                  	// #176
  201204:	9133c000 	add	x0, x0, #0xcf0
  201208:	940008fe 	bl	203600 <_assert_fail>
  20120c:	17ffffa2 	b	201094 <notified+0x194>
        assert(!(pkt.flags & VIRTQ_DESC_F_NEXT));
  201210:	aa1503e3 	mov	x3, x21
  201214:	aa1603e1 	mov	x1, x22
  201218:	d0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  20121c:	52801482 	mov	w2, #0xa4                  	// #164
  201220:	91330000 	add	x0, x0, #0xcc0
  201224:	b9006be5 	str	w5, [sp, #104]
  201228:	940008f6 	bl	203600 <_assert_fail>
  20122c:	b9406be5 	ldr	w5, [sp, #104]
  201230:	17ffffb1 	b	2010f4 <notified+0x1f4>
        assert(rx_virtq.desc[hdr_used.id].flags & VIRTQ_DESC_F_NEXT);
  201234:	aa1603e1 	mov	x1, x22
  201238:	528013e2 	mov	w2, #0x9f                  	// #159
  20123c:	aa1503e3 	mov	x3, x21
  201240:	d0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  201244:	91322000 	add	x0, x0, #0xc88
  201248:	940008ee 	bl	203600 <_assert_fail>
        struct virtq_desc pkt = rx_virtq.desc[rx_virtq.desc[hdr_used.id].next % rx_virtq.num];
  20124c:	f9400662 	ldr	x2, [x19, #8]
  201250:	b9400261 	ldr	w1, [x19]
  201254:	8b180040 	add	x0, x2, x24
  201258:	17ffff9e 	b	2010d0 <notified+0x1d0>
}
  20125c:	a94153f3 	ldp	x19, x20, [sp, #16]
  201260:	a8c87bfd 	ldp	x29, x30, [sp], #128
        rx_provide();
  201264:	17fffb6b 	b	200010 <rx_provide>
 *
 * @param queue queue handle of the active queue to check.
 */
static inline bool net_require_signal_active(net_queue_handle_t *queue)
{
    return !queue->active->consumer_signalled;
  201268:	f9401a60 	ldr	x0, [x19, #48]
    rx_last_seen_used += packets_transferred;
  20126c:	f9403be3 	ldr	x3, [sp, #112]
  201270:	b9407fe1 	ldr	w1, [sp, #124]
  201274:	785f8062 	ldurh	w2, [x3, #-8]
  201278:	4b010339 	sub	w25, w25, w1
    if (packets_transferred > 0 && net_require_signal_active(&rx_queue)) {
  20127c:	b9400401 	ldr	w1, [x0, #4]
    rx_last_seen_used += packets_transferred;
  201280:	0b020339 	add	w25, w25, w2
  201284:	781f8079 	sturh	w25, [x3, #-8]
    if (packets_transferred > 0 && net_require_signal_active(&rx_queue)) {
  201288:	340017a1 	cbz	w1, 20157c <notified+0x67c>
    uint16_t i = tx_last_seen_used;
  20128c:	f9403be1 	ldr	x1, [sp, #112]
    uint16_t enqueued = 0;
  201290:	52800015 	mov	w21, #0x0                   	// #0
    uint16_t curr_idx = tx_virtq.used->idx;
  201294:	f9404660 	ldr	x0, [x19, #136]
    uint16_t i = tx_last_seen_used;
  201298:	785fa03c 	ldurh	w28, [x1, #-6]
    uint16_t curr_idx = tx_virtq.used->idx;
  20129c:	7940041a 	ldrh	w26, [x0, #2]
    while (i != curr_idx && !net_queue_full_free(&tx_queue)) {
  2012a0:	6b1a039f 	cmp	w28, w26
  2012a4:	54001420 	b.eq	201528 <notified+0x628>  // b.none
        assert(tx_virtq.desc[hdr_used.id].flags & VIRTQ_DESC_F_NEXT);
  2012a8:	d0000016 	adrp	x22, 203000 <_vsnprintf+0x9f0>
  2012ac:	911a22d6 	add	x22, x22, #0x688
  2012b0:	d0000019 	adrp	x25, 203000 <_vsnprintf+0x9f0>
  2012b4:	911f0339 	add	x25, x25, #0x7c0
  2012b8:	910122d6 	add	x22, x22, #0x48
  2012bc:	14000020 	b	20133c <notified+0x43c>
        ia->tail = id - ia->offset;
  2012c0:	29011826 	stp	w6, w6, [x1, #8]
    ia->num_free++;
  2012c4:	11000463 	add	w3, w3, #0x1
  2012c8:	b900c263 	str	w3, [x19, #192]
        err = ialloc_free(&tx_ialloc_desc, tx_virtq.desc[hdr_used.id].next);
  2012cc:	f9403e61 	ldr	x1, [x19, #120]
  2012d0:	8b180021 	add	x1, x1, x24
  2012d4:	79401c21 	ldrh	w1, [x1, #14]
    if (id >= ia->size + ia->offset || id < ia->offset || !ialloc_in_use(ia, id)) {
  2012d8:	6b02003f 	cmp	w1, w2
  2012dc:	7a402022 	ccmp	w1, w0, #0x2, cs	// cs = hs, nlast
  2012e0:	54000ce2 	b.cs	20147c <notified+0x57c>  // b.hs, b.nlast
    return ia->idxlist[id - ia->offset] == -1;
  2012e4:	f9405a64 	ldr	x4, [x19, #176]
  2012e8:	4b020020 	sub	w0, w1, w2
  2012ec:	9102c263 	add	x3, x19, #0xb0
  2012f0:	4b020022 	sub	w2, w1, w2
    if (id >= ia->size + ia->offset || id < ia->offset || !ialloc_in_use(ia, id)) {
  2012f4:	b8607880 	ldr	w0, [x4, x0, lsl #2]
  2012f8:	3100041f 	cmn	w0, #0x1
  2012fc:	54000c01 	b.ne	20147c <notified+0x57c>  // b.any
    return ia->num_free == 0;
  201300:	b9401060 	ldr	w0, [x3, #16]
    if (ialloc_full(ia)) {
  201304:	350009e0 	cbnz	w0, 201440 <notified+0x540>
        ia->tail = id - ia->offset;
  201308:	29010862 	stp	w2, w2, [x3, #8]
    ia->num_free++;
  20130c:	11000400 	add	w0, w0, #0x1
  201310:	b900c260 	str	w0, [x19, #192]
        tx_last_desc_idx -= 2;
  201314:	b9409260 	ldr	w0, [x19, #144]
  201318:	51000800 	sub	w0, w0, #0x2
  20131c:	b9009260 	str	w0, [x19, #144]
        assert(tx_last_desc_idx >= 0);
  201320:	37f80c20 	tbnz	w0, #31, 2014a4 <notified+0x5a4>
        i++;
  201324:	11000780 	add	w0, w28, #0x1
        enqueued++;
  201328:	110006b5 	add	w21, w21, #0x1
        i++;
  20132c:	12003c1c 	and	w28, w0, #0xffff
        enqueued++;
  201330:	12003eb5 	and	w21, w21, #0xffff
    while (i != curr_idx && !net_queue_full_free(&tx_queue)) {
  201334:	6b20235f 	cmp	w26, w0, uxth
  201338:	54000ee0 	b.eq	201514 <notified+0x614>  // b.none
    return queue->free->tail - queue->free->head == queue->capacity;
  20133c:	f9404e61 	ldr	x1, [x19, #152]
  201340:	b940aa62 	ldr	w2, [x19, #168]
  201344:	79400020 	ldrh	w0, [x1]
  201348:	79400421 	ldrh	w1, [x1, #2]
  20134c:	4b010000 	sub	w0, w0, w1
  201350:	6b02001f 	cmp	w0, w2
  201354:	54000e00 	b.eq	201514 <notified+0x614>  // b.none
        struct virtq_used_elem hdr_used = tx_virtq.used->ring[i % tx_virtq.num];
  201358:	b9407261 	ldr	w1, [x19, #112]
  20135c:	9101c265 	add	x5, x19, #0x70
  201360:	f9404663 	ldr	x3, [x19, #136]
        assert(tx_virtq.desc[hdr_used.id].flags & VIRTQ_DESC_F_NEXT);
  201364:	f9403e62 	ldr	x2, [x19, #120]
        struct virtq_used_elem hdr_used = tx_virtq.used->ring[i % tx_virtq.num];
  201368:	1ac10b80 	udiv	w0, w28, w1
  20136c:	1b01f000 	msub	w0, w0, w1, w28
  201370:	8b000c60 	add	x0, x3, x0, lsl #3
  201374:	b940041b 	ldr	w27, [x0, #4]
        assert(tx_virtq.desc[hdr_used.id].flags & VIRTQ_DESC_F_NEXT);
  201378:	d37c7f78 	ubfiz	x24, x27, #4, #32
  20137c:	8b180040 	add	x0, x2, x24
  201380:	79401803 	ldrh	w3, [x0, #12]
  201384:	36000b03 	tbz	w3, #0, 2014e4 <notified+0x5e4>
        struct virtq_desc pkt = tx_virtq.desc[tx_virtq.desc[hdr_used.id].next % tx_virtq.num];
  201388:	79401c03 	ldrh	w3, [x0, #14]
  20138c:	1ac10860 	udiv	w0, w3, w1
  201390:	1b018c00 	msub	w0, w0, w1, w3
  201394:	d37cec00 	lsl	x0, x0, #4
  201398:	8b000041 	add	x1, x2, x0
  20139c:	f8606845 	ldr	x5, [x2, x0]
        assert(!(pkt.flags & VIRTQ_DESC_F_NEXT));
  2013a0:	79401820 	ldrh	w0, [x1, #12]
  2013a4:	370008e0 	tbnz	w0, #0, 2014c0 <notified+0x5c0>
  2013a8:	f9404e61 	ldr	x1, [x19, #152]
  2013ac:	b940aa63 	ldr	w3, [x19, #168]
  2013b0:	79400022 	ldrh	w2, [x1]
  2013b4:	79400420 	ldrh	w0, [x1, #2]
  2013b8:	4b000040 	sub	w0, w2, w0
    if (net_queue_full_free(queue)) {
  2013bc:	6b03001f 	cmp	w0, w3
  2013c0:	54000f00 	b.eq	2015a0 <notified+0x6a0>  // b.none
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  2013c4:	1ac30840 	udiv	w0, w2, w3
  2013c8:	d2800107 	mov	x7, #0x8                   	// #8
    queue->free->tail++;
  2013cc:	11000446 	add	w6, w2, #0x1
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  2013d0:	1b038800 	msub	w0, w0, w3, w2
  2013d4:	8b2050e0 	add	x0, x7, w0, uxtw #4
  2013d8:	8b000022 	add	x2, x1, x0
  2013dc:	f8206825 	str	x5, [x1, x0]
  2013e0:	7900105f 	strh	wzr, [x2, #8]
    queue->free->tail++;
  2013e4:	79000026 	strh	w6, [x1]
    if (id >= ia->size + ia->offset || id < ia->offset || !ialloc_in_use(ia, id)) {
  2013e8:	9102c261 	add	x1, x19, #0xb0
  2013ec:	29428022 	ldp	w2, w0, [x1, #20]
  2013f0:	0b000040 	add	w0, w2, w0
  2013f4:	6b00037f 	cmp	w27, w0
  2013f8:	7a423360 	ccmp	w27, w2, #0x0, cc	// cc = lo, ul, last
  2013fc:	540002e3 	b.cc	201458 <notified+0x558>  // b.lo, b.ul, b.last
    return ia->idxlist[id - ia->offset] == -1;
  201400:	f9405a65 	ldr	x5, [x19, #176]
  201404:	4b020363 	sub	w3, w27, w2
  201408:	4b020366 	sub	w6, w27, w2
    if (id >= ia->size + ia->offset || id < ia->offset || !ialloc_in_use(ia, id)) {
  20140c:	b86378a3 	ldr	w3, [x5, x3, lsl #2]
  201410:	3100047f 	cmn	w3, #0x1
  201414:	54000221 	b.ne	201458 <notified+0x558>  // b.any
    return ia->num_free == 0;
  201418:	b9401023 	ldr	w3, [x1, #16]
    if (ialloc_full(ia)) {
  20141c:	34fff523 	cbz	w3, 2012c0 <notified+0x3c0>
        ia->idxlist[ia->tail] = id - ia->offset;
  201420:	b9400c20 	ldr	w0, [x1, #12]
  201424:	b82078a6 	str	w6, [x5, x0, lsl #2]
        ia->tail = id - ia->offset;
  201428:	29420823 	ldp	w3, w2, [x1, #16]
    if (id >= ia->size + ia->offset || id < ia->offset || !ialloc_in_use(ia, id)) {
  20142c:	b9401820 	ldr	w0, [x1, #24]
        ia->tail = id - ia->offset;
  201430:	4b02037b 	sub	w27, w27, w2
  201434:	b9000c3b 	str	w27, [x1, #12]
    if (id >= ia->size + ia->offset || id < ia->offset || !ialloc_in_use(ia, id)) {
  201438:	0b000040 	add	w0, w2, w0
  20143c:	17ffffa2 	b	2012c4 <notified+0x3c4>
        ia->idxlist[ia->tail] = id - ia->offset;
  201440:	b9400c60 	ldr	w0, [x3, #12]
  201444:	b8207882 	str	w2, [x4, x0, lsl #2]
        ia->tail = id - ia->offset;
  201448:	29420860 	ldp	w0, w2, [x3, #16]
  20144c:	4b020021 	sub	w1, w1, w2
  201450:	b9000c61 	str	w1, [x3, #12]
  201454:	17ffffae 	b	20130c <notified+0x40c>
        assert(!err);
  201458:	528021e2 	mov	w2, #0x10f                 	// #271
  20145c:	aa1603e3 	mov	x3, x22
  201460:	aa1903e1 	mov	x1, x25
  201464:	d0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  201468:	9133a000 	add	x0, x0, #0xce8
  20146c:	94000865 	bl	203600 <_assert_fail>
    if (id >= ia->size + ia->offset || id < ia->offset || !ialloc_in_use(ia, id)) {
  201470:	29588262 	ldp	w2, w0, [x19, #196]
  201474:	0b000040 	add	w0, w2, w0
  201478:	17ffff95 	b	2012cc <notified+0x3cc>
        assert(!err);
  20147c:	aa1603e3 	mov	x3, x22
  201480:	aa1903e1 	mov	x1, x25
  201484:	d0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  201488:	52802222 	mov	w2, #0x111                 	// #273
  20148c:	9133a000 	add	x0, x0, #0xce8
  201490:	9400085c 	bl	203600 <_assert_fail>
        tx_last_desc_idx -= 2;
  201494:	b9409260 	ldr	w0, [x19, #144]
  201498:	51000800 	sub	w0, w0, #0x2
  20149c:	b9009260 	str	w0, [x19, #144]
        assert(tx_last_desc_idx >= 0);
  2014a0:	36fff420 	tbz	w0, #31, 201324 <notified+0x424>
  2014a4:	aa1603e3 	mov	x3, x22
  2014a8:	aa1903e1 	mov	x1, x25
  2014ac:	d0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  2014b0:	52802262 	mov	w2, #0x113                 	// #275
  2014b4:	91350000 	add	x0, x0, #0xd40
  2014b8:	94000852 	bl	203600 <_assert_fail>
  2014bc:	17ffff9a 	b	201324 <notified+0x424>
        assert(!(pkt.flags & VIRTQ_DESC_F_NEXT));
  2014c0:	aa1603e3 	mov	x3, x22
  2014c4:	aa1903e1 	mov	x1, x25
  2014c8:	d0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  2014cc:	52802102 	mov	w2, #0x108                 	// #264
  2014d0:	91330000 	add	x0, x0, #0xcc0
  2014d4:	f90037e5 	str	x5, [sp, #104]
  2014d8:	9400084a 	bl	203600 <_assert_fail>
  2014dc:	f94037e5 	ldr	x5, [sp, #104]
  2014e0:	17ffffb2 	b	2013a8 <notified+0x4a8>
        assert(tx_virtq.desc[hdr_used.id].flags & VIRTQ_DESC_F_NEXT);
  2014e4:	aa1903e1 	mov	x1, x25
  2014e8:	52802082 	mov	w2, #0x104                 	// #260
  2014ec:	aa1603e3 	mov	x3, x22
  2014f0:	d0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  2014f4:	91342000 	add	x0, x0, #0xd08
  2014f8:	f90037e5 	str	x5, [sp, #104]
  2014fc:	94000841 	bl	203600 <_assert_fail>
        struct virtq_desc pkt = tx_virtq.desc[tx_virtq.desc[hdr_used.id].next % tx_virtq.num];
  201500:	f94037e5 	ldr	x5, [sp, #104]
  201504:	b9407261 	ldr	w1, [x19, #112]
  201508:	f94004a2 	ldr	x2, [x5, #8]
  20150c:	8b180040 	add	x0, x2, x24
  201510:	17ffff9e 	b	201388 <notified+0x488>
    tx_last_seen_used += enqueued;
  201514:	f9403be1 	ldr	x1, [sp, #112]
  201518:	785fa020 	ldurh	w0, [x1, #-6]
  20151c:	0b0002a0 	add	w0, w21, w0
  201520:	781fa020 	sturh	w0, [x1, #-6]
    if (enqueued > 0 && net_require_signal_free(&tx_queue)) {
  201524:	35000155 	cbnz	w21, 20154c <notified+0x64c>
        tx_provide();
  201528:	97fffb8a 	bl	200350 <tx_provide>
        regs->InterruptACK = VIRTIO_MMIO_IRQ_VQUEUE;
  20152c:	f9403660 	ldr	x0, [x19, #104]
  201530:	52800021 	mov	w1, #0x1                   	// #1
  201534:	a9425bf5 	ldp	x21, x22, [sp, #32]
  201538:	a9446bf9 	ldp	x25, x26, [sp, #64]
  20153c:	a94573fb 	ldp	x27, x28, [sp, #80]
  201540:	b9006401 	str	w1, [x0, #100]
    if (irq_status & VIRTIO_MMIO_IRQ_CONFIG) {
  201544:	360fd257 	tbz	w23, #1, 200f8c <notified+0x8c>
  201548:	17fffe9f 	b	200fc4 <notified+0xc4>
    return !queue->free->consumer_signalled;
  20154c:	f9404e60 	ldr	x0, [x19, #152]
    if (enqueued > 0 && net_require_signal_free(&tx_queue)) {
  201550:	b9400401 	ldr	w1, [x0, #4]
  201554:	35fffea1 	cbnz	w1, 201528 <notified+0x628>
    queue->free->consumer_signalled = 1;
  201558:	52800021 	mov	w1, #0x1                   	// #1
  20155c:	b9000401 	str	w1, [x0, #4]
    register seL4_Word scno asm("x7") = sys;
  201560:	92800087 	mov	x7, #0xfffffffffffffffb    	// #-5
    register seL4_Word info asm("x1") = info_arg;
  201564:	d2800001 	mov	x1, #0x0                   	// #0
        microkit_notify(config.virt_tx.id);
  201568:	f0000000 	adrp	x0, 204000 <__sel4_ipc_buffer>
    seL4_Signal(BASE_OUTPUT_NOTIFICATION_CAP + ch);
  20156c:	395a8800 	ldrb	w0, [x0, #1698]
  201570:	91002800 	add	x0, x0, #0xa
    asm volatile(
  201574:	d4000001 	svc	#0x0
}
  201578:	17ffffec 	b	201528 <notified+0x628>
    queue->active->consumer_signalled = 1;
  20157c:	52800021 	mov	w1, #0x1                   	// #1
  201580:	b9000401 	str	w1, [x0, #4]
    register seL4_Word scno asm("x7") = sys;
  201584:	92800087 	mov	x7, #0xfffffffffffffffb    	// #-5
    register seL4_Word info asm("x1") = info_arg;
  201588:	d2800001 	mov	x1, #0x0                   	// #0
        microkit_notify(config.virt_rx.id);
  20158c:	f0000000 	adrp	x0, 204000 <__sel4_ipc_buffer>
    seL4_Signal(BASE_OUTPUT_NOTIFICATION_CAP + ch);
  201590:	3959e800 	ldrb	w0, [x0, #1658]
  201594:	91002800 	add	x0, x0, #0xa
    asm volatile(
  201598:	d4000001 	svc	#0x0
}
  20159c:	17ffff3c 	b	20128c <notified+0x38c>
        assert(!err);
  2015a0:	d0000003 	adrp	x3, 203000 <_vsnprintf+0x9f0>
  2015a4:	911a2063 	add	x3, x3, #0x688
  2015a8:	91012063 	add	x3, x3, #0x48
  2015ac:	d0000001 	adrp	x1, 203000 <_vsnprintf+0x9f0>
  2015b0:	d0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  2015b4:	911f0021 	add	x1, x1, #0x7c0
  2015b8:	9133a000 	add	x0, x0, #0xce8
  2015bc:	52802182 	mov	w2, #0x10c                 	// #268
  2015c0:	94000810 	bl	203600 <_assert_fail>
  2015c4:	17ffff89 	b	2013e8 <notified+0x4e8>
        assert(!err);
  2015c8:	d0000003 	adrp	x3, 203000 <_vsnprintf+0x9f0>
  2015cc:	911a2063 	add	x3, x3, #0x688
  2015d0:	9100e063 	add	x3, x3, #0x38
  2015d4:	d0000001 	adrp	x1, 203000 <_vsnprintf+0x9f0>
  2015d8:	d0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  2015dc:	911f0021 	add	x1, x1, #0x7c0
  2015e0:	9133a000 	add	x0, x0, #0xce8
  2015e4:	52801502 	mov	w2, #0xa8                  	// #168
  2015e8:	94000806 	bl	203600 <_assert_fail>
  2015ec:	17fffed3 	b	201138 <notified+0x238>

00000000002015f0 <protected>:
  2015f0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  2015f4:	90000020 	adrp	x0, 205000 <tx_descriptors+0x60>
  2015f8:	911f4000 	add	x0, x0, #0x7d0
  2015fc:	910003fd 	mov	x29, sp
  201600:	94000078 	bl	2017e0 <microkit_dbg_puts>
  201604:	d0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  201608:	91370000 	add	x0, x0, #0xdc0
  20160c:	94000075 	bl	2017e0 <microkit_dbg_puts>
  201610:	d2800000 	mov	x0, #0x0                   	// #0
  201614:	b900001f 	str	wzr, [x0]
  201618:	d4207d00 	brk	#0x3e8
  20161c:	d503201f 	nop

0000000000201620 <fault>:
  201620:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  201624:	90000020 	adrp	x0, 205000 <tx_descriptors+0x60>
  201628:	911f4000 	add	x0, x0, #0x7d0
  20162c:	910003fd 	mov	x29, sp
  201630:	9400006c 	bl	2017e0 <microkit_dbg_puts>
  201634:	d0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  201638:	9137c000 	add	x0, x0, #0xdf0
  20163c:	94000069 	bl	2017e0 <microkit_dbg_puts>
  201640:	d2800000 	mov	x0, #0x0                   	// #0
  201644:	b900001f 	str	wzr, [x0]
  201648:	d4207d00 	brk	#0x3e8
  20164c:	00000000 	udf	#0

0000000000201650 <main>:
  201650:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  201654:	f0000000 	adrp	x0, 204000 <__sel4_ipc_buffer>
  201658:	91000000 	add	x0, x0, #0x0
  20165c:	910003fd 	mov	x29, sp
  201660:	a90153f3 	stp	x19, x20, [sp, #16]
  201664:	f0000014 	adrp	x20, 204000 <__sel4_ipc_buffer>
  201668:	91000294 	add	x20, x20, #0x0
  20166c:	a9025bf5 	stp	x21, x22, [sp, #32]
  201670:	eb140015 	subs	x21, x0, x20
  201674:	54000100 	b.eq	201694 <main+0x44>  // b.none
  201678:	9343feb5 	asr	x21, x21, #3
  20167c:	d2800013 	mov	x19, #0x0                   	// #0
  201680:	f8737a80 	ldr	x0, [x20, x19, lsl #3]
  201684:	91000673 	add	x19, x19, #0x1
  201688:	d63f0000 	blr	x0
  20168c:	eb1302bf 	cmp	x21, x19
  201690:	54ffff88 	b.hi	201680 <main+0x30>  // b.pmore
  201694:	90000036 	adrp	x22, 205000 <tx_descriptors+0x60>
  201698:	911f42d6 	add	x22, x22, #0x7d0
  20169c:	97fffc5d 	bl	200810 <init>
  2016a0:	394102c0 	ldrb	w0, [x22, #64]
  2016a4:	340000a0 	cbz	w0, 2016b8 <main+0x68>
  2016a8:	52800021 	mov	w1, #0x1                   	// #1
  2016ac:	d28000a0 	mov	x0, #0x5                   	// #5
  2016b0:	390106c1 	strb	w1, [x22, #65]
  2016b4:	a90482df 	stp	xzr, x0, [x22, #72]
  2016b8:	f0000015 	adrp	x21, 204000 <__sel4_ipc_buffer>
  2016bc:	910002b5 	add	x21, x21, #0x0
  2016c0:	52800000 	mov	w0, #0x0                   	// #0
  2016c4:	d503201f 	nop
  2016c8:	35000220 	cbnz	w0, 20170c <main+0xbc>
  2016cc:	39c106c0 	ldrsb	w0, [x22, #65]
  2016d0:	350004e0 	cbnz	w0, 20176c <main+0x11c>
  2016d4:	d2800020 	mov	x0, #0x1                   	// #1
  2016d8:	d2800086 	mov	x6, #0x4                   	// #4
  2016dc:	928000c7 	mov	x7, #0xfffffffffffffff9    	// #-7
  2016e0:	d4000001 	svc	#0x0
  2016e4:	f94002a6 	ldr	x6, [x21]
  2016e8:	aa0003f3 	mov	x19, x0
  2016ec:	a9008cc2 	stp	x2, x3, [x6, #8]
  2016f0:	a90194c4 	stp	x4, x5, [x6, #24]
  2016f4:	b7f00313 	tbnz	x19, #62, 201754 <main+0x104>
  2016f8:	52800014 	mov	w20, #0x0                   	// #0
  2016fc:	b6f801b3 	tbz	x19, #63, 201730 <main+0xe0>
  201700:	12001660 	and	w0, w19, #0x3f
  201704:	97ffffbb 	bl	2015f0 <protected>
  201708:	f9001fe0 	str	x0, [sp, #56]
  20170c:	f94002a5 	ldr	x5, [x21]
  201710:	d2800020 	mov	x0, #0x1                   	// #1
  201714:	f9401fe1 	ldr	x1, [sp, #56]
  201718:	d2800086 	mov	x6, #0x4                   	// #4
  20171c:	a9408ca2 	ldp	x2, x3, [x5, #8]
  201720:	92800027 	mov	x7, #0xfffffffffffffffe    	// #-2
  201724:	a94194a4 	ldp	x4, x5, [x5, #24]
  201728:	d4000001 	svc	#0x0
  20172c:	17ffffee 	b	2016e4 <main+0x94>
  201730:	370000d3 	tbnz	w19, #0, 201748 <main+0xf8>
  201734:	d503201f 	nop
  201738:	d341fe73 	lsr	x19, x19, #1
  20173c:	11000694 	add	w20, w20, #0x1
  201740:	b4fffc73 	cbz	x19, 2016cc <main+0x7c>
  201744:	3607ffb3 	tbz	w19, #0, 201738 <main+0xe8>
  201748:	2a1403e0 	mov	w0, w20
  20174c:	97fffded 	bl	200f00 <notified>
  201750:	17fffffa 	b	201738 <main+0xe8>
  201754:	12001e60 	and	w0, w19, #0xff
  201758:	9100e3e2 	add	x2, sp, #0x38
  20175c:	97ffffb1 	bl	201620 <fault>
  201760:	72001c1f 	tst	w0, #0xff
  201764:	1a9f07e0 	cset	w0, ne	// ne = any
  201768:	17ffffd8 	b	2016c8 <main+0x78>
  20176c:	f94002a5 	ldr	x5, [x21]
  201770:	d2800020 	mov	x0, #0x1                   	// #1
  201774:	a944a2c1 	ldp	x1, x8, [x22, #72]
  201778:	d2800086 	mov	x6, #0x4                   	// #4
  20177c:	a9408ca2 	ldp	x2, x3, [x5, #8]
  201780:	92800047 	mov	x7, #0xfffffffffffffffd    	// #-3
  201784:	a94194a4 	ldp	x4, x5, [x5, #24]
  201788:	d4000001 	svc	#0x0
  20178c:	f94002a6 	ldr	x6, [x21]
  201790:	aa0003f3 	mov	x19, x0
  201794:	390106df 	strb	wzr, [x22, #65]
  201798:	a9008cc2 	stp	x2, x3, [x6, #8]
  20179c:	a90194c4 	stp	x4, x5, [x6, #24]
  2017a0:	17ffffd5 	b	2016f4 <main+0xa4>
	...

00000000002017b0 <microkit_dbg_putc>:
  2017b0:	d2800001 	mov	x1, #0x0                   	// #0
  2017b4:	92401c00 	and	x0, x0, #0xff
  2017b8:	d2800002 	mov	x2, #0x0                   	// #0
  2017bc:	d2800003 	mov	x3, #0x0                   	// #0
  2017c0:	d2800004 	mov	x4, #0x0                   	// #0
  2017c4:	d2800005 	mov	x5, #0x0                   	// #0
  2017c8:	d2800006 	mov	x6, #0x0                   	// #0
  2017cc:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  2017d0:	d4000001 	svc	#0x0
  2017d4:	d65f03c0 	ret
  2017d8:	d503201f 	nop
  2017dc:	d503201f 	nop

00000000002017e0 <microkit_dbg_puts>:
  2017e0:	aa0003e8 	mov	x8, x0
  2017e4:	39400000 	ldrb	w0, [x0]
  2017e8:	34000180 	cbz	w0, 201818 <microkit_dbg_puts+0x38>
  2017ec:	d503201f 	nop
  2017f0:	d2800001 	mov	x1, #0x0                   	// #0
  2017f4:	d2800002 	mov	x2, #0x0                   	// #0
  2017f8:	d2800003 	mov	x3, #0x0                   	// #0
  2017fc:	d2800004 	mov	x4, #0x0                   	// #0
  201800:	d2800005 	mov	x5, #0x0                   	// #0
  201804:	d2800006 	mov	x6, #0x0                   	// #0
  201808:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  20180c:	d4000001 	svc	#0x0
  201810:	38401d00 	ldrb	w0, [x8, #1]!
  201814:	35fffee0 	cbnz	w0, 2017f0 <microkit_dbg_puts+0x10>
  201818:	d65f03c0 	ret
  20181c:	d503201f 	nop

0000000000201820 <__assert_fail>:
  201820:	d000000b 	adrp	x11, 203000 <_vsnprintf+0x9f0>
  201824:	9138616b 	add	x11, x11, #0xe18
  201828:	aa0103e9 	mov	x9, x1
  20182c:	aa0303e8 	mov	x8, x3
  201830:	aa0003ea 	mov	x10, x0
  201834:	d2800c20 	mov	x0, #0x61                  	// #97
  201838:	d2800001 	mov	x1, #0x0                   	// #0
  20183c:	d2800002 	mov	x2, #0x0                   	// #0
  201840:	d2800003 	mov	x3, #0x0                   	// #0
  201844:	d2800004 	mov	x4, #0x0                   	// #0
  201848:	d2800005 	mov	x5, #0x0                   	// #0
  20184c:	d2800006 	mov	x6, #0x0                   	// #0
  201850:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  201854:	d4000001 	svc	#0x0
  201858:	38401d60 	ldrb	w0, [x11, #1]!
  20185c:	35fffee0 	cbnz	w0, 201838 <__assert_fail+0x18>
  201860:	39400140 	ldrb	w0, [x10]
  201864:	34000160 	cbz	w0, 201890 <__assert_fail+0x70>
  201868:	d2800001 	mov	x1, #0x0                   	// #0
  20186c:	d2800002 	mov	x2, #0x0                   	// #0
  201870:	d2800003 	mov	x3, #0x0                   	// #0
  201874:	d2800004 	mov	x4, #0x0                   	// #0
  201878:	d2800005 	mov	x5, #0x0                   	// #0
  20187c:	d2800006 	mov	x6, #0x0                   	// #0
  201880:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  201884:	d4000001 	svc	#0x0
  201888:	38401d40 	ldrb	w0, [x10, #1]!
  20188c:	35fffee0 	cbnz	w0, 201868 <__assert_fail+0x48>
  201890:	d2800400 	mov	x0, #0x20                  	// #32
  201894:	d2800001 	mov	x1, #0x0                   	// #0
  201898:	d2800002 	mov	x2, #0x0                   	// #0
  20189c:	d2800003 	mov	x3, #0x0                   	// #0
  2018a0:	d2800004 	mov	x4, #0x0                   	// #0
  2018a4:	d2800005 	mov	x5, #0x0                   	// #0
  2018a8:	d2800006 	mov	x6, #0x0                   	// #0
  2018ac:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  2018b0:	d4000001 	svc	#0x0
  2018b4:	39400120 	ldrb	w0, [x9]
  2018b8:	34000180 	cbz	w0, 2018e8 <__assert_fail+0xc8>
  2018bc:	d503201f 	nop
  2018c0:	d2800001 	mov	x1, #0x0                   	// #0
  2018c4:	d2800002 	mov	x2, #0x0                   	// #0
  2018c8:	d2800003 	mov	x3, #0x0                   	// #0
  2018cc:	d2800004 	mov	x4, #0x0                   	// #0
  2018d0:	d2800005 	mov	x5, #0x0                   	// #0
  2018d4:	d2800006 	mov	x6, #0x0                   	// #0
  2018d8:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  2018dc:	d4000001 	svc	#0x0
  2018e0:	38401d20 	ldrb	w0, [x9, #1]!
  2018e4:	35fffee0 	cbnz	w0, 2018c0 <__assert_fail+0xa0>
  2018e8:	d2800400 	mov	x0, #0x20                  	// #32
  2018ec:	d2800001 	mov	x1, #0x0                   	// #0
  2018f0:	d2800002 	mov	x2, #0x0                   	// #0
  2018f4:	d2800003 	mov	x3, #0x0                   	// #0
  2018f8:	d2800004 	mov	x4, #0x0                   	// #0
  2018fc:	d2800005 	mov	x5, #0x0                   	// #0
  201900:	d2800006 	mov	x6, #0x0                   	// #0
  201904:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  201908:	d4000001 	svc	#0x0
  20190c:	39400100 	ldrb	w0, [x8]
  201910:	34000180 	cbz	w0, 201940 <__assert_fail+0x120>
  201914:	d503201f 	nop
  201918:	d2800001 	mov	x1, #0x0                   	// #0
  20191c:	d2800002 	mov	x2, #0x0                   	// #0
  201920:	d2800003 	mov	x3, #0x0                   	// #0
  201924:	d2800004 	mov	x4, #0x0                   	// #0
  201928:	d2800005 	mov	x5, #0x0                   	// #0
  20192c:	d2800006 	mov	x6, #0x0                   	// #0
  201930:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  201934:	d4000001 	svc	#0x0
  201938:	38401d00 	ldrb	w0, [x8, #1]!
  20193c:	35fffee0 	cbnz	w0, 201918 <__assert_fail+0xf8>
  201940:	d2800140 	mov	x0, #0xa                   	// #10
  201944:	d2800001 	mov	x1, #0x0                   	// #0
  201948:	d2800002 	mov	x2, #0x0                   	// #0
  20194c:	d2800003 	mov	x3, #0x0                   	// #0
  201950:	d2800004 	mov	x4, #0x0                   	// #0
  201954:	d2800005 	mov	x5, #0x0                   	// #0
  201958:	d2800006 	mov	x6, #0x0                   	// #0
  20195c:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  201960:	d4000001 	svc	#0x0
  201964:	d65f03c0 	ret
	...

0000000000201970 <_out_buffer>:


// internal buffer output
static inline void _out_buffer(char character, void* buffer, size_t idx, size_t maxlen)
{
  if (idx < maxlen) {
  201970:	eb03005f 	cmp	x2, x3
{
  201974:	12001c00 	and	w0, w0, #0xff
  if (idx < maxlen) {
  201978:	54000042 	b.cs	201980 <_out_buffer+0x10>  // b.hs, b.nlast
    ((char*)buffer)[idx] = character;
  20197c:	38226820 	strb	w0, [x1, x2]
  }
}
  201980:	d65f03c0 	ret
  201984:	d503201f 	nop
  201988:	d503201f 	nop
  20198c:	d503201f 	nop

0000000000201990 <_out_null>:

// internal null output
static inline void _out_null(char character, void* buffer, size_t idx, size_t maxlen)
{
  (void)character; (void)buffer; (void)idx; (void)maxlen;
}
  201990:	d65f03c0 	ret
  201994:	d503201f 	nop
  201998:	d503201f 	nop
  20199c:	d503201f 	nop

00000000002019a0 <_out_rev>:
}


// output the specified string in reverse, taking care of any zero-padding
static size_t _out_rev(out_fct_type out, char* buffer, size_t idx, size_t maxlen, const char* buf, size_t len, unsigned int width, unsigned int flags)
{
  2019a0:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  2019a4:	910003fd 	mov	x29, sp
  2019a8:	a90153f3 	stp	x19, x20, [sp, #16]
  2019ac:	aa0503f3 	mov	x19, x5
  2019b0:	a9025bf5 	stp	x21, x22, [sp, #32]
  2019b4:	aa0003f5 	mov	x21, x0
  2019b8:	aa0103f6 	mov	x22, x1
  2019bc:	a90363f7 	stp	x23, x24, [sp, #48]
  const size_t start_idx = idx;

  // pad spaces up to given width
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
  2019c0:	120004e0 	and	w0, w7, #0x3
{
  2019c4:	aa0203f8 	mov	x24, x2
  2019c8:	a9046bf9 	stp	x25, x26, [sp, #64]
  2019cc:	aa0303f7 	mov	x23, x3
  2019d0:	aa0403f9 	mov	x25, x4
  2019d4:	a90573fb 	stp	x27, x28, [sp, #80]
  2019d8:	2a0603fa 	mov	w26, w6
  2019dc:	2a0703fb 	mov	w27, w7
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
  2019e0:	350005e0 	cbnz	w0, 201a9c <_out_rev+0xfc>
    for (size_t i = len; i < width; i++) {
  2019e4:	2a1a03e0 	mov	w0, w26
  2019e8:	aa0203f4 	mov	x20, x2
  2019ec:	cb05001c 	sub	x28, x0, x5
  2019f0:	eb0000bf 	cmp	x5, x0
  2019f4:	8b02039c 	add	x28, x28, x2
  2019f8:	540005a2 	b.cs	201aac <_out_rev+0x10c>  // b.hs, b.nlast
  2019fc:	d503201f 	nop
      out(' ', buffer, idx++, maxlen);
  201a00:	aa1403e2 	mov	x2, x20
  201a04:	aa1703e3 	mov	x3, x23
  201a08:	91000694 	add	x20, x20, #0x1
  201a0c:	aa1603e1 	mov	x1, x22
  201a10:	52800400 	mov	w0, #0x20                  	// #32
  201a14:	d63f02a0 	blr	x21
    for (size_t i = len; i < width; i++) {
  201a18:	eb1c029f 	cmp	x20, x28
  201a1c:	54ffff21 	b.ne	201a00 <_out_rev+0x60>  // b.any
    }
  }

  // reverse string
  while (len) {
  201a20:	b40002f3 	cbz	x19, 201a7c <_out_rev+0xdc>
  201a24:	8b13039c 	add	x28, x28, x19
  201a28:	cb130382 	sub	x2, x28, x19
    out(buf[--len], buffer, idx++, maxlen);
  201a2c:	d1000673 	sub	x19, x19, #0x1
  201a30:	aa1c03f4 	mov	x20, x28
  201a34:	aa1703e3 	mov	x3, x23
  201a38:	aa1603e1 	mov	x1, x22
  201a3c:	38736b20 	ldrb	w0, [x25, x19]
  201a40:	d63f02a0 	blr	x21
  while (len) {
  201a44:	b5ffff33 	cbnz	x19, 201a28 <_out_rev+0x88>
  }

  // append pad spaces up to given width
  if (flags & FLAGS_LEFT) {
  201a48:	360801bb 	tbz	w27, #1, 201a7c <_out_rev+0xdc>
    while (idx - start_idx < width) {
  201a4c:	cb180298 	sub	x24, x20, x24
  201a50:	eb1a031f 	cmp	x24, x26
  201a54:	54000142 	b.cs	201a7c <_out_rev+0xdc>  // b.hs, b.nlast
      out(' ', buffer, idx++, maxlen);
  201a58:	aa1403e2 	mov	x2, x20
  201a5c:	aa1703e3 	mov	x3, x23
  201a60:	aa1603e1 	mov	x1, x22
    while (idx - start_idx < width) {
  201a64:	91000718 	add	x24, x24, #0x1
      out(' ', buffer, idx++, maxlen);
  201a68:	52800400 	mov	w0, #0x20                  	// #32
  201a6c:	d63f02a0 	blr	x21
  201a70:	91000694 	add	x20, x20, #0x1
    while (idx - start_idx < width) {
  201a74:	eb1a031f 	cmp	x24, x26
  201a78:	54ffff03 	b.cc	201a58 <_out_rev+0xb8>  // b.lo, b.ul, b.last
    }
  }

  return idx;
}
  201a7c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  201a80:	aa1403e0 	mov	x0, x20
  201a84:	a94153f3 	ldp	x19, x20, [sp, #16]
  201a88:	a94363f7 	ldp	x23, x24, [sp, #48]
  201a8c:	a9446bf9 	ldp	x25, x26, [sp, #64]
  201a90:	a94573fb 	ldp	x27, x28, [sp, #80]
  201a94:	a8c67bfd 	ldp	x29, x30, [sp], #96
  201a98:	d65f03c0 	ret
  while (len) {
  201a9c:	aa0203fc 	mov	x28, x2
  201aa0:	aa0203f4 	mov	x20, x2
  201aa4:	b5fffc05 	cbnz	x5, 201a24 <_out_rev+0x84>
  201aa8:	17ffffe8 	b	201a48 <_out_rev+0xa8>
  201aac:	aa0203fc 	mov	x28, x2
  201ab0:	b5fffba5 	cbnz	x5, 201a24 <_out_rev+0x84>
  201ab4:	17fffff2 	b	201a7c <_out_rev+0xdc>
  201ab8:	d503201f 	nop
  201abc:	d503201f 	nop

0000000000201ac0 <_ntoa_long>:
}


// internal itoa for 'long' type
static size_t _ntoa_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long value, bool negative, unsigned long base, unsigned int prec, unsigned int width, unsigned int flags)
{
  201ac0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  201ac4:	aa0603ea 	mov	x10, x6
  201ac8:	aa0403e9 	mov	x9, x4
  201acc:	910003fd 	mov	x29, sp
  201ad0:	b9403be8 	ldr	w8, [sp, #56]
  201ad4:	2a0703ee 	mov	w14, w7
  201ad8:	b94033e6 	ldr	w6, [sp, #48]
  201adc:	12001cb1 	and	w17, w5, #0xff
  if (!value) {
    flags &= ~FLAGS_HASH;
  }

  // write if precision != 0 and value is != 0
  if (!(flags & FLAGS_PRECISION) || value) {
  201ae0:	1216010f 	and	w15, w8, #0x400
  if (!value) {
  201ae4:	b4000744 	cbz	x4, 201bcc <_ntoa_long+0x10c>
  if (flags & FLAGS_HASH) {
  201ae8:	121c0110 	and	w16, w8, #0x10
  201aec:	2a0803e7 	mov	w7, w8
    do {
      const char digit = (char)(value % base);
  201af0:	9aca092b 	udiv	x11, x9, x10
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  201af4:	721b00e4 	ands	w4, w7, #0x20
  201af8:	52800c24 	mov	w4, #0x61                  	// #97
  201afc:	5280082c 	mov	w12, #0x41                  	// #65
  201b00:	1a84118c 	csel	w12, w12, w4, ne	// ne = any
  201b04:	d2800005 	mov	x5, #0x0                   	// #0
  201b08:	5100298c 	sub	w12, w12, #0xa
  201b0c:	910043e4 	add	x4, sp, #0x10
      const char digit = (char)(value % base);
  201b10:	9b0aa568 	msub	x8, x11, x10, x9
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  201b14:	910004a5 	add	x5, x5, #0x1
  201b18:	f100251f 	cmp	x8, #0x9
      const char digit = (char)(value % base);
  201b1c:	12001d08 	and	w8, w8, #0xff
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  201b20:	1100c10d 	add	w13, w8, #0x30
  201b24:	0b0c0108 	add	w8, w8, w12
  201b28:	54000208 	b.hi	201b68 <_ntoa_long+0xa8>  // b.pmore
  201b2c:	d503201f 	nop
  201b30:	8b050088 	add	x8, x4, x5
      value /= base;
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
  201b34:	f1007cbf 	cmp	x5, #0x1f
  201b38:	fa4a9120 	ccmp	x9, x10, #0x0, ls	// ls = plast
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  201b3c:	381ff10d 	sturb	w13, [x8, #-1]
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
  201b40:	540001e3 	b.cc	201b7c <_ntoa_long+0xbc>  // b.lo, b.ul, b.last
      value /= base;
  201b44:	aa0b03e9 	mov	x9, x11
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  201b48:	910004a5 	add	x5, x5, #0x1
      const char digit = (char)(value % base);
  201b4c:	9aca092b 	udiv	x11, x9, x10
  201b50:	9b0aa568 	msub	x8, x11, x10, x9
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  201b54:	f100251f 	cmp	x8, #0x9
      const char digit = (char)(value % base);
  201b58:	12001d08 	and	w8, w8, #0xff
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  201b5c:	1100c10d 	add	w13, w8, #0x30
  201b60:	0b0c0108 	add	w8, w8, w12
  201b64:	54fffe69 	b.ls	201b30 <_ntoa_long+0x70>  // b.plast
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
  201b68:	eb0a013f 	cmp	x9, x10
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  201b6c:	8b050089 	add	x9, x4, x5
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
  201b70:	fa5f28a2 	ccmp	x5, #0x1f, #0x2, cs	// cs = hs, nlast
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  201b74:	381ff128 	sturb	w8, [x9, #-1]
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
  201b78:	54fffe69 	b.ls	201b44 <_ntoa_long+0x84>  // b.plast
  if (!(flags & FLAGS_LEFT)) {
  201b7c:	36080367 	tbz	w7, #1, 201be8 <_ntoa_long+0x128>
  if (flags & FLAGS_HASH) {
  201b80:	34000af0 	cbz	w16, 201cdc <_ntoa_long+0x21c>
    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
  201b84:	350008ef 	cbnz	w15, 201ca0 <_ntoa_long+0x1e0>
  201b88:	2a0e03e9 	mov	w9, w14
  201b8c:	b5000825 	cbnz	x5, 201c90 <_ntoa_long+0x1d0>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201b90:	f100415f 	cmp	x10, #0x10
  201b94:	54001460 	b.eq	201e20 <_ntoa_long+0x360>  // b.none
    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201b98:	f100095f 	cmp	x10, #0x2
  201b9c:	54001201 	b.ne	201ddc <_ntoa_long+0x31c>  // b.any
  201ba0:	52800c48 	mov	w8, #0x62                  	// #98
      buf[len++] = '0';
  201ba4:	52800609 	mov	w9, #0x30                  	// #48
  201ba8:	d2800045 	mov	x5, #0x2                   	// #2
      buf[len++] = 'b';
  201bac:	390043e8 	strb	w8, [sp, #16]
      buf[len++] = '0';
  201bb0:	390047e9 	strb	w9, [sp, #17]
    if (negative) {
  201bb4:	37000b71 	tbnz	w17, #0, 201d20 <_ntoa_long+0x260>
    else if (flags & FLAGS_PLUS) {
  201bb8:	36100f87 	tbz	w7, #2, 201da8 <_ntoa_long+0x2e8>
      buf[len++] = '+';  // ignore the space if the '+' exists
  201bbc:	52800568 	mov	w8, #0x2b                  	// #43
  201bc0:	38256888 	strb	w8, [x4, x5]
  201bc4:	910004a5 	add	x5, x5, #0x1
  201bc8:	14000047 	b	201ce4 <_ntoa_long+0x224>
    flags &= ~FLAGS_HASH;
  201bcc:	121b7907 	and	w7, w8, #0xffffffef
  if (!(flags & FLAGS_PRECISION) || value) {
  201bd0:	3400090f 	cbz	w15, 201cf0 <_ntoa_long+0x230>
  if (!(flags & FLAGS_LEFT)) {
  201bd4:	121f0110 	and	w16, w8, #0x2
  201bd8:	37080c48 	tbnz	w8, #1, 201d60 <_ntoa_long+0x2a0>
  201bdc:	910043e4 	add	x4, sp, #0x10
  size_t len = 0U;
  201be0:	d2800005 	mov	x5, #0x0                   	// #0
  if (!(flags & FLAGS_PRECISION) || value) {
  201be4:	5280800f 	mov	w15, #0x400                 	// #1024
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201be8:	2a0e03e9 	mov	w9, w14
    if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
  201bec:	350003e6 	cbnz	w6, 201c68 <_ntoa_long+0x1a8>
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201bf0:	eb05013f 	cmp	x9, x5
  201bf4:	54fffc69 	b.ls	201b80 <_ntoa_long+0xc0>  // b.plast
  201bf8:	f10080bf 	cmp	x5, #0x20
    if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
  201bfc:	120000ec 	and	w12, w7, #0x1
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201c00:	54000400 	b.eq	201c80 <_ntoa_long+0x1c0>  // b.none
      buf[len++] = '0';
  201c04:	5280060b 	mov	w11, #0x30                  	// #48
  201c08:	14000003 	b	201c14 <_ntoa_long+0x154>
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201c0c:	f10080bf 	cmp	x5, #0x20
  201c10:	54000740 	b.eq	201cf8 <_ntoa_long+0x238>  // b.none
      buf[len++] = '0';
  201c14:	910004a5 	add	x5, x5, #0x1
  201c18:	8b050088 	add	x8, x4, x5
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201c1c:	eb0900bf 	cmp	x5, x9
      buf[len++] = '0';
  201c20:	381ff10b 	sturb	w11, [x8, #-1]
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201c24:	54ffff43 	b.cc	201c0c <_ntoa_long+0x14c>  // b.lo, b.ul, b.last
    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201c28:	34fffacc 	cbz	w12, 201b80 <_ntoa_long+0xc0>
  201c2c:	2a0603eb 	mov	w11, w6
  201c30:	eb05017f 	cmp	x11, x5
  201c34:	54fffa69 	b.ls	201b80 <_ntoa_long+0xc0>  // b.plast
  201c38:	f10080bf 	cmp	x5, #0x20
      buf[len++] = '0';
  201c3c:	5280060c 	mov	w12, #0x30                  	// #48
    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201c40:	54000081 	b.ne	201c50 <_ntoa_long+0x190>  // b.any
  201c44:	14000030 	b	201d04 <_ntoa_long+0x244>
  201c48:	f10080bf 	cmp	x5, #0x20
  201c4c:	54000a80 	b.eq	201d9c <_ntoa_long+0x2dc>  // b.none
      buf[len++] = '0';
  201c50:	910004a5 	add	x5, x5, #0x1
  201c54:	8b050088 	add	x8, x4, x5
    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201c58:	eb0b00bf 	cmp	x5, x11
      buf[len++] = '0';
  201c5c:	381ff10c 	sturb	w12, [x8, #-1]
    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201c60:	54ffff41 	b.ne	201c48 <_ntoa_long+0x188>  // b.any
  201c64:	17ffffc7 	b	201b80 <_ntoa_long+0xc0>
    if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
  201c68:	120000ec 	and	w12, w7, #0x1
  201c6c:	37000667 	tbnz	w7, #0, 201d38 <_ntoa_long+0x278>
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201c70:	eb05013f 	cmp	x9, x5
  201c74:	54fff869 	b.ls	201b80 <_ntoa_long+0xc0>  // b.plast
  201c78:	f10080bf 	cmp	x5, #0x20
  201c7c:	54fffc41 	b.ne	201c04 <_ntoa_long+0x144>  // b.any
  if (flags & FLAGS_HASH) {
  201c80:	340004d0 	cbz	w16, 201d18 <_ntoa_long+0x258>
    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
  201c84:	350004af 	cbnz	w15, 201d18 <_ntoa_long+0x258>
  201c88:	d2800405 	mov	x5, #0x20                  	// #32
  201c8c:	d503201f 	nop
  201c90:	eb05013f 	cmp	x9, x5
  201c94:	54000720 	b.eq	201d78 <_ntoa_long+0x2b8>  // b.none
  201c98:	eb2640bf 	cmp	x5, w6, uxtw
  201c9c:	540006e0 	b.eq	201d78 <_ntoa_long+0x2b8>  // b.none
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201ca0:	f100415f 	cmp	x10, #0x10
  201ca4:	540008c0 	b.eq	201dbc <_ntoa_long+0x2fc>  // b.none
    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201ca8:	7100095f 	cmp	w10, #0x2
  201cac:	fa5f08a2 	ccmp	x5, #0x1f, #0x2, eq	// eq = none
  201cb0:	540000a8 	b.hi	201cc4 <_ntoa_long+0x204>  // b.pmore
      buf[len++] = 'b';
  201cb4:	aa0503e8 	mov	x8, x5
  201cb8:	910004a5 	add	x5, x5, #0x1
  201cbc:	52800c49 	mov	w9, #0x62                  	// #98
  201cc0:	38286889 	strb	w9, [x4, x8]
    if (len < PRINTF_NTOA_BUFFER_SIZE) {
  201cc4:	f10080bf 	cmp	x5, #0x20
  201cc8:	540000e0 	b.eq	201ce4 <_ntoa_long+0x224>  // b.none
      buf[len++] = '0';
  201ccc:	aa0503e8 	mov	x8, x5
  201cd0:	910004a5 	add	x5, x5, #0x1
  201cd4:	52800609 	mov	w9, #0x30                  	// #48
  201cd8:	38286889 	strb	w9, [x4, x8]
  if (len < PRINTF_NTOA_BUFFER_SIZE) {
  201cdc:	f10080bf 	cmp	x5, #0x20
  201ce0:	54fff6a1 	b.ne	201bb4 <_ntoa_long+0xf4>  // b.any
  return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
  201ce4:	97ffff2f 	bl	2019a0 <_out_rev>
  }

  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
}
  201ce8:	a8c37bfd 	ldp	x29, x30, [sp], #48
  201cec:	d65f03c0 	ret
  if (!(flags & FLAGS_PRECISION) || value) {
  201cf0:	52800010 	mov	w16, #0x0                   	// #0
  201cf4:	17ffff7f 	b	201af0 <_ntoa_long+0x30>
    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201cf8:	3400052c 	cbz	w12, 201d9c <_ntoa_long+0x2dc>
  201cfc:	710080df 	cmp	w6, #0x20
  201d00:	540004e9 	b.ls	201d9c <_ntoa_long+0x2dc>  // b.plast
  if (flags & FLAGS_HASH) {
  201d04:	d2800405 	mov	x5, #0x20                  	// #32
  201d08:	34fffef0 	cbz	w16, 201ce4 <_ntoa_long+0x224>
    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
  201d0c:	34fffc2f 	cbz	w15, 201c90 <_ntoa_long+0x1d0>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201d10:	f100415f 	cmp	x10, #0x10
  201d14:	54fffe81 	b.ne	201ce4 <_ntoa_long+0x224>  // b.any
  201d18:	d2800405 	mov	x5, #0x20                  	// #32
  201d1c:	17fffff2 	b	201ce4 <_ntoa_long+0x224>
      buf[len++] = '-';
  201d20:	528005a8 	mov	w8, #0x2d                  	// #45
  201d24:	38256888 	strb	w8, [x4, x5]
  201d28:	910004a5 	add	x5, x5, #0x1
  return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
  201d2c:	97ffff1d 	bl	2019a0 <_out_rev>
}
  201d30:	a8c37bfd 	ldp	x29, x30, [sp], #48
  201d34:	d65f03c0 	ret
    if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
  201d38:	370001d1 	tbnz	w17, #0, 201d70 <_ntoa_long+0x2b0>
  201d3c:	721e04ff 	tst	w7, #0xc
  201d40:	54000181 	b.ne	201d70 <_ntoa_long+0x2b0>  // b.any
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201d44:	eb05013f 	cmp	x9, x5
  201d48:	54fff729 	b.ls	201c2c <_ntoa_long+0x16c>  // b.plast
  201d4c:	f10080bf 	cmp	x5, #0x20
  201d50:	54fff5a1 	b.ne	201c04 <_ntoa_long+0x144>  // b.any
    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201d54:	710080df 	cmp	w6, #0x20
  201d58:	54fffd68 	b.hi	201d04 <_ntoa_long+0x244>  // b.pmore
  201d5c:	17ffffc9 	b	201c80 <_ntoa_long+0x1c0>
  201d60:	910043e4 	add	x4, sp, #0x10
  size_t len = 0U;
  201d64:	d2800005 	mov	x5, #0x0                   	// #0
    if (negative) {
  201d68:	3607f291 	tbz	w17, #0, 201bb8 <_ntoa_long+0xf8>
  201d6c:	17ffffed 	b	201d20 <_ntoa_long+0x260>
      width--;
  201d70:	510004c6 	sub	w6, w6, #0x1
  201d74:	17fffff4 	b	201d44 <_ntoa_long+0x284>
      if (len && (base == 16U)) {
  201d78:	f10004a8 	subs	x8, x5, #0x1
  201d7c:	7a501940 	ccmp	w10, #0x10, #0x0, ne	// ne = any
  201d80:	54000461 	b.ne	201e0c <_ntoa_long+0x34c>  // b.any
        len--;
  201d84:	d10008a5 	sub	x5, x5, #0x2
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201d88:	36280567 	tbz	w7, #5, 201e34 <_ntoa_long+0x374>
      buf[len++] = 'X';
  201d8c:	52800b09 	mov	w9, #0x58                  	// #88
  201d90:	38256889 	strb	w9, [x4, x5]
  201d94:	aa0803e5 	mov	x5, x8
  201d98:	17ffffcd 	b	201ccc <_ntoa_long+0x20c>
  if (flags & FLAGS_HASH) {
  201d9c:	d2800405 	mov	x5, #0x20                  	// #32
  201da0:	35ffef30 	cbnz	w16, 201b84 <_ntoa_long+0xc4>
  201da4:	17ffffd0 	b	201ce4 <_ntoa_long+0x224>
    else if (flags & FLAGS_SPACE) {
  201da8:	361ff9e7 	tbz	w7, #3, 201ce4 <_ntoa_long+0x224>
      buf[len++] = ' ';
  201dac:	52800408 	mov	w8, #0x20                  	// #32
  201db0:	38256888 	strb	w8, [x4, x5]
  201db4:	910004a5 	add	x5, x5, #0x1
  201db8:	17ffffcb 	b	201ce4 <_ntoa_long+0x224>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201dbc:	372801a7 	tbnz	w7, #5, 201df0 <_ntoa_long+0x330>
  201dc0:	f10080bf 	cmp	x5, #0x20
  201dc4:	54fffaa0 	b.eq	201d18 <_ntoa_long+0x258>  // b.none
      buf[len++] = 'X';
  201dc8:	aa0503e8 	mov	x8, x5
  201dcc:	910004a5 	add	x5, x5, #0x1
      buf[len++] = 'x';
  201dd0:	52800f09 	mov	w9, #0x78                  	// #120
  201dd4:	38286889 	strb	w9, [x4, x8]
  201dd8:	17ffffbb 	b	201cc4 <_ntoa_long+0x204>
      buf[len++] = '0';
  201ddc:	52800608 	mov	w8, #0x30                  	// #48
  201de0:	390043e8 	strb	w8, [sp, #16]
  201de4:	d2800025 	mov	x5, #0x1                   	// #1
    if (negative) {
  201de8:	3607ee91 	tbz	w17, #0, 201bb8 <_ntoa_long+0xf8>
  201dec:	17ffffcd 	b	201d20 <_ntoa_long+0x260>
    else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201df0:	f10080bf 	cmp	x5, #0x20
  201df4:	54fff920 	b.eq	201d18 <_ntoa_long+0x258>  // b.none
      buf[len++] = 'X';
  201df8:	aa0503e8 	mov	x8, x5
  201dfc:	910004a5 	add	x5, x5, #0x1
  201e00:	52800b09 	mov	w9, #0x58                  	// #88
  201e04:	38286889 	strb	w9, [x4, x8]
  201e08:	17ffffaf 	b	201cc4 <_ntoa_long+0x204>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201e0c:	f100415f 	cmp	x10, #0x10
  201e10:	540001a0 	b.eq	201e44 <_ntoa_long+0x384>  // b.none
    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201e14:	f100095f 	cmp	x10, #0x2
  201e18:	54fff520 	b.eq	201cbc <_ntoa_long+0x1fc>  // b.none
  201e1c:	17ffffae 	b	201cd4 <_ntoa_long+0x214>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201e20:	721b00e5 	ands	w5, w7, #0x20
  201e24:	52800b08 	mov	w8, #0x58                  	// #88
  201e28:	52800f05 	mov	w5, #0x78                  	// #120
  201e2c:	1a851108 	csel	w8, w8, w5, ne	// ne = any
  201e30:	17ffff5d 	b	201ba4 <_ntoa_long+0xe4>
      buf[len++] = 'x';
  201e34:	52800f09 	mov	w9, #0x78                  	// #120
  201e38:	38256889 	strb	w9, [x4, x5]
      buf[len++] = 'X';
  201e3c:	aa0803e5 	mov	x5, x8
  201e40:	17ffffa3 	b	201ccc <_ntoa_long+0x20c>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  201e44:	362ffc67 	tbz	w7, #5, 201dd0 <_ntoa_long+0x310>
  201e48:	17ffffee 	b	201e00 <_ntoa_long+0x340>
  201e4c:	d503201f 	nop

0000000000201e50 <_out_char>:
  if (character) {
  201e50:	72001c00 	ands	w0, w0, #0xff
  201e54:	54000041 	b.ne	201e5c <_out_char+0xc>  // b.any
}
  201e58:	d65f03c0 	ret
    _sddf_putchar(character);
  201e5c:	140005f5 	b	203630 <_sddf_putchar>

0000000000201e60 <_out_fct>:
  if (character) {
  201e60:	72001c00 	ands	w0, w0, #0xff
  201e64:	54000080 	b.eq	201e74 <_out_fct+0x14>  // b.none
    ((out_fct_wrap_type*)buffer)->fct(character, ((out_fct_wrap_type*)buffer)->arg);
  201e68:	a9400422 	ldp	x2, x1, [x1]
  201e6c:	aa0203f0 	mov	x16, x2
  201e70:	d61f0200 	br	x16
}
  201e74:	d65f03c0 	ret
  201e78:	d503201f 	nop
  201e7c:	d503201f 	nop

0000000000201e80 <_ftoa>:

  // powers of 10
  static const double pow10[] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };

  // test for special values
  if (value != value)
  201e80:	1e602000 	fcmp	d0, d0
{
  201e84:	2a0603e7 	mov	w7, w6
  if (value != value)
  201e88:	54000fa1 	b.ne	20207c <_ftoa+0x1fc>  // b.any
    return _out_rev(out, buffer, idx, maxlen, "nan", 3, width, flags);
  if (value < -DBL_MAX)
  201e8c:	92e00206 	mov	x6, #0xffefffffffffffff    	// #-4503599627370497
  201e90:	9e6700c1 	fmov	d1, x6
  201e94:	1e612010 	fcmpe	d0, d1
  201e98:	54001324 	b.mi	2020fc <_ftoa+0x27c>  // b.first
  201e9c:	aa0003ef 	mov	x15, x0
    return _out_rev(out, buffer, idx, maxlen, "fni-", 4, width, flags);
  if (value > DBL_MAX)
  201ea0:	92f00200 	mov	x0, #0x7fefffffffffffff    	// #9218868437227405311
  201ea4:	9e670001 	fmov	d1, x0
  201ea8:	aa0103f0 	mov	x16, x1
  201eac:	aa0203f1 	mov	x17, x2
  201eb0:	aa0303f2 	mov	x18, x3
  201eb4:	1e612010 	fcmpe	d0, d1
  201eb8:	54000ccc 	b.gt	202050 <_ftoa+0x1d0>
    return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? "fni+" : "fni", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);

  // test for very large values
  // standard printf behavior is to print EVERY whole number digit -- which could be 100s of characters overflowing your buffers == bad
  if ((value > PRINTF_MAX_FLOAT) || (value < -PRINTF_MAX_FLOAT)) {
  201ebc:	d2d9aca0 	mov	x0, #0xcd6500000000        	// #225833675390976
  201ec0:	f2e839a0 	movk	x0, #0x41cd, lsl #48
  201ec4:	9e670001 	fmov	d1, x0
  201ec8:	1e612010 	fcmpe	d0, d1
  201ecc:	540010cc 	b.gt	2020e4 <_ftoa+0x264>
  201ed0:	d2d9aca0 	mov	x0, #0xcd6500000000        	// #225833675390976
  201ed4:	f2f839a0 	movk	x0, #0xc1cd, lsl #48
  201ed8:	9e670001 	fmov	d1, x0
  201edc:	1e612010 	fcmpe	d0, d1
  201ee0:	54001024 	b.mi	2020e4 <_ftoa+0x264>  // b.first
#endif
  }

  // test for negative
  bool negative = false;
  if (value < 0) {
  201ee4:	1e602018 	fcmpe	d0, #0.0
{
  201ee8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  201eec:	910003fd 	mov	x29, sp
  if (value < 0) {
  201ef0:	54000e44 	b.mi	2020b8 <_ftoa+0x238>  // b.first
  bool negative = false;
  201ef4:	52800003 	mov	w3, #0x0                   	// #0
    negative = true;
    value = 0 - value;
  }

  // set default precision, if not set explicitly
  if (!(flags & FLAGS_PRECISION)) {
  201ef8:	36500e87 	tbz	w7, #10, 2020c8 <_ftoa+0x248>
    prec = PRINTF_DEFAULT_FLOAT_PRECISION;
  }
  // limit precision to 9, cause a prec >= 10 can lead to overflow errors
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
  201efc:	7100249f 	cmp	w4, #0x9
  201f00:	54001ac9 	b.ls	202258 <_ftoa+0x3d8>  // b.plast
  201f04:	910043ec 	add	x12, sp, #0x10
  201f08:	d2800008 	mov	x8, #0x0                   	// #0
    buf[len++] = '0';
  201f0c:	52800601 	mov	w1, #0x30                  	// #48
  201f10:	91000508 	add	x8, x8, #0x1
    prec--;
  201f14:	51000484 	sub	w4, w4, #0x1
    buf[len++] = '0';
  201f18:	8b080180 	add	x0, x12, x8
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
  201f1c:	f1007d1f 	cmp	x8, #0x1f
  201f20:	7a499880 	ccmp	w4, #0x9, #0x0, ls	// ls = plast
    buf[len++] = '0';
  201f24:	381ff001 	sturb	w1, [x0, #-1]
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
  201f28:	54ffff48 	b.hi	201f10 <_ftoa+0x90>  // b.pmore
  201f2c:	d2d9aca0 	mov	x0, #0xcd6500000000        	// #225833675390976
  201f30:	f2e839a0 	movk	x0, #0x41cd, lsl #48
  201f34:	9e670002 	fmov	d2, x0
  }

  int whole = (int)value;
  201f38:	1e78000a 	fcvtzs	w10, d0
  double tmp = (value - whole) * pow10[prec];
  unsigned long frac = (unsigned long)tmp;
  diff = tmp - frac;

  if (diff > 0.5) {
  201f3c:	1e6c1003 	fmov	d3, #5.000000000000000000e-01
  double tmp = (value - whole) * pow10[prec];
  201f40:	1e620141 	scvtf	d1, w10
  201f44:	1e613801 	fsub	d1, d0, d1
  201f48:	1e620821 	fmul	d1, d1, d2
  unsigned long frac = (unsigned long)tmp;
  201f4c:	9e79002e 	fcvtzu	x14, d1
  diff = tmp - frac;
  201f50:	9e6301c4 	ucvtf	d4, x14
  201f54:	1e643821 	fsub	d1, d1, d4
  if (diff > 0.5) {
  201f58:	1e632030 	fcmpe	d1, d3
  201f5c:	5400106c 	b.gt	202168 <_ftoa+0x2e8>
    if (frac >= pow10[prec]) {
      frac = 0;
      ++whole;
    }
  }
  else if (diff < 0.5) {
  201f60:	54000084 	b.mi	201f70 <_ftoa+0xf0>  // b.first
  }
  else if ((frac == 0U) || (frac & 1U)) {
  201f64:	b50016ae 	cbnz	x14, 202238 <_ftoa+0x3b8>
    // if halfway, round up if odd OR if last digit is 0
    ++frac;
  201f68:	910005ce 	add	x14, x14, #0x1
  201f6c:	d503201f 	nop
  }

  if (prec == 0U) {
  201f70:	35000d04 	cbnz	w4, 202110 <_ftoa+0x290>
    diff = value - (double)whole;
  201f74:	1e620142 	scvtf	d2, w10
    if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
  201f78:	1e6c1001 	fmov	d1, #5.000000000000000000e-01
      // exactly 0.5 and ODD, then round up
      // 1.5 -> 2, but 2.5 -> 2
      ++whole;
  201f7c:	12000140 	and	w0, w10, #0x1
  201f80:	0b000140 	add	w0, w10, w0
    diff = value - (double)whole;
  201f84:	1e623800 	fsub	d0, d0, d2
      ++whole;
  201f88:	1e612010 	fcmpe	d0, d1
  201f8c:	1a80414a 	csel	w10, w10, w0, mi	// mi = first
    }
  }

  // do whole part, number is reversed
  while (len < PRINTF_FTOA_BUFFER_SIZE) {
    buf[len++] = (char)(48 + (whole % 10));
  201f90:	528ccce1 	mov	w1, #0x6667                	// #26215
  201f94:	72acccc1 	movk	w1, #0x6666, lsl #16
  201f98:	52800142 	mov	w2, #0xa                   	// #10
  201f9c:	1400000a 	b	201fc4 <_ftoa+0x144>
  201fa0:	9362fd29 	asr	x9, x9, #34
  201fa4:	91000508 	add	x8, x8, #0x1
  201fa8:	4b8a7d29 	sub	w9, w9, w10, asr #31
  201fac:	8b080180 	add	x0, x12, x8
  201fb0:	1b02a92b 	msub	w11, w9, w2, w10
    if (!(whole /= 10)) {
  201fb4:	2a0903ea 	mov	w10, w9
    buf[len++] = (char)(48 + (whole % 10));
  201fb8:	1100c169 	add	w9, w11, #0x30
  201fbc:	381ff009 	sturb	w9, [x0, #-1]
    if (!(whole /= 10)) {
  201fc0:	34000e4a 	cbz	w10, 202188 <_ftoa+0x308>
    buf[len++] = (char)(48 + (whole % 10));
  201fc4:	9b217d49 	smull	x9, w10, w1
  while (len < PRINTF_FTOA_BUFFER_SIZE) {
  201fc8:	f100811f 	cmp	x8, #0x20
  201fcc:	54fffea1 	b.ne	201fa0 <_ftoa+0x120>  // b.any
      break;
    }
  }

  // pad leading zeros
  if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
  201fd0:	120004e0 	and	w0, w7, #0x3
  201fd4:	7100041f 	cmp	w0, #0x1
  201fd8:	54000281 	b.ne	202028 <_ftoa+0x1a8>  // b.any
    if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
  201fdc:	34000265 	cbz	w5, 202028 <_ftoa+0x1a8>
  201fe0:	35001323 	cbnz	w3, 202244 <_ftoa+0x3c4>
  201fe4:	721e04ff 	tst	w7, #0xc
  201fe8:	540012e1 	b.ne	202244 <_ftoa+0x3c4>  // b.any
      width--;
    }
    while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
  201fec:	2a0503e2 	mov	w2, w5
  201ff0:	eb02011f 	cmp	x8, x2
  201ff4:	54001002 	b.cs	2021f4 <_ftoa+0x374>  // b.hs, b.nlast
  201ff8:	f100811f 	cmp	x8, #0x20
      buf[len++] = '0';
  201ffc:	52800601 	mov	w1, #0x30                  	// #48
    while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
  202000:	54000120 	b.eq	202024 <_ftoa+0x1a4>  // b.none
  202004:	d503201f 	nop
      buf[len++] = '0';
  202008:	91000508 	add	x8, x8, #0x1
  20200c:	8b080180 	add	x0, x12, x8
    while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
  202010:	eb02011f 	cmp	x8, x2
      buf[len++] = '0';
  202014:	381ff001 	sturb	w1, [x0, #-1]
    while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
  202018:	54000be0 	b.eq	202194 <_ftoa+0x314>  // b.none
  20201c:	f100811f 	cmp	x8, #0x20
  202020:	54ffff41 	b.ne	202008 <_ftoa+0x188>  // b.any
    }
    else if (flags & FLAGS_PLUS) {
      buf[len++] = '+';  // ignore the space if the '+' exists
    }
    else if (flags & FLAGS_SPACE) {
      buf[len++] = ' ';
  202024:	d2800408 	mov	x8, #0x20                  	// #32
    }
  }

  return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
  202028:	2a0503e6 	mov	w6, w5
  20202c:	aa0c03e4 	mov	x4, x12
  202030:	aa0803e5 	mov	x5, x8
  202034:	aa1203e3 	mov	x3, x18
  202038:	aa1103e2 	mov	x2, x17
  20203c:	aa1003e1 	mov	x1, x16
  202040:	aa0f03e0 	mov	x0, x15
  202044:	97fffe57 	bl	2019a0 <_out_rev>
}
  202048:	a8c37bfd 	ldp	x29, x30, [sp], #48
  20204c:	d65f03c0 	ret
    return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? "fni+" : "fni", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);
  202050:	37100207 	tbnz	w7, #2, 202090 <_ftoa+0x210>
  202054:	d2800060 	mov	x0, #0x3                   	// #3
  202058:	2a0503e6 	mov	w6, w5
  20205c:	b0000004 	adrp	x4, 203000 <_vsnprintf+0x9f0>
  202060:	9138c084 	add	x4, x4, #0xe30
  202064:	aa0003e5 	mov	x5, x0
  202068:	aa1203e3 	mov	x3, x18
  20206c:	aa1103e2 	mov	x2, x17
  202070:	aa1003e1 	mov	x1, x16
  202074:	aa0f03e0 	mov	x0, x15
  202078:	17fffe4a 	b	2019a0 <_out_rev>
    return _out_rev(out, buffer, idx, maxlen, "nan", 3, width, flags);
  20207c:	2a0503e6 	mov	w6, w5
  202080:	b0000004 	adrp	x4, 203000 <_vsnprintf+0x9f0>
  202084:	d2800065 	mov	x5, #0x3                   	// #3
  202088:	9138e084 	add	x4, x4, #0xe38
  20208c:	17fffe45 	b	2019a0 <_out_rev>
    return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? "fni+" : "fni", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);
  202090:	d2800080 	mov	x0, #0x4                   	// #4
  202094:	2a0503e6 	mov	w6, w5
  202098:	b0000004 	adrp	x4, 203000 <_vsnprintf+0x9f0>
  20209c:	9138a084 	add	x4, x4, #0xe28
  2020a0:	aa0003e5 	mov	x5, x0
  2020a4:	aa1203e3 	mov	x3, x18
  2020a8:	aa1103e2 	mov	x2, x17
  2020ac:	aa1003e1 	mov	x1, x16
  2020b0:	aa0f03e0 	mov	x0, x15
  2020b4:	17fffe3b 	b	2019a0 <_out_rev>
    value = 0 - value;
  2020b8:	2f00e401 	movi	d1, #0x0
    negative = true;
  2020bc:	52800023 	mov	w3, #0x1                   	// #1
    value = 0 - value;
  2020c0:	1e603820 	fsub	d0, d1, d0
  if (!(flags & FLAGS_PRECISION)) {
  2020c4:	3757f1c7 	tbnz	w7, #10, 201efc <_ftoa+0x7c>
  2020c8:	d2d09000 	mov	x0, #0x848000000000        	// #145685290680320
  2020cc:	910043ec 	add	x12, sp, #0x10
  2020d0:	f2e825c0 	movk	x0, #0x412e, lsl #48
    prec = PRINTF_DEFAULT_FLOAT_PRECISION;
  2020d4:	528000c4 	mov	w4, #0x6                   	// #6
  2020d8:	9e670002 	fmov	d2, x0
  2020dc:	d2800008 	mov	x8, #0x0                   	// #0
  2020e0:	17ffff96 	b	201f38 <_ftoa+0xb8>
    return _etoa(out, buffer, idx, maxlen, value, prec, width, flags);
  2020e4:	2a0703e6 	mov	w6, w7
  2020e8:	aa1203e3 	mov	x3, x18
  2020ec:	aa1103e2 	mov	x2, x17
  2020f0:	aa1003e1 	mov	x1, x16
  2020f4:	aa0f03e0 	mov	x0, x15
  2020f8:	14000062 	b	202280 <_etoa>
    return _out_rev(out, buffer, idx, maxlen, "fni-", 4, width, flags);
  2020fc:	2a0503e6 	mov	w6, w5
  202100:	b0000004 	adrp	x4, 203000 <_vsnprintf+0x9f0>
  202104:	d2800085 	mov	x5, #0x4                   	// #4
  202108:	91390084 	add	x4, x4, #0xe40
  20210c:	17fffe25 	b	2019a0 <_out_rev>
  202110:	51008081 	sub	w1, w4, #0x20
      buf[len++] = (char)(48U + (frac % 10U));
  202114:	b202e7e2 	mov	x2, #0xcccccccccccccccc    	// #-3689348814741910324
  202118:	0b080021 	add	w1, w1, w8
  20211c:	f29999a2 	movk	x2, #0xcccd
  202120:	1400000d 	b	202154 <_ftoa+0x2d4>
  202124:	d343fd6b 	lsr	x11, x11, #3
      if (!(frac /= 10U)) {
  202128:	f10025df 	cmp	x14, #0x9
      --count;
  20212c:	51000480 	sub	w0, w4, #0x1
      buf[len++] = (char)(48U + (frac % 10U));
  202130:	91000509 	add	x9, x8, #0x1
  202134:	8b0b096d 	add	x13, x11, x11, lsl #2
  202138:	cb0d05cd 	sub	x13, x14, x13, lsl #1
      if (!(frac /= 10U)) {
  20213c:	aa0b03ee 	mov	x14, x11
      buf[len++] = (char)(48U + (frac % 10U));
  202140:	1100c1ab 	add	w11, w13, #0x30
  202144:	3828698b 	strb	w11, [x12, x8]
      if (!(frac /= 10U)) {
  202148:	54000349 	b.ls	2021b0 <_ftoa+0x330>  // b.plast
      --count;
  20214c:	2a0003e4 	mov	w4, w0
      buf[len++] = (char)(48U + (frac % 10U));
  202150:	aa0903e8 	mov	x8, x9
  202154:	9bc27dcb 	umulh	x11, x14, x2
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
  202158:	6b01009f 	cmp	w4, w1
  20215c:	54fffe41 	b.ne	202124 <_ftoa+0x2a4>  // b.any
      buf[len++] = (char)(48U + (frac % 10U));
  202160:	d2800408 	mov	x8, #0x20                  	// #32
  202164:	17ffff8b 	b	201f90 <_ftoa+0x110>
    ++frac;
  202168:	910005ce 	add	x14, x14, #0x1
    if (frac >= pow10[prec]) {
  20216c:	9e6301c1 	ucvtf	d1, x14
  202170:	1e622030 	fcmpe	d1, d2
  202174:	5400004a 	b.ge	20217c <_ftoa+0x2fc>  // b.tcont
  202178:	17ffff7e 	b	201f70 <_ftoa+0xf0>
      ++whole;
  20217c:	1100054a 	add	w10, w10, #0x1
      frac = 0;
  202180:	d280000e 	mov	x14, #0x0                   	// #0
  202184:	17ffff7b 	b	201f70 <_ftoa+0xf0>
  if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
  202188:	120004e0 	and	w0, w7, #0x3
  20218c:	7100041f 	cmp	w0, #0x1
  202190:	54000700 	b.eq	202270 <_ftoa+0x3f0>  // b.none
  if (len < PRINTF_FTOA_BUFFER_SIZE) {
  202194:	f100811f 	cmp	x8, #0x20
  202198:	54fff480 	b.eq	202028 <_ftoa+0x1a8>  // b.none
    if (negative) {
  20219c:	34000323 	cbz	w3, 202200 <_ftoa+0x380>
      buf[len++] = '-';
  2021a0:	528005a0 	mov	w0, #0x2d                  	// #45
  2021a4:	38286980 	strb	w0, [x12, x8]
  2021a8:	91000508 	add	x8, x8, #0x1
  2021ac:	17ffff9f 	b	202028 <_ftoa+0x1a8>
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
  2021b0:	f100813f 	cmp	x9, #0x20
  2021b4:	54fffd60 	b.eq	202160 <_ftoa+0x2e0>  // b.none
  2021b8:	91000908 	add	x8, x8, #0x2
  2021bc:	51000884 	sub	w4, w4, #0x2
  2021c0:	8b040108 	add	x8, x8, x4
      buf[len++] = '0';
  2021c4:	52800601 	mov	w1, #0x30                  	// #48
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
  2021c8:	35000080 	cbnz	w0, 2021d8 <_ftoa+0x358>
  2021cc:	14000013 	b	202218 <_ftoa+0x398>
  2021d0:	eb08013f 	cmp	x9, x8
  2021d4:	54000220 	b.eq	202218 <_ftoa+0x398>  // b.none
      buf[len++] = '0';
  2021d8:	91000529 	add	x9, x9, #0x1
  2021dc:	8b090180 	add	x0, x12, x9
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
  2021e0:	f100813f 	cmp	x9, #0x20
      buf[len++] = '0';
  2021e4:	381ff001 	sturb	w1, [x0, #-1]
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
  2021e8:	54ffff41 	b.ne	2021d0 <_ftoa+0x350>  // b.any
      buf[len++] = (char)(48U + (frac % 10U));
  2021ec:	d2800408 	mov	x8, #0x20                  	// #32
  2021f0:	17ffff68 	b	201f90 <_ftoa+0x110>
  if (len < PRINTF_FTOA_BUFFER_SIZE) {
  2021f4:	f100811f 	cmp	x8, #0x20
  2021f8:	54fff180 	b.eq	202028 <_ftoa+0x1a8>  // b.none
  2021fc:	d503201f 	nop
    else if (flags & FLAGS_PLUS) {
  202200:	37100147 	tbnz	w7, #2, 202228 <_ftoa+0x3a8>
    else if (flags & FLAGS_SPACE) {
  202204:	361ff127 	tbz	w7, #3, 202028 <_ftoa+0x1a8>
      buf[len++] = ' ';
  202208:	52800400 	mov	w0, #0x20                  	// #32
  20220c:	38286980 	strb	w0, [x12, x8]
  202210:	91000508 	add	x8, x8, #0x1
  202214:	17ffff85 	b	202028 <_ftoa+0x1a8>
      buf[len++] = '.';
  202218:	528005c0 	mov	w0, #0x2e                  	// #46
  20221c:	91000528 	add	x8, x9, #0x1
  202220:	38296980 	strb	w0, [x12, x9]
  202224:	17ffff5b 	b	201f90 <_ftoa+0x110>
      buf[len++] = '+';  // ignore the space if the '+' exists
  202228:	52800560 	mov	w0, #0x2b                  	// #43
  20222c:	38286980 	strb	w0, [x12, x8]
  202230:	91000508 	add	x8, x8, #0x1
  202234:	17ffff7d 	b	202028 <_ftoa+0x1a8>
  else if ((frac == 0U) || (frac & 1U)) {
  202238:	3607e9ce 	tbz	w14, #0, 201f70 <_ftoa+0xf0>
    ++frac;
  20223c:	910005ce 	add	x14, x14, #0x1
  202240:	17ffff4c 	b	201f70 <_ftoa+0xf0>
      width--;
  202244:	510004a2 	sub	w2, w5, #0x1
  202248:	aa0203e5 	mov	x5, x2
    while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
  20224c:	eb08005f 	cmp	x2, x8
  202250:	54ffed48 	b.hi	201ff8 <_ftoa+0x178>  // b.pmore
  202254:	17ffffd0 	b	202194 <_ftoa+0x314>
  double tmp = (value - whole) * pow10[prec];
  202258:	b0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  20225c:	911dc000 	add	x0, x0, #0x770
  202260:	910043ec 	add	x12, sp, #0x10
  202264:	d2800008 	mov	x8, #0x0                   	// #0
  202268:	fc645802 	ldr	d2, [x0, w4, uxtw #3]
  20226c:	17ffff33 	b	201f38 <_ftoa+0xb8>
    if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
  202270:	34fff925 	cbz	w5, 202194 <_ftoa+0x314>
  202274:	17ffff5b 	b	201fe0 <_ftoa+0x160>
  202278:	d503201f 	nop
  20227c:	d503201f 	nop

0000000000202280 <_etoa>:


#if defined(PRINTF_SUPPORT_EXPONENTIAL)
// internal ftoa variant for exponential floating-point type, contributed by Martijn Jasperse <m.jasperse@gmail.com>
static size_t _etoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags)
{
  202280:	d10203ff 	sub	sp, sp, #0x80
  // check for NaN and special values
  if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {
  202284:	1e602000 	fcmp	d0, d0
{
  202288:	a9017bfd 	stp	x29, x30, [sp, #16]
  20228c:	910043fd 	add	x29, sp, #0x10
  202290:	a90253f3 	stp	x19, x20, [sp, #32]
  202294:	aa0203f3 	mov	x19, x2
  202298:	2a0603f4 	mov	w20, w6
  20229c:	a9035bf5 	stp	x21, x22, [sp, #48]
  2022a0:	aa0003f6 	mov	x22, x0
  2022a4:	a90463f7 	stp	x23, x24, [sp, #64]
  2022a8:	aa0103f7 	mov	x23, x1
  2022ac:	aa0303f8 	mov	x24, x3
  2022b0:	a90673fb 	stp	x27, x28, [sp, #96]
  2022b4:	2a0503fb 	mov	w27, w5
  if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {
  2022b8:	54001301 	b.ne	202518 <_etoa+0x298>  // b.any
  2022bc:	92f00200 	mov	x0, #0x7fefffffffffffff    	// #9218868437227405311
  2022c0:	9e670001 	fmov	d1, x0
  2022c4:	1e612010 	fcmpe	d0, d1
  2022c8:	5400128c 	b.gt	202518 <_etoa+0x298>
  2022cc:	92e00200 	mov	x0, #0xffefffffffffffff    	// #-4503599627370497
  2022d0:	9e670001 	fmov	d1, x0
  2022d4:	1e612010 	fcmpe	d0, d1
  2022d8:	54001204 	b.mi	202518 <_etoa+0x298>  // b.first
    return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);
  }

  // determine the sign
  const bool negative = value < 0;
  if (negative) {
  2022dc:	1e602018 	fcmpe	d0, #0.0
  2022e0:	1e614002 	fneg	d2, d0

  conv.F = value;
  int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;           // effectively log2
  conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
  // now approximate log10 from the log2 integer part and an expansion of ln around 1.5
  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
  2022e4:	b0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  2022e8:	fd475016 	ldr	d22, [x0, #3744]
  2022ec:	b0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  2022f0:	fd475401 	ldr	d1, [x0, #3752]
  2022f4:	b0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  2022f8:	fd475815 	ldr	d21, [x0, #3760]
  2022fc:	1e604c42 	fcsel	d2, d2, d0, mi	// mi = first
  // now we want to compute 10^expval but we want to be sure it won't overflow
  exp2 = (int)(expval * 3.321928094887362 + 0.5);
  202300:	b0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  202304:	fd475c14 	ldr	d20, [x0, #3768]
  const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
  202308:	b0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  20230c:	fd476013 	ldr	d19, [x0, #3776]
  202310:	b0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  202314:	fd476412 	ldr	d18, [x0, #3784]
  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
  202318:	1e6f1018 	fmov	d24, #1.500000000000000000e+00
  conv.F = value;
  20231c:	9e660040 	fmov	x0, d2
  202320:	a9056bf9 	stp	x25, x26, [sp, #80]
  exp2 = (int)(expval * 3.321928094887362 + 0.5);
  202324:	1e6c1005 	fmov	d5, #5.000000000000000000e-01
  const double z2 = z * z;
  conv.U = (uint64_t)(exp2 + 1023) << 52U;
  // compute exp(z) using continued fractions, see https://en.wikipedia.org/wiki/Exponential_function#Continued_fractions_for_ex
  conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
  202328:	1e659003 	fmov	d3, #1.400000000000000000e+01
  20232c:	1e649007 	fmov	d7, #1.000000000000000000e+01
  202330:	1e631011 	fmov	d17, #6.000000000000000000e+00
  202334:	1e601006 	fmov	d6, #2.000000000000000000e+00
  conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
  202338:	9240cc01 	and	x1, x0, #0xfffffffffffff
  int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;           // effectively log2
  20233c:	d374f800 	ubfx	x0, x0, #52, #11
  202340:	510ffc00 	sub	w0, w0, #0x3ff
  conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
  202344:	b24c2421 	orr	x1, x1, #0x3ff0000000000000
  202348:	9e670024 	fmov	d4, x1
  conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
  20234c:	1e6e1010 	fmov	d16, #1.000000000000000000e+00
  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
  202350:	1e620017 	scvtf	d23, w0
    prec = PRINTF_DEFAULT_FLOAT_PRECISION;
  202354:	721600c3 	ands	w3, w6, #0x400
  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
  202358:	1e783884 	fsub	d4, d4, d24
    prec = PRINTF_DEFAULT_FLOAT_PRECISION;
  20235c:	528000c2 	mov	w2, #0x6                   	// #6
  202360:	1a821084 	csel	w4, w4, w2, ne	// ne = any
  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
  202364:	1f5606e1 	fmadd	d1, d23, d22, d1
  202368:	1f550481 	fmadd	d1, d4, d21, d1
  20236c:	1e780039 	fcvtzs	w25, d1
  exp2 = (int)(expval * 3.321928094887362 + 0.5);
  202370:	1e620324 	scvtf	d4, w25
  202374:	1f541481 	fmadd	d1, d4, d20, d5
  202378:	1e780020 	fcvtzs	w0, d1
  const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
  20237c:	1e620001 	scvtf	d1, w0
  conv.U = (uint64_t)(exp2 + 1023) << 52U;
  202380:	110ffc00 	add	w0, w0, #0x3ff
  202384:	9e670005 	fmov	d5, x0
  202388:	5f7454a5 	shl	d5, d5, #52
  const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
  20238c:	1e730821 	fmul	d1, d1, d19
  202390:	1f728481 	fnmsub	d1, d4, d18, d1
  const double z2 = z * z;
  202394:	1e610824 	fmul	d4, d1, d1
  conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
  202398:	1e6138c6 	fsub	d6, d6, d1
  20239c:	1e612821 	fadd	d1, d1, d1
  2023a0:	1e631883 	fdiv	d3, d4, d3
  2023a4:	1e672863 	fadd	d3, d3, d7
  2023a8:	1e631883 	fdiv	d3, d4, d3
  2023ac:	1e712863 	fadd	d3, d3, d17
  2023b0:	1e631884 	fdiv	d4, d4, d3
  2023b4:	1e662884 	fadd	d4, d4, d6
  2023b8:	1e641821 	fdiv	d1, d1, d4
  2023bc:	1e702821 	fadd	d1, d1, d16
  2023c0:	1e650821 	fmul	d1, d1, d5
  // correct for rounding errors
  if (value < conv.F) {
  2023c4:	1e612050 	fcmpe	d2, d1
  2023c8:	54000c24 	b.mi	20254c <_etoa+0x2cc>  // b.first
    expval--;
    conv.F /= 10;
  }

  // the exponent format is "%+03d" and largest value is "307", so set aside 4-5 characters
  unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
  2023cc:	11018f20 	add	w0, w25, #0x63
  2023d0:	7103181f 	cmp	w0, #0xc6
  2023d4:	1a9f97fc 	cset	w28, hi	// hi = pmore
  2023d8:	1100139c 	add	w28, w28, #0x4

  // in "%g" mode, "prec" is the number of *significant figures* not decimals
  if (flags & FLAGS_ADAPT_EXP) {
  2023dc:	36580134 	tbz	w20, #11, 202400 <_etoa+0x180>
    // do we want to fall-back to "%f" mode?
    if ((value >= 1e-4) && (value < 1e6)) {
  2023e0:	b0000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  2023e4:	fd476803 	ldr	d3, [x0, #3792]
  2023e8:	1e632050 	fcmpe	d2, d3
  2023ec:	54000d2a 	b.ge	202590 <_etoa+0x310>  // b.tcont
      minwidth = 0U;
      expval   = 0;
    }
    else {
      // we use one sigfig for the whole part
      if ((prec > 0) && (flags & FLAGS_PRECISION)) {
  2023f0:	34000084 	cbz	w4, 202400 <_etoa+0x180>
        --prec;
  2023f4:	7100007f 	cmp	w3, #0x0
  2023f8:	1a9f07e0 	cset	w0, ne	// ne = any
  2023fc:	4b000084 	sub	w4, w4, w0

  // will everything fit?
  unsigned int fwidth = width;
  if (width > minwidth) {
    // we didn't fall-back so subtract the characters required for the exponent
    fwidth -= minwidth;
  202400:	6b1c0365 	subs	w5, w27, w28
  } else {
    // not enough characters, so go back to default sizing
    fwidth = 0U;
  }
  if ((flags & FLAGS_LEFT) && minwidth) {
  202404:	121f0280 	and	w0, w20, #0x2
    fwidth -= minwidth;
  202408:	1a9f80a5 	csel	w5, w5, wzr, hi	// hi = pmore
  if ((flags & FLAGS_LEFT) && minwidth) {
  20240c:	7100001f 	cmp	w0, #0x0
  202410:	1a9f07e0 	cset	w0, ne	// ne = any
  202414:	b9007fe0 	str	w0, [sp, #124]
  202418:	1a9f00a5 	csel	w5, w5, wzr, eq	// eq = none
    // if we're padding on the right, DON'T pad the floating part
    fwidth = 0U;
  }

  // rescale the float value
  if (expval) {
  20241c:	5280003a 	mov	w26, #0x1                   	// #1
  202420:	34000059 	cbz	w25, 202428 <_etoa+0x1a8>
    value /= conv.F;
  202424:	1e611842 	fdiv	d2, d2, d1
  }

  // output the floating part
  const size_t start_idx = idx;
  idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
  202428:	1e602018 	fcmpe	d0, #0.0
  20242c:	54000ae4 	b.mi	202588 <_etoa+0x308>  // b.first
  202430:	1e604040 	fmov	d0, d2
  202434:	12147a86 	and	w6, w20, #0xfffff7ff
  202438:	aa1803e3 	mov	x3, x24
  20243c:	aa1303e2 	mov	x2, x19
  202440:	aa1703e1 	mov	x1, x23
  202444:	aa1603e0 	mov	x0, x22
  202448:	97fffe8e 	bl	201e80 <_ftoa>
  20244c:	aa0003f5 	mov	x21, x0

  // output the exponent part
  if (minwidth) {
  202450:	3400053a 	cbz	w26, 2024f4 <_etoa+0x274>
    // output the exponential symbol
    out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);
  202454:	721b0294 	ands	w20, w20, #0x20
  202458:	52800ca1 	mov	w1, #0x65                  	// #101
  20245c:	aa1503e2 	mov	x2, x21
  202460:	aa1803e3 	mov	x3, x24
  202464:	528008a0 	mov	w0, #0x45                  	// #69
  202468:	1a800020 	csel	w0, w1, w0, eq	// eq = none
  20246c:	aa1703e1 	mov	x1, x23
  202470:	d63f02c0 	blr	x22
    // output the exponent value
    idx = _ntoa_long(out, buffer, idx, maxlen, (expval < 0) ? -expval : expval, expval < 0, 10, 0, minwidth-1, FLAGS_ZEROPAD | FLAGS_PLUS);
  202474:	7100033f 	cmp	w25, #0x0
  202478:	528000a0 	mov	w0, #0x5                   	// #5
  20247c:	5a99a724 	cneg	w4, w25, lt	// lt = tstop
  202480:	5100079c 	sub	w28, w28, #0x1
  202484:	b90003fc 	str	w28, [sp]
    out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);
  202488:	910006b4 	add	x20, x21, #0x1
    idx = _ntoa_long(out, buffer, idx, maxlen, (expval < 0) ? -expval : expval, expval < 0, 10, 0, minwidth-1, FLAGS_ZEROPAD | FLAGS_PLUS);
  20248c:	b9000be0 	str	w0, [sp, #8]
  202490:	aa1403e2 	mov	x2, x20
  202494:	93407c84 	sxtw	x4, w4
  202498:	531f7f25 	lsr	w5, w25, #31
  20249c:	aa1803e3 	mov	x3, x24
  2024a0:	aa1703e1 	mov	x1, x23
  2024a4:	aa1603e0 	mov	x0, x22
  2024a8:	52800007 	mov	w7, #0x0                   	// #0
  2024ac:	d2800146 	mov	x6, #0xa                   	// #10
  2024b0:	97fffd84 	bl	201ac0 <_ntoa_long>
  2024b4:	aa0003f5 	mov	x21, x0
    // might need to right-pad spaces
    if (flags & FLAGS_LEFT) {
  2024b8:	b9407fe0 	ldr	w0, [sp, #124]
  2024bc:	340001c0 	cbz	w0, 2024f4 <_etoa+0x274>
      while (idx - start_idx < width) out(' ', buffer, idx++, maxlen);
  2024c0:	cb1302b3 	sub	x19, x21, x19
  2024c4:	eb1b027f 	cmp	x19, x27
  2024c8:	54000162 	b.cs	2024f4 <_etoa+0x274>  // b.hs, b.nlast
  2024cc:	d503201f 	nop
  2024d0:	aa1503e2 	mov	x2, x21
  2024d4:	aa1803e3 	mov	x3, x24
  2024d8:	aa1703e1 	mov	x1, x23
  2024dc:	91000673 	add	x19, x19, #0x1
  2024e0:	52800400 	mov	w0, #0x20                  	// #32
  2024e4:	d63f02c0 	blr	x22
  2024e8:	910006b5 	add	x21, x21, #0x1
  2024ec:	eb13037f 	cmp	x27, x19
  2024f0:	54ffff08 	b.hi	2024d0 <_etoa+0x250>  // b.pmore
    }
  }
  return idx;
}
  2024f4:	a9417bfd 	ldp	x29, x30, [sp, #16]
  2024f8:	aa1503e0 	mov	x0, x21
  2024fc:	a94253f3 	ldp	x19, x20, [sp, #32]
  202500:	a9435bf5 	ldp	x21, x22, [sp, #48]
  202504:	a94463f7 	ldp	x23, x24, [sp, #64]
  202508:	a9456bf9 	ldp	x25, x26, [sp, #80]
  20250c:	a94673fb 	ldp	x27, x28, [sp, #96]
  202510:	910203ff 	add	sp, sp, #0x80
  202514:	d65f03c0 	ret
    return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);
  202518:	2a1403e6 	mov	w6, w20
  20251c:	2a1b03e5 	mov	w5, w27
  202520:	aa1803e3 	mov	x3, x24
  202524:	aa1303e2 	mov	x2, x19
  202528:	aa1703e1 	mov	x1, x23
  20252c:	aa1603e0 	mov	x0, x22
}
  202530:	a9417bfd 	ldp	x29, x30, [sp, #16]
  202534:	a94253f3 	ldp	x19, x20, [sp, #32]
  202538:	a9435bf5 	ldp	x21, x22, [sp, #48]
  20253c:	a94463f7 	ldp	x23, x24, [sp, #64]
  202540:	a94673fb 	ldp	x27, x28, [sp, #96]
  202544:	910203ff 	add	sp, sp, #0x80
  idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
  202548:	17fffe4e 	b	201e80 <_ftoa>
    conv.F /= 10;
  20254c:	1e671821 	fdiv	d1, d1, d7
    expval--;
  202550:	51000739 	sub	w25, w25, #0x1
  unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
  202554:	11018f20 	add	w0, w25, #0x63
  202558:	7103181f 	cmp	w0, #0xc6
  20255c:	1a9f97fc 	cset	w28, hi	// hi = pmore
  202560:	1100139c 	add	w28, w28, #0x4
  if (flags & FLAGS_ADAPT_EXP) {
  202564:	365ff4f4 	tbz	w20, #11, 202400 <_etoa+0x180>
  202568:	17ffff9e 	b	2023e0 <_etoa+0x160>
      flags |= FLAGS_PRECISION;   // make sure _ftoa respects precision
  20256c:	2a0103f4 	mov	w20, w1
    fwidth = 0U;
  202570:	52800005 	mov	w5, #0x0                   	// #0
      minwidth = 0U;
  202574:	5280001c 	mov	w28, #0x0                   	// #0
      expval   = 0;
  202578:	52800019 	mov	w25, #0x0                   	// #0
  if ((flags & FLAGS_LEFT) && minwidth) {
  20257c:	5280001a 	mov	w26, #0x0                   	// #0
  202580:	b9007fff 	str	wzr, [sp, #124]
  202584:	d503201f 	nop
  idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
  202588:	1e614042 	fneg	d2, d2
  20258c:	17ffffa9 	b	202430 <_etoa+0x1b0>
    if ((value >= 1e-4) && (value < 1e6)) {
  202590:	d2d09000 	mov	x0, #0x848000000000        	// #145685290680320
  202594:	f2e825c0 	movk	x0, #0x412e, lsl #48
  202598:	9e670003 	fmov	d3, x0
  20259c:	1e632050 	fcmpe	d2, d3
  2025a0:	54000044 	b.mi	2025a8 <_etoa+0x328>  // b.first
  2025a4:	17ffff93 	b	2023f0 <_etoa+0x170>
        prec = (unsigned)((int)prec - expval - 1);
  2025a8:	4b190080 	sub	w0, w4, w25
  2025ac:	6b04033f 	cmp	w25, w4
  2025b0:	51000400 	sub	w0, w0, #0x1
      flags |= FLAGS_PRECISION;   // make sure _ftoa respects precision
  2025b4:	32160281 	orr	w1, w20, #0x400
        prec = (unsigned)((int)prec - expval - 1);
  2025b8:	1a9fb004 	csel	w4, w0, wzr, lt	// lt = tstop
  if (width > minwidth) {
  2025bc:	350001bb 	cbnz	w27, 2025f0 <_etoa+0x370>
  idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
  2025c0:	1e602018 	fcmpe	d0, #0.0
  2025c4:	54fffd44 	b.mi	20256c <_etoa+0x2ec>  // b.first
  2025c8:	12147a86 	and	w6, w20, #0xfffff7ff
  2025cc:	1e604040 	fmov	d0, d2
  2025d0:	a9456bf9 	ldp	x25, x26, [sp, #80]
  2025d4:	321600c6 	orr	w6, w6, #0x400
  2025d8:	aa1803e3 	mov	x3, x24
  2025dc:	aa1303e2 	mov	x2, x19
  2025e0:	aa1703e1 	mov	x1, x23
  2025e4:	aa1603e0 	mov	x0, x22
  2025e8:	52800005 	mov	w5, #0x0                   	// #0
  2025ec:	17ffffd1 	b	202530 <_etoa+0x2b0>
      flags |= FLAGS_PRECISION;   // make sure _ftoa respects precision
  2025f0:	2a0103f4 	mov	w20, w1
    fwidth -= minwidth;
  2025f4:	2a1b03e5 	mov	w5, w27
  if (width > minwidth) {
  2025f8:	5280001a 	mov	w26, #0x0                   	// #0
  2025fc:	52800019 	mov	w25, #0x0                   	// #0
      minwidth = 0U;
  202600:	5280001c 	mov	w28, #0x0                   	// #0
  if (width > minwidth) {
  202604:	b9007fff 	str	wzr, [sp, #124]
  202608:	17ffff88 	b	202428 <_etoa+0x1a8>
  20260c:	d503201f 	nop

0000000000202610 <_vsnprintf>:
#endif  // PRINTF_SUPPORT_FLOAT


// internal vsnprintf
static int _vsnprintf(out_fct_type out, char* buffer, const size_t maxlen, const char* format, va_list va)
{
  202610:	d102c3ff 	sub	sp, sp, #0xb0
  unsigned int flags, width, precision, n;
  size_t idx = 0U;

  if (!buffer) {
    // use null output function
    out = _out_null;
  202614:	f100003f 	cmp	x1, #0x0
{
  202618:	a9017bfd 	stp	x29, x30, [sp, #16]
  20261c:	910043fd 	add	x29, sp, #0x10
  202620:	a90253f3 	stp	x19, x20, [sp, #32]
    out = _out_null;
  202624:	f0fffff3 	adrp	x19, 201000 <notified+0x100>
  202628:	91264273 	add	x19, x19, #0x990
{
  20262c:	a9035bf5 	stp	x21, x22, [sp, #48]
    out = _out_null;
  202630:	9a800273 	csel	x19, x19, x0, eq	// eq = none
{
  202634:	aa0103f5 	mov	x21, x1
  202638:	a90463f7 	stp	x23, x24, [sp, #64]
  20263c:	aa0203f4 	mov	x20, x2
  202640:	a9056bf9 	stp	x25, x26, [sp, #80]
  202644:	b940189a 	ldr	w26, [x4, #24]
  202648:	a90673fb 	stp	x27, x28, [sp, #96]
  }

  while (*format)
  20264c:	d280001c 	mov	x28, #0x0                   	// #0
  202650:	f9400880 	ldr	x0, [x4, #16]
  202654:	f9004fe0 	str	x0, [sp, #152]
  202658:	39400061 	ldrb	w1, [x3]
  20265c:	a9400897 	ldp	x23, x2, [x4]
  202660:	f90047e2 	str	x2, [sp, #136]
  202664:	b9401c80 	ldr	w0, [x4, #28]
  202668:	b9007fe0 	str	w0, [sp, #124]
  20266c:	34004001 	cbz	w1, 202e6c <_vsnprintf+0x85c>
  202670:	aa0303fb 	mov	x27, x3
  202674:	52800158 	mov	w24, #0xa                   	// #10
  202678:	14000009 	b	20269c <_vsnprintf+0x8c>
        out('%', buffer, idx++, maxlen);
        format++;
        break;

      default :
        out(*format, buffer, idx++, maxlen);
  20267c:	91000796 	add	x22, x28, #0x1
  202680:	aa1c03e2 	mov	x2, x28
  202684:	aa1603fc 	mov	x28, x22
  202688:	aa1403e3 	mov	x3, x20
  20268c:	aa1503e1 	mov	x1, x21
  202690:	d63f0260 	blr	x19
  while (*format)
  202694:	39400361 	ldrb	w1, [x27]
  202698:	34001241 	cbz	w1, 2028e0 <_vsnprintf+0x2d0>
      format++;
  20269c:	9100077b 	add	x27, x27, #0x1
      out(*format, buffer, idx++, maxlen);
  2026a0:	2a0103e0 	mov	w0, w1
    if (*format != '%') {
  2026a4:	7100943f 	cmp	w1, #0x25
  2026a8:	54fffea1 	b.ne	20267c <_vsnprintf+0x6c>  // b.any
      switch (*format) {
  2026ac:	aa1b03e1 	mov	x1, x27
    flags = 0U;
  2026b0:	52800006 	mov	w6, #0x0                   	// #0
      switch (*format) {
  2026b4:	38401420 	ldrb	w0, [x1], #1
  2026b8:	7100ac1f 	cmp	w0, #0x2b
  2026bc:	54000180 	b.eq	2026ec <_vsnprintf+0xdc>  // b.none
  2026c0:	540001c8 	b.hi	2026f8 <_vsnprintf+0xe8>  // b.pmore
  2026c4:	7100801f 	cmp	w0, #0x20
  2026c8:	54000260 	b.eq	202714 <_vsnprintf+0x104>  // b.none
  2026cc:	71008c1f 	cmp	w0, #0x23
  2026d0:	54000981 	b.ne	202800 <_vsnprintf+0x1f0>  // b.any
        case '#': flags |= FLAGS_HASH;    format++; n = 1U; break;
  2026d4:	321c00c6 	orr	w6, w6, #0x10
  while (*format)
  2026d8:	aa0103fb 	mov	x27, x1
      switch (*format) {
  2026dc:	aa1b03e1 	mov	x1, x27
  2026e0:	38401420 	ldrb	w0, [x1], #1
  2026e4:	7100ac1f 	cmp	w0, #0x2b
  2026e8:	54fffec1 	b.ne	2026c0 <_vsnprintf+0xb0>  // b.any
        case '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;
  2026ec:	321e00c6 	orr	w6, w6, #0x4
  while (*format)
  2026f0:	aa0103fb 	mov	x27, x1
  2026f4:	17fffffa 	b	2026dc <_vsnprintf+0xcc>
      switch (*format) {
  2026f8:	7100b41f 	cmp	w0, #0x2d
  2026fc:	54000120 	b.eq	202720 <_vsnprintf+0x110>  // b.none
  202700:	7100c01f 	cmp	w0, #0x30
  202704:	54000141 	b.ne	20272c <_vsnprintf+0x11c>  // b.any
        case '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;
  202708:	320000c6 	orr	w6, w6, #0x1
  while (*format)
  20270c:	aa0103fb 	mov	x27, x1
  202710:	17fffff3 	b	2026dc <_vsnprintf+0xcc>
        case ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;
  202714:	321d00c6 	orr	w6, w6, #0x8
  while (*format)
  202718:	aa0103fb 	mov	x27, x1
  20271c:	17fffff0 	b	2026dc <_vsnprintf+0xcc>
        case '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;
  202720:	321f00c6 	orr	w6, w6, #0x2
  while (*format)
  202724:	aa0103fb 	mov	x27, x1
  202728:	17ffffed 	b	2026dc <_vsnprintf+0xcc>
  return (ch >= '0') && (ch <= '9');
  20272c:	5100c002 	sub	w2, w0, #0x30
  unsigned int i = 0U;
  202730:	52800019 	mov	w25, #0x0                   	// #0
    if (_is_digit(*format)) {
  202734:	12001c42 	and	w2, w2, #0xff
  202738:	7100245f 	cmp	w2, #0x9
  20273c:	54000148 	b.hi	202764 <_vsnprintf+0x154>  // b.pmore
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
  202740:	1b180325 	madd	w5, w25, w24, w0
  while (_is_digit(**str)) {
  202744:	39400020 	ldrb	w0, [x1]
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
  202748:	aa0103fb 	mov	x27, x1
  20274c:	91000421 	add	x1, x1, #0x1
  return (ch >= '0') && (ch <= '9');
  202750:	5100c002 	sub	w2, w0, #0x30
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
  202754:	5100c0b9 	sub	w25, w5, #0x30
  while (_is_digit(**str)) {
  202758:	12001c42 	and	w2, w2, #0xff
  20275c:	7100245f 	cmp	w2, #0x9
  202760:	54ffff09 	b.ls	202740 <_vsnprintf+0x130>  // b.plast
    if (*format == '.') {
  202764:	7100b81f 	cmp	w0, #0x2e
    precision = 0U;
  202768:	52800016 	mov	w22, #0x0                   	// #0
    if (*format == '.') {
  20276c:	540001a1 	b.ne	2027a0 <_vsnprintf+0x190>  // b.any
      if (_is_digit(*format)) {
  202770:	39400760 	ldrb	w0, [x27, #1]
      flags |= FLAGS_PRECISION;
  202774:	321600c6 	orr	w6, w6, #0x400
      format++;
  202778:	aa0103e2 	mov	x2, x1
  return (ch >= '0') && (ch <= '9');
  20277c:	5100c003 	sub	w3, w0, #0x30
      if (_is_digit(*format)) {
  202780:	12001c63 	and	w3, w3, #0xff
  202784:	7100247f 	cmp	w3, #0x9
  202788:	54002709 	b.ls	202c68 <_vsnprintf+0x658>  // b.plast
      else if (*format == '*') {
  20278c:	7100a81f 	cmp	w0, #0x2a
  202790:	54002840 	b.eq	202c98 <_vsnprintf+0x688>  // b.none
      format++;
  202794:	aa0103fb 	mov	x27, x1
  202798:	91000421 	add	x1, x1, #0x1
  20279c:	d503201f 	nop
    switch (*format) {
  2027a0:	7101b01f 	cmp	w0, #0x6c
        format++;
  2027a4:	aa0103e2 	mov	x2, x1
    switch (*format) {
  2027a8:	54002060 	b.eq	202bb4 <_vsnprintf+0x5a4>  // b.none
  2027ac:	540004a8 	b.hi	202840 <_vsnprintf+0x230>  // b.pmore
  2027b0:	7101a01f 	cmp	w0, #0x68
  2027b4:	54001f60 	b.eq	202ba0 <_vsnprintf+0x590>  // b.none
  2027b8:	7101a81f 	cmp	w0, #0x6a
  2027bc:	54002841 	b.ne	202cc4 <_vsnprintf+0x6b4>  // b.any
        if (*format == 'l') {
  2027c0:	39400760 	ldrb	w0, [x27, #1]
        flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
  2027c4:	321800c6 	orr	w6, w6, #0x100
        format++;
  2027c8:	9100045b 	add	x27, x2, #0x1
    switch (*format) {
  2027cc:	71019c1f 	cmp	w0, #0x67
  2027d0:	54000428 	b.hi	202854 <_vsnprintf+0x244>  // b.pmore
  2027d4:	7100901f 	cmp	w0, #0x24
  2027d8:	54fff529 	b.ls	20267c <_vsnprintf+0x6c>  // b.plast
  2027dc:	51009401 	sub	w1, w0, #0x25
  2027e0:	7101083f 	cmp	w1, #0x42
  2027e4:	54fff4c8 	b.hi	20267c <_vsnprintf+0x6c>  // b.pmore
  2027e8:	b0000002 	adrp	x2, 203000 <_vsnprintf+0x9f0>
  2027ec:	911b8042 	add	x2, x2, #0x6e0
  2027f0:	78615842 	ldrh	w2, [x2, w1, uxtw #1]
  2027f4:	10000061 	adr	x1, 202800 <_vsnprintf+0x1f0>
  2027f8:	8b22a822 	add	x2, x1, w2, sxth #2
  2027fc:	d61f0040 	br	x2
    else if (*format == '*') {
  202800:	7100a81f 	cmp	w0, #0x2a
    width = 0U;
  202804:	52800019 	mov	w25, #0x0                   	// #0
    precision = 0U;
  202808:	52800016 	mov	w22, #0x0                   	// #0
    else if (*format == '*') {
  20280c:	54fffca1 	b.ne	2027a0 <_vsnprintf+0x190>  // b.any
      const int w = va_arg(va, int);
  202810:	37f810fa 	tbnz	w26, #31, 202a2c <_vsnprintf+0x41c>
  202814:	91002ee2 	add	x2, x23, #0xb
  202818:	aa1703e0 	mov	x0, x23
  20281c:	927df057 	and	x23, x2, #0xfffffffffffffff8
  202820:	b9400019 	ldr	w25, [x0]
      if (w < 0) {
  202824:	36f80079 	tbz	w25, #31, 202830 <_vsnprintf+0x220>
        flags |= FLAGS_LEFT;    // reverse padding
  202828:	321f00c6 	orr	w6, w6, #0x2
        width = (unsigned int)-w;
  20282c:	4b1903f9 	neg	w25, w25
    if (*format == '.') {
  202830:	39400760 	ldrb	w0, [x27, #1]
      format++;
  202834:	aa0103fb 	mov	x27, x1
  202838:	91000421 	add	x1, x1, #0x1
  20283c:	17ffffca 	b	202764 <_vsnprintf+0x154>
    switch (*format) {
  202840:	7101d01f 	cmp	w0, #0x74
  202844:	54fffbe0 	b.eq	2027c0 <_vsnprintf+0x1b0>  // b.none
  202848:	7101e81f 	cmp	w0, #0x7a
  20284c:	54fffba0 	b.eq	2027c0 <_vsnprintf+0x1b0>  // b.none
        format++;
  202850:	aa0103fb 	mov	x27, x1
    switch (*format) {
  202854:	5101a401 	sub	w1, w0, #0x69
  202858:	12001c21 	and	w1, w1, #0xff
  20285c:	71003c3f 	cmp	w1, #0xf
  202860:	54fff0e8 	b.hi	20267c <_vsnprintf+0x6c>  // b.pmore
  202864:	d2800022 	mov	x2, #0x1                   	// #1
  202868:	d2920823 	mov	x3, #0x9041                	// #36929
  20286c:	9ac12042 	lsl	x2, x2, x1
  202870:	ea03005f 	tst	x2, x3
  202874:	54001ae1 	b.ne	202bd0 <_vsnprintf+0x5c0>  // b.any
  202878:	7100283f 	cmp	w1, #0xa
  20287c:	54000540 	b.eq	202924 <_vsnprintf+0x314>  // b.none
  202880:	71001c3f 	cmp	w1, #0x7
  202884:	54ffefc1 	b.ne	20267c <_vsnprintf+0x6c>  // b.any
        flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
  202888:	52800420 	mov	w0, #0x21                  	// #33
  20288c:	2a0000c0 	orr	w0, w6, w0
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
  202890:	37f8253a 	tbnz	w26, #31, 202d34 <_vsnprintf+0x724>
  202894:	91003ee2 	add	x2, x23, #0xf
  202898:	aa1703e1 	mov	x1, x23
  20289c:	927df057 	and	x23, x2, #0xfffffffffffffff8
  2028a0:	2a1603e7 	mov	w7, w22
  2028a4:	aa1c03e2 	mov	x2, x28
  2028a8:	f9400024 	ldr	x4, [x1]
  2028ac:	d2800206 	mov	x6, #0x10                  	// #16
  2028b0:	52800201 	mov	w1, #0x10                  	// #16
  2028b4:	b90003e1 	str	w1, [sp]
  2028b8:	b9000be0 	str	w0, [sp, #8]
  2028bc:	52800005 	mov	w5, #0x0                   	// #0
  2028c0:	aa1503e1 	mov	x1, x21
  2028c4:	aa1403e3 	mov	x3, x20
  2028c8:	aa1303e0 	mov	x0, x19
  2028cc:	97fffc7d 	bl	201ac0 <_ntoa_long>
  while (*format)
  2028d0:	39400361 	ldrb	w1, [x27]
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
  2028d4:	aa0003fc 	mov	x28, x0
  while (*format)
  2028d8:	35ffee21 	cbnz	w1, 20269c <_vsnprintf+0x8c>
  2028dc:	d503201f 	nop

  // termination
  out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);

  // return written chars without terminating \0
  return (int)idx;
  2028e0:	2a1c03f6 	mov	w22, w28
  out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
  2028e4:	eb1c029f 	cmp	x20, x28
  2028e8:	d1000682 	sub	x2, x20, #0x1
  2028ec:	aa1503e1 	mov	x1, x21
  2028f0:	9a9c9042 	csel	x2, x2, x28, ls	// ls = plast
  2028f4:	aa1403e3 	mov	x3, x20
  2028f8:	52800000 	mov	w0, #0x0                   	// #0
  2028fc:	d63f0260 	blr	x19
}
  202900:	a9417bfd 	ldp	x29, x30, [sp, #16]
  202904:	2a1603e0 	mov	w0, w22
  202908:	a94253f3 	ldp	x19, x20, [sp, #32]
  20290c:	a9435bf5 	ldp	x21, x22, [sp, #48]
  202910:	a94463f7 	ldp	x23, x24, [sp, #64]
  202914:	a9456bf9 	ldp	x25, x26, [sp, #80]
  202918:	a94673fb 	ldp	x27, x28, [sp, #96]
  20291c:	9102c3ff 	add	sp, sp, #0xb0
  202920:	d65f03c0 	ret
        const char* p = va_arg(va, char*);
  202924:	37f8219a 	tbnz	w26, #31, 202d54 <_vsnprintf+0x744>
  202928:	91003ee1 	add	x1, x23, #0xf
  20292c:	aa1703e0 	mov	x0, x23
  202930:	927df037 	and	x23, x1, #0xfffffffffffffff8
  202934:	f940000a 	ldr	x10, [x0]
        unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
  202938:	710002df 	cmp	w22, #0x0
  20293c:	2a1603e3 	mov	w3, w22
  202940:	da9f1063 	csinv	x3, x3, xzr, ne	// ne = any
  for (s = str; *s && maxsize--; ++s);
  202944:	aa0a03e1 	mov	x1, x10
  202948:	39400140 	ldrb	w0, [x10]
  20294c:	8b030143 	add	x3, x10, x3
  202950:	35000080 	cbnz	w0, 202960 <_vsnprintf+0x350>
  202954:	140001e4 	b	2030e4 <_vsnprintf+0xad4>
  202958:	eb03003f 	cmp	x1, x3
  20295c:	54000060 	b.eq	202968 <_vsnprintf+0x358>  // b.none
  202960:	38401c22 	ldrb	w2, [x1, #1]!
  202964:	35ffffa2 	cbnz	w2, 202958 <_vsnprintf+0x348>
  return (unsigned int)(s - str);
  202968:	4b0a0021 	sub	w1, w1, w10
  20296c:	b90093e1 	str	w1, [sp, #144]
        if (flags & FLAGS_PRECISION) {
  202970:	121600c1 	and	w1, w6, #0x400
  202974:	b900abe1 	str	w1, [sp, #168]
  202978:	365000a6 	tbz	w6, #10, 20298c <_vsnprintf+0x37c>
          l = (l < precision ? l : precision);
  20297c:	b94093e1 	ldr	w1, [sp, #144]
  202980:	6b16003f 	cmp	w1, w22
  202984:	1a969021 	csel	w1, w1, w22, ls	// ls = plast
  202988:	b90093e1 	str	w1, [sp, #144]
        if (!(flags & FLAGS_LEFT)) {
  20298c:	121f00c1 	and	w1, w6, #0x2
  202990:	b900afe1 	str	w1, [sp, #172]
  202994:	36082866 	tbz	w6, #1, 202ea0 <_vsnprintf+0x890>
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  202998:	34000280 	cbz	w0, 2029e8 <_vsnprintf+0x3d8>
  20299c:	b940abe1 	ldr	w1, [sp, #168]
  2029a0:	34002481 	cbz	w1, 202e30 <_vsnprintf+0x820>
  2029a4:	aa1c03e2 	mov	x2, x28
  2029a8:	8b36439c 	add	x28, x28, w22, uxtw
  2029ac:	cb020141 	sub	x1, x10, x2
  2029b0:	f90043e1 	str	x1, [sp, #128]
  2029b4:	14000009 	b	2029d8 <_vsnprintf+0x3c8>
          out(*(p++), buffer, idx++, maxlen);
  2029b8:	91000456 	add	x22, x2, #0x1
  2029bc:	aa1403e3 	mov	x3, x20
  2029c0:	aa1503e1 	mov	x1, x21
  2029c4:	d63f0260 	blr	x19
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  2029c8:	f94043e0 	ldr	x0, [sp, #128]
  2029cc:	38766800 	ldrb	w0, [x0, x22]
  2029d0:	34002420 	cbz	w0, 202e54 <_vsnprintf+0x844>
          out(*(p++), buffer, idx++, maxlen);
  2029d4:	aa1603e2 	mov	x2, x22
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  2029d8:	eb02039f 	cmp	x28, x2
  2029dc:	54fffee1 	b.ne	2029b8 <_vsnprintf+0x3a8>  // b.any
        if (flags & FLAGS_LEFT) {
  2029e0:	b940afe0 	ldr	w0, [sp, #172]
  2029e4:	34ffe580 	cbz	w0, 202694 <_vsnprintf+0x84>
          while (l++ < width) {
  2029e8:	b94093e1 	ldr	w1, [sp, #144]
  2029ec:	aa1c03f6 	mov	x22, x28
  2029f0:	6b19003f 	cmp	w1, w25
  2029f4:	54ffe502 	b.cs	202694 <_vsnprintf+0x84>  // b.hs, b.nlast
  2029f8:	51000720 	sub	w0, w25, #0x1
  2029fc:	91000789 	add	x9, x28, #0x1
  202a00:	4b010000 	sub	w0, w0, w1
  202a04:	8b09001c 	add	x28, x0, x9
            out(' ', buffer, idx++, maxlen);
  202a08:	aa1603e2 	mov	x2, x22
  202a0c:	aa1403e3 	mov	x3, x20
  202a10:	910006d6 	add	x22, x22, #0x1
  202a14:	aa1503e1 	mov	x1, x21
  202a18:	52800400 	mov	w0, #0x20                  	// #32
  202a1c:	d63f0260 	blr	x19
          while (l++ < width) {
  202a20:	eb1c02df 	cmp	x22, x28
  202a24:	54ffff21 	b.ne	202a08 <_vsnprintf+0x3f8>  // b.any
  202a28:	17ffff1b 	b	202694 <_vsnprintf+0x84>
      const int w = va_arg(va, int);
  202a2c:	11002342 	add	w2, w26, #0x8
  202a30:	7100005f 	cmp	w2, #0x0
  202a34:	54001a0d 	b.le	202d74 <_vsnprintf+0x764>
  202a38:	91002ee3 	add	x3, x23, #0xb
  202a3c:	aa1703e0 	mov	x0, x23
  202a40:	2a0203fa 	mov	w26, w2
  202a44:	927df077 	and	x23, x3, #0xfffffffffffffff8
  202a48:	17ffff76 	b	202820 <_vsnprintf+0x210>
        if ((*format == 'E')||(*format == 'G')) flags |= FLAGS_UPPERCASE;
  202a4c:	121e7802 	and	w2, w0, #0xfffffffd
        if ((*format == 'g')||(*format == 'G')) flags |= FLAGS_ADAPT_EXP;
  202a50:	121a7801 	and	w1, w0, #0xffffffdf
        if ((*format == 'E')||(*format == 'G')) flags |= FLAGS_UPPERCASE;
  202a54:	7101145f 	cmp	w2, #0x45
  202a58:	1a9f17e0 	cset	w0, eq	// eq = none
        if ((*format == 'g')||(*format == 'G')) flags |= FLAGS_ADAPT_EXP;
  202a5c:	71011c3f 	cmp	w1, #0x47
  202a60:	1a9f17e1 	cset	w1, eq	// eq = none
  202a64:	53155021 	lsl	w1, w1, #11
        if ((*format == 'E')||(*format == 'G')) flags |= FLAGS_UPPERCASE;
  202a68:	2a001420 	orr	w0, w1, w0, lsl #5
  202a6c:	2a060006 	orr	w6, w0, w6
        idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
  202a70:	b9407fe0 	ldr	w0, [sp, #124]
  202a74:	37f812c0 	tbnz	w0, #31, 202ccc <_vsnprintf+0x6bc>
  202a78:	91003ee1 	add	x1, x23, #0xf
  202a7c:	aa1703e0 	mov	x0, x23
  202a80:	927df037 	and	x23, x1, #0xfffffffffffffff8
  202a84:	fd400000 	ldr	d0, [x0]
  202a88:	aa1c03e2 	mov	x2, x28
  202a8c:	2a1903e5 	mov	w5, w25
  202a90:	2a1603e4 	mov	w4, w22
  202a94:	aa1403e3 	mov	x3, x20
  202a98:	aa1503e1 	mov	x1, x21
  202a9c:	aa1303e0 	mov	x0, x19
  202aa0:	97fffdf8 	bl	202280 <_etoa>
  202aa4:	aa0003fc 	mov	x28, x0
        break;
  202aa8:	17fffefb 	b	202694 <_vsnprintf+0x84>
        if (*format == 'F') flags |= FLAGS_UPPERCASE;
  202aac:	7101181f 	cmp	w0, #0x46
  202ab0:	321b00c0 	orr	w0, w6, #0x20
  202ab4:	1a860006 	csel	w6, w0, w6, eq	// eq = none
        idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
  202ab8:	b9407fe0 	ldr	w0, [sp, #124]
  202abc:	37f811a0 	tbnz	w0, #31, 202cf0 <_vsnprintf+0x6e0>
  202ac0:	91003ee1 	add	x1, x23, #0xf
  202ac4:	aa1703e0 	mov	x0, x23
  202ac8:	927df037 	and	x23, x1, #0xfffffffffffffff8
  202acc:	fd400000 	ldr	d0, [x0]
  202ad0:	aa1c03e2 	mov	x2, x28
  202ad4:	2a1903e5 	mov	w5, w25
  202ad8:	2a1603e4 	mov	w4, w22
  202adc:	aa1403e3 	mov	x3, x20
  202ae0:	aa1503e1 	mov	x1, x21
  202ae4:	aa1303e0 	mov	x0, x19
  202ae8:	97fffce6 	bl	201e80 <_ftoa>
  202aec:	aa0003fc 	mov	x28, x0
        break;
  202af0:	17fffee9 	b	202694 <_vsnprintf+0x84>
        unsigned int l = 1U;
  202af4:	52800020 	mov	w0, #0x1                   	// #1
  202af8:	b90083e0 	str	w0, [sp, #128]
        if (!(flags & FLAGS_LEFT)) {
  202afc:	121f00c0 	and	w0, w6, #0x2
  202b00:	b90093e0 	str	w0, [sp, #144]
  202b04:	36081406 	tbz	w6, #1, 202d84 <_vsnprintf+0x774>
        out((char)va_arg(va, int), buffer, idx++, maxlen);
  202b08:	37f8107a 	tbnz	w26, #31, 202d14 <_vsnprintf+0x704>
  202b0c:	91002ee1 	add	x1, x23, #0xb
  202b10:	aa1703e0 	mov	x0, x23
  202b14:	927df037 	and	x23, x1, #0xfffffffffffffff8
  202b18:	39400000 	ldrb	w0, [x0]
  202b1c:	aa1403e3 	mov	x3, x20
  202b20:	aa1c03e2 	mov	x2, x28
  202b24:	aa1503e1 	mov	x1, x21
  202b28:	91000796 	add	x22, x28, #0x1
  202b2c:	d63f0260 	blr	x19
        if (flags & FLAGS_LEFT) {
  202b30:	b94093e0 	ldr	w0, [sp, #144]
  202b34:	34000220 	cbz	w0, 202b78 <_vsnprintf+0x568>
          while (l++ < width) {
  202b38:	b94083e0 	ldr	w0, [sp, #128]
  202b3c:	6b19001f 	cmp	w0, w25
  202b40:	540001c2 	b.cs	202b78 <_vsnprintf+0x568>  // b.hs, b.nlast
  202b44:	51000725 	sub	w5, w25, #0x1
  202b48:	91000b89 	add	x9, x28, #0x2
  202b4c:	4b0000a0 	sub	w0, w5, w0
  202b50:	8b090019 	add	x25, x0, x9
  202b54:	d503201f 	nop
            out(' ', buffer, idx++, maxlen);
  202b58:	aa1603e2 	mov	x2, x22
  202b5c:	aa1403e3 	mov	x3, x20
  202b60:	910006d6 	add	x22, x22, #0x1
  202b64:	aa1503e1 	mov	x1, x21
  202b68:	52800400 	mov	w0, #0x20                  	// #32
  202b6c:	d63f0260 	blr	x19
          while (l++ < width) {
  202b70:	eb1902df 	cmp	x22, x25
  202b74:	54ffff21 	b.ne	202b58 <_vsnprintf+0x548>  // b.any
        out('%', buffer, idx++, maxlen);
  202b78:	aa1603fc 	mov	x28, x22
        break;
  202b7c:	17fffec6 	b	202694 <_vsnprintf+0x84>
        out('%', buffer, idx++, maxlen);
  202b80:	91000796 	add	x22, x28, #0x1
  202b84:	aa1c03e2 	mov	x2, x28
  202b88:	aa1403e3 	mov	x3, x20
  202b8c:	aa1503e1 	mov	x1, x21
  202b90:	528004a0 	mov	w0, #0x25                  	// #37
  202b94:	aa1603fc 	mov	x28, x22
  202b98:	d63f0260 	blr	x19
        break;
  202b9c:	17fffebe 	b	202694 <_vsnprintf+0x84>
        if (*format == 'h') {
  202ba0:	39400760 	ldrb	w0, [x27, #1]
  202ba4:	7101a01f 	cmp	w0, #0x68
  202ba8:	540015a0 	b.eq	202e5c <_vsnprintf+0x84c>  // b.none
        flags |= FLAGS_SHORT;
  202bac:	321900c6 	orr	w6, w6, #0x80
  202bb0:	17ffff06 	b	2027c8 <_vsnprintf+0x1b8>
        if (*format == 'l') {
  202bb4:	39400760 	ldrb	w0, [x27, #1]
  202bb8:	7101b01f 	cmp	w0, #0x6c
  202bbc:	54ffe041 	b.ne	2027c4 <_vsnprintf+0x1b4>  // b.any
    switch (*format) {
  202bc0:	39400b60 	ldrb	w0, [x27, #2]
          flags |= FLAGS_LONG_LONG;
  202bc4:	321804c6 	orr	w6, w6, #0x300
          format++;
  202bc8:	91000b62 	add	x2, x27, #0x2
  202bcc:	17fffeff 	b	2027c8 <_vsnprintf+0x1b8>
        if (*format == 'x' || *format == 'X') {
  202bd0:	7101bc1f 	cmp	w0, #0x6f
  202bd4:	54001020 	b.eq	202dd8 <_vsnprintf+0x7c8>  // b.none
  202bd8:	540019c8 	b.hi	202f10 <_vsnprintf+0x900>  // b.pmore
        if ((*format != 'i') && (*format != 'd')) {
  202bdc:	7101a41f 	cmp	w0, #0x69
          flags &= ~FLAGS_HASH;   // no hash for dec format
  202be0:	121b78c1 	and	w1, w6, #0xffffffef
        if ((*format != 'i') && (*format != 'd')) {
  202be4:	540038a1 	b.ne	2032f8 <_vsnprintf+0xce8>  // b.any
        if (flags & FLAGS_PRECISION) {
  202be8:	d2800142 	mov	x2, #0xa                   	// #10
  202bec:	36500046 	tbz	w6, #10, 202bf4 <_vsnprintf+0x5e4>
          flags &= ~FLAGS_ZEROPAD;
  202bf0:	121f7821 	and	w1, w1, #0xfffffffe
        if ((*format == 'i') || (*format == 'd')) {
  202bf4:	7101a41f 	cmp	w0, #0x69
  202bf8:	52800c83 	mov	w3, #0x64                  	// #100
  202bfc:	7a431004 	ccmp	w0, w3, #0x4, ne	// ne = any
  202c00:	54000f41 	b.ne	202de8 <_vsnprintf+0x7d8>  // b.any
          if (flags & FLAGS_LONG_LONG) {
  202c04:	37481c21 	tbnz	w1, #9, 202f88 <_vsnprintf+0x978>
          else if (flags & FLAGS_LONG) {
  202c08:	374021e1 	tbnz	w1, #8, 203044 <_vsnprintf+0xa34>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  202c0c:	37301961 	tbnz	w1, #6, 202f38 <_vsnprintf+0x928>
  202c10:	363826e1 	tbz	w1, #7, 2030ec <_vsnprintf+0xadc>
  202c14:	37f830da 	tbnz	w26, #31, 20322c <_vsnprintf+0xc1c>
  202c18:	91002ee3 	add	x3, x23, #0xb
  202c1c:	aa1703e0 	mov	x0, x23
  202c20:	927df077 	and	x23, x3, #0xfffffffffffffff8
  202c24:	79c00005 	ldrsh	w5, [x0]
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
  202c28:	710000bf 	cmp	w5, #0x0
  202c2c:	5a85a4a4 	cneg	w4, w5, lt	// lt = tstop
  202c30:	12003c84 	and	w4, w4, #0xffff
  202c34:	aa0203e6 	mov	x6, x2
  202c38:	2a1603e7 	mov	w7, w22
  202c3c:	531f7ca5 	lsr	w5, w5, #31
  202c40:	93407c84 	sxtw	x4, w4
  202c44:	aa1c03e2 	mov	x2, x28
  202c48:	b90003f9 	str	w25, [sp]
  202c4c:	b9000be1 	str	w1, [sp, #8]
            idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
  202c50:	aa1403e3 	mov	x3, x20
  202c54:	aa1503e1 	mov	x1, x21
  202c58:	aa1303e0 	mov	x0, x19
  202c5c:	97fffb99 	bl	201ac0 <_ntoa_long>
  202c60:	aa0003fc 	mov	x28, x0
        break;
  202c64:	17fffe8c 	b	202694 <_vsnprintf+0x84>
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
  202c68:	52800143 	mov	w3, #0xa                   	// #10
  202c6c:	d503201f 	nop
  202c70:	1b0302d6 	madd	w22, w22, w3, w0
  while (_is_digit(**str)) {
  202c74:	38401c40 	ldrb	w0, [x2, #1]!
  return (ch >= '0') && (ch <= '9');
  202c78:	5100c001 	sub	w1, w0, #0x30
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
  202c7c:	5100c2d6 	sub	w22, w22, #0x30
  while (_is_digit(**str)) {
  202c80:	12001c21 	and	w1, w1, #0xff
  202c84:	7100243f 	cmp	w1, #0x9
  202c88:	54ffff49 	b.ls	202c70 <_vsnprintf+0x660>  // b.plast
  202c8c:	aa0203fb 	mov	x27, x2
  202c90:	91000441 	add	x1, x2, #0x1
  202c94:	17fffec3 	b	2027a0 <_vsnprintf+0x190>
        const int prec = (int)va_arg(va, int);
  202c98:	37f80f5a 	tbnz	w26, #31, 202e80 <_vsnprintf+0x870>
  202c9c:	91002ee1 	add	x1, x23, #0xb
  202ca0:	aa1703e0 	mov	x0, x23
  202ca4:	927df037 	and	x23, x1, #0xfffffffffffffff8
        precision = prec > 0 ? (unsigned int)prec : 0U;
  202ca8:	b9400007 	ldr	w7, [x0]
        format++;
  202cac:	91000b7b 	add	x27, x27, #0x2
    switch (*format) {
  202cb0:	39400360 	ldrb	w0, [x27]
  202cb4:	91000761 	add	x1, x27, #0x1
        precision = prec > 0 ? (unsigned int)prec : 0U;
  202cb8:	710000ff 	cmp	w7, #0x0
  202cbc:	1a9fa0f6 	csel	w22, w7, wzr, ge	// ge = tcont
        format++;
  202cc0:	17fffeb8 	b	2027a0 <_vsnprintf+0x190>
    switch (*format) {
  202cc4:	aa1b03e2 	mov	x2, x27
  202cc8:	17fffec0 	b	2027c8 <_vsnprintf+0x1b8>
        idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
  202ccc:	b9407fe0 	ldr	w0, [sp, #124]
  202cd0:	11004001 	add	w1, w0, #0x10
  202cd4:	7100003f 	cmp	w1, #0x0
  202cd8:	54001a2d 	b.le	20301c <_vsnprintf+0xa0c>
  202cdc:	91003ee2 	add	x2, x23, #0xf
  202ce0:	aa1703e0 	mov	x0, x23
  202ce4:	927df057 	and	x23, x2, #0xfffffffffffffff8
  202ce8:	b9007fe1 	str	w1, [sp, #124]
  202cec:	17ffff66 	b	202a84 <_vsnprintf+0x474>
        idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
  202cf0:	b9407fe0 	ldr	w0, [sp, #124]
  202cf4:	11004001 	add	w1, w0, #0x10
  202cf8:	7100003f 	cmp	w1, #0x0
  202cfc:	540019ad 	b.le	203030 <_vsnprintf+0xa20>
  202d00:	91003ee2 	add	x2, x23, #0xf
  202d04:	aa1703e0 	mov	x0, x23
  202d08:	927df057 	and	x23, x2, #0xfffffffffffffff8
  202d0c:	b9007fe1 	str	w1, [sp, #124]
  202d10:	17ffff6f 	b	202acc <_vsnprintf+0x4bc>
        out((char)va_arg(va, int), buffer, idx++, maxlen);
  202d14:	11002341 	add	w1, w26, #0x8
  202d18:	7100003f 	cmp	w1, #0x0
  202d1c:	5400168d 	b.le	202fec <_vsnprintf+0x9dc>
  202d20:	91002ee2 	add	x2, x23, #0xb
  202d24:	aa1703e0 	mov	x0, x23
  202d28:	2a0103fa 	mov	w26, w1
  202d2c:	927df057 	and	x23, x2, #0xfffffffffffffff8
  202d30:	17ffff7a 	b	202b18 <_vsnprintf+0x508>
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
  202d34:	11002342 	add	w2, w26, #0x8
  202d38:	7100005f 	cmp	w2, #0x0
  202d3c:	5400168d 	b.le	20300c <_vsnprintf+0x9fc>
  202d40:	91003ee3 	add	x3, x23, #0xf
  202d44:	aa1703e1 	mov	x1, x23
  202d48:	2a0203fa 	mov	w26, w2
  202d4c:	927df077 	and	x23, x3, #0xfffffffffffffff8
  202d50:	17fffed4 	b	2028a0 <_vsnprintf+0x290>
        const char* p = va_arg(va, char*);
  202d54:	11002341 	add	w1, w26, #0x8
  202d58:	7100003f 	cmp	w1, #0x0
  202d5c:	5400150d 	b.le	202ffc <_vsnprintf+0x9ec>
  202d60:	91003ee2 	add	x2, x23, #0xf
  202d64:	aa1703e0 	mov	x0, x23
  202d68:	2a0103fa 	mov	w26, w1
  202d6c:	927df057 	and	x23, x2, #0xfffffffffffffff8
  202d70:	17fffef1 	b	202934 <_vsnprintf+0x324>
      const int w = va_arg(va, int);
  202d74:	f94047e0 	ldr	x0, [sp, #136]
  202d78:	8b3ac000 	add	x0, x0, w26, sxtw
  202d7c:	2a0203fa 	mov	w26, w2
  202d80:	17fffea8 	b	202820 <_vsnprintf+0x210>
          while (l++ < width) {
  202d84:	7100073f 	cmp	w25, #0x1
  202d88:	54002209 	b.ls	2031c8 <_vsnprintf+0xbb8>  // b.plast
  202d8c:	91000784 	add	x4, x28, #0x1
  202d90:	51000b36 	sub	w22, w25, #0x2
  202d94:	8b160096 	add	x22, x4, x22
  202d98:	14000003 	b	202da4 <_vsnprintf+0x794>
  202d9c:	f94043e4 	ldr	x4, [sp, #128]
  202da0:	91000484 	add	x4, x4, #0x1
            out(' ', buffer, idx++, maxlen);
  202da4:	f90043e4 	str	x4, [sp, #128]
  202da8:	aa1c03e2 	mov	x2, x28
  202dac:	aa1403e3 	mov	x3, x20
  202db0:	aa0403fc 	mov	x28, x4
  202db4:	aa1503e1 	mov	x1, x21
  202db8:	52800400 	mov	w0, #0x20                  	// #32
  202dbc:	d63f0260 	blr	x19
          while (l++ < width) {
  202dc0:	eb16039f 	cmp	x28, x22
  202dc4:	54fffec1 	b.ne	202d9c <_vsnprintf+0x78c>  // b.any
  202dc8:	11000720 	add	w0, w25, #0x1
  202dcc:	b90083e0 	str	w0, [sp, #128]
        out((char)va_arg(va, int), buffer, idx++, maxlen);
  202dd0:	36ffe9fa 	tbz	w26, #31, 202b0c <_vsnprintf+0x4fc>
  202dd4:	17ffffd0 	b	202d14 <_vsnprintf+0x704>
    switch (*format) {
  202dd8:	d2800102 	mov	x2, #0x8                   	// #8
  202ddc:	d503201f 	nop
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
  202de0:	121c74c1 	and	w1, w6, #0xfffffff3
        if (flags & FLAGS_PRECISION) {
  202de4:	3757f066 	tbnz	w6, #10, 202bf0 <_vsnprintf+0x5e0>
          if (flags & FLAGS_LONG_LONG) {
  202de8:	37480ec1 	tbnz	w1, #9, 202fc0 <_vsnprintf+0x9b0>
          else if (flags & FLAGS_LONG) {
  202dec:	37401481 	tbnz	w1, #8, 20307c <_vsnprintf+0xa6c>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  202df0:	37300b21 	tbnz	w1, #6, 202f54 <_vsnprintf+0x944>
  202df4:	363818c1 	tbz	w1, #7, 20310c <_vsnprintf+0xafc>
  202df8:	37f822ba 	tbnz	w26, #31, 20324c <_vsnprintf+0xc3c>
  202dfc:	aa1703e0 	mov	x0, x23
  202e00:	91002ee3 	add	x3, x23, #0xb
  202e04:	927df077 	and	x23, x3, #0xfffffffffffffff8
  202e08:	79400004 	ldrh	w4, [x0]
  202e0c:	14000057 	b	202f68 <_vsnprintf+0x958>
        if (*format == 'x' || *format == 'X') {
  202e10:	7101601f 	cmp	w0, #0x58
  202e14:	54000300 	b.eq	202e74 <_vsnprintf+0x864>  // b.none
  202e18:	7101881f 	cmp	w0, #0x62
    switch (*format) {
  202e1c:	d2800042 	mov	x2, #0x2                   	// #2
  202e20:	54fffe00 	b.eq	202de0 <_vsnprintf+0x7d0>  // b.none
          flags &= ~FLAGS_HASH;   // no hash for dec format
  202e24:	121b78c1 	and	w1, w6, #0xffffffef
  202e28:	52800c80 	mov	w0, #0x64                  	// #100
  202e2c:	17ffff6f 	b	202be8 <_vsnprintf+0x5d8>
          out(*(p++), buffer, idx++, maxlen);
  202e30:	aa1c03f6 	mov	x22, x28
  202e34:	cb1c015c 	sub	x28, x10, x28
  202e38:	aa1603e2 	mov	x2, x22
  202e3c:	910006d6 	add	x22, x22, #0x1
  202e40:	aa1403e3 	mov	x3, x20
  202e44:	aa1503e1 	mov	x1, x21
  202e48:	d63f0260 	blr	x19
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  202e4c:	38766b80 	ldrb	w0, [x28, x22]
  202e50:	35ffff40 	cbnz	w0, 202e38 <_vsnprintf+0x828>
          out(*(p++), buffer, idx++, maxlen);
  202e54:	aa1603fc 	mov	x28, x22
  202e58:	17fffee2 	b	2029e0 <_vsnprintf+0x3d0>
    switch (*format) {
  202e5c:	39400b60 	ldrb	w0, [x27, #2]
          flags |= FLAGS_CHAR;
  202e60:	321a04c6 	orr	w6, w6, #0xc0
          format++;
  202e64:	91000b62 	add	x2, x27, #0x2
  202e68:	17fffe58 	b	2027c8 <_vsnprintf+0x1b8>
  while (*format)
  202e6c:	52800016 	mov	w22, #0x0                   	// #0
  202e70:	17fffe9d 	b	2028e4 <_vsnprintf+0x2d4>
          flags |= FLAGS_UPPERCASE;
  202e74:	321b00c6 	orr	w6, w6, #0x20
  202e78:	d2800202 	mov	x2, #0x10                  	// #16
  202e7c:	17ffffd9 	b	202de0 <_vsnprintf+0x7d0>
        const int prec = (int)va_arg(va, int);
  202e80:	11002341 	add	w1, w26, #0x8
  202e84:	7100003f 	cmp	w1, #0x0
  202e88:	5400050d 	b.le	202f28 <_vsnprintf+0x918>
  202e8c:	91002ee2 	add	x2, x23, #0xb
  202e90:	aa1703e0 	mov	x0, x23
  202e94:	2a0103fa 	mov	w26, w1
  202e98:	927df057 	and	x23, x2, #0xfffffffffffffff8
  202e9c:	17ffff83 	b	202ca8 <_vsnprintf+0x698>
          while (l++ < width) {
  202ea0:	b94093e1 	ldr	w1, [sp, #144]
  202ea4:	6b19003f 	cmp	w1, w25
  202ea8:	54001862 	b.cs	2031b4 <_vsnprintf+0xba4>  // b.hs, b.nlast
  202eac:	51000720 	sub	w0, w25, #0x1
  202eb0:	91000784 	add	x4, x28, #0x1
  202eb4:	4b010000 	sub	w0, w0, w1
  202eb8:	8b040000 	add	x0, x0, x4
  202ebc:	f90053e0 	str	x0, [sp, #160]
  202ec0:	14000003 	b	202ecc <_vsnprintf+0x8bc>
  202ec4:	f9404be4 	ldr	x4, [sp, #144]
  202ec8:	91000484 	add	x4, x4, #0x1
  202ecc:	f90043ea 	str	x10, [sp, #128]
            out(' ', buffer, idx++, maxlen);
  202ed0:	aa1c03e2 	mov	x2, x28
  202ed4:	f9004be4 	str	x4, [sp, #144]
  202ed8:	aa0403fc 	mov	x28, x4
  202edc:	52800400 	mov	w0, #0x20                  	// #32
  202ee0:	aa1403e3 	mov	x3, x20
  202ee4:	aa1503e1 	mov	x1, x21
  202ee8:	d63f0260 	blr	x19
          while (l++ < width) {
  202eec:	f94053e0 	ldr	x0, [sp, #160]
  202ef0:	f94043ea 	ldr	x10, [sp, #128]
  202ef4:	eb00039f 	cmp	x28, x0
  202ef8:	54fffe61 	b.ne	202ec4 <_vsnprintf+0x8b4>  // b.any
  202efc:	11000720 	add	w0, w25, #0x1
  202f00:	b90093e0 	str	w0, [sp, #144]
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  202f04:	39400140 	ldrb	w0, [x10]
  202f08:	35ffd4a0 	cbnz	w0, 20299c <_vsnprintf+0x38c>
  202f0c:	17fffde2 	b	202694 <_vsnprintf+0x84>
  202f10:	7101e01f 	cmp	w0, #0x78
    switch (*format) {
  202f14:	d2800202 	mov	x2, #0x10                  	// #16
  202f18:	54fff640 	b.eq	202de0 <_vsnprintf+0x7d0>  // b.none
          flags &= ~FLAGS_HASH;   // no hash for dec format
  202f1c:	121b78c6 	and	w6, w6, #0xffffffef
  202f20:	d2800142 	mov	x2, #0xa                   	// #10
  202f24:	17ffffaf 	b	202de0 <_vsnprintf+0x7d0>
        const int prec = (int)va_arg(va, int);
  202f28:	f94047e0 	ldr	x0, [sp, #136]
  202f2c:	8b3ac000 	add	x0, x0, w26, sxtw
  202f30:	2a0103fa 	mov	w26, w1
  202f34:	17ffff5d 	b	202ca8 <_vsnprintf+0x698>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  202f38:	37f80f7a 	tbnz	w26, #31, 203124 <_vsnprintf+0xb14>
  202f3c:	91002ee3 	add	x3, x23, #0xb
  202f40:	aa1703e0 	mov	x0, x23
  202f44:	927df077 	and	x23, x3, #0xfffffffffffffff8
  202f48:	39400005 	ldrb	w5, [x0]
  202f4c:	2a0503e4 	mov	w4, w5
  202f50:	17ffff39 	b	202c34 <_vsnprintf+0x624>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  202f54:	37f8109a 	tbnz	w26, #31, 203164 <_vsnprintf+0xb54>
  202f58:	91002ee3 	add	x3, x23, #0xb
  202f5c:	aa1703e0 	mov	x0, x23
  202f60:	927df077 	and	x23, x3, #0xfffffffffffffff8
  202f64:	39400004 	ldrb	w4, [x0]
            idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
  202f68:	2a1603e7 	mov	w7, w22
  202f6c:	aa0203e6 	mov	x6, x2
  202f70:	2a0403e4 	mov	w4, w4
  202f74:	b90003f9 	str	w25, [sp]
  202f78:	b9000be1 	str	w1, [sp, #8]
  202f7c:	aa1c03e2 	mov	x2, x28
  202f80:	52800005 	mov	w5, #0x0                   	// #0
  202f84:	17ffff33 	b	202c50 <_vsnprintf+0x640>
            const long long value = va_arg(va, long long);
  202f88:	37f809fa 	tbnz	w26, #31, 2030c4 <_vsnprintf+0xab4>
  202f8c:	91003ee3 	add	x3, x23, #0xf
  202f90:	aa1703e0 	mov	x0, x23
  202f94:	927df077 	and	x23, x3, #0xfffffffffffffff8
  202f98:	f9400005 	ldr	x5, [x0]
            idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
  202f9c:	aa0203e6 	mov	x6, x2
  202fa0:	2a1603e7 	mov	w7, w22
  202fa4:	aa1c03e2 	mov	x2, x28
  202fa8:	f10000bf 	cmp	x5, #0x0
  202fac:	b90003f9 	str	w25, [sp]
  202fb0:	da85a4a4 	cneg	x4, x5, lt	// lt = tstop
  202fb4:	d37ffca5 	lsr	x5, x5, #63
  202fb8:	b9000be1 	str	w1, [sp, #8]
  202fbc:	17fffe41 	b	2028c0 <_vsnprintf+0x2b0>
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
  202fc0:	37f8073a 	tbnz	w26, #31, 2030a4 <_vsnprintf+0xa94>
  202fc4:	91003ee3 	add	x3, x23, #0xf
  202fc8:	aa1703e0 	mov	x0, x23
  202fcc:	927df077 	and	x23, x3, #0xfffffffffffffff8
  202fd0:	f9400004 	ldr	x4, [x0]
  202fd4:	aa0203e6 	mov	x6, x2
  202fd8:	2a1603e7 	mov	w7, w22
  202fdc:	aa1c03e2 	mov	x2, x28
  202fe0:	b90003f9 	str	w25, [sp]
  202fe4:	b9000be1 	str	w1, [sp, #8]
  202fe8:	17fffe35 	b	2028bc <_vsnprintf+0x2ac>
        out((char)va_arg(va, int), buffer, idx++, maxlen);
  202fec:	f94047e0 	ldr	x0, [sp, #136]
  202ff0:	8b3ac000 	add	x0, x0, w26, sxtw
  202ff4:	2a0103fa 	mov	w26, w1
  202ff8:	17fffec8 	b	202b18 <_vsnprintf+0x508>
        const char* p = va_arg(va, char*);
  202ffc:	f94047e0 	ldr	x0, [sp, #136]
  203000:	8b3ac000 	add	x0, x0, w26, sxtw
  203004:	2a0103fa 	mov	w26, w1
  203008:	17fffe4b 	b	202934 <_vsnprintf+0x324>
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
  20300c:	f94047e1 	ldr	x1, [sp, #136]
  203010:	8b3ac021 	add	x1, x1, w26, sxtw
  203014:	2a0203fa 	mov	w26, w2
  203018:	17fffe22 	b	2028a0 <_vsnprintf+0x290>
        idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
  20301c:	f9404fe2 	ldr	x2, [sp, #152]
  203020:	b9407fe0 	ldr	w0, [sp, #124]
  203024:	b9007fe1 	str	w1, [sp, #124]
  203028:	8b20c040 	add	x0, x2, w0, sxtw
  20302c:	17fffe96 	b	202a84 <_vsnprintf+0x474>
        idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
  203030:	f9404fe2 	ldr	x2, [sp, #152]
  203034:	b9407fe0 	ldr	w0, [sp, #124]
  203038:	b9007fe1 	str	w1, [sp, #124]
  20303c:	8b20c040 	add	x0, x2, w0, sxtw
  203040:	17fffea3 	b	202acc <_vsnprintf+0x4bc>
            const long value = va_arg(va, long);
  203044:	37f80a1a 	tbnz	w26, #31, 203184 <_vsnprintf+0xb74>
  203048:	91003ee3 	add	x3, x23, #0xf
  20304c:	aa1703e0 	mov	x0, x23
  203050:	927df077 	and	x23, x3, #0xfffffffffffffff8
  203054:	f9400005 	ldr	x5, [x0]
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
  203058:	aa0203e6 	mov	x6, x2
  20305c:	2a1603e7 	mov	w7, w22
  203060:	aa1c03e2 	mov	x2, x28
  203064:	f10000bf 	cmp	x5, #0x0
  203068:	b90003f9 	str	w25, [sp]
  20306c:	da85a4a4 	cneg	x4, x5, lt	// lt = tstop
  203070:	d37ffca5 	lsr	x5, x5, #63
  203074:	b9000be1 	str	w1, [sp, #8]
  203078:	17fffef6 	b	202c50 <_vsnprintf+0x640>
            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
  20307c:	37f8065a 	tbnz	w26, #31, 203144 <_vsnprintf+0xb34>
  203080:	91003ee3 	add	x3, x23, #0xf
  203084:	aa1703e0 	mov	x0, x23
  203088:	927df077 	and	x23, x3, #0xfffffffffffffff8
  20308c:	f9400004 	ldr	x4, [x0]
  203090:	2a1603e7 	mov	w7, w22
  203094:	aa0203e6 	mov	x6, x2
  203098:	b90003f9 	str	w25, [sp]
  20309c:	b9000be1 	str	w1, [sp, #8]
  2030a0:	17ffffb7 	b	202f7c <_vsnprintf+0x96c>
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
  2030a4:	11002343 	add	w3, w26, #0x8
  2030a8:	7100007f 	cmp	w3, #0x0
  2030ac:	5400096d 	b.le	2031d8 <_vsnprintf+0xbc8>
  2030b0:	91003ee4 	add	x4, x23, #0xf
  2030b4:	aa1703e0 	mov	x0, x23
  2030b8:	2a0303fa 	mov	w26, w3
  2030bc:	927df097 	and	x23, x4, #0xfffffffffffffff8
  2030c0:	17ffffc4 	b	202fd0 <_vsnprintf+0x9c0>
            const long long value = va_arg(va, long long);
  2030c4:	11002343 	add	w3, w26, #0x8
  2030c8:	7100007f 	cmp	w3, #0x0
  2030cc:	540006cd 	b.le	2031a4 <_vsnprintf+0xb94>
  2030d0:	91003ee4 	add	x4, x23, #0xf
  2030d4:	aa1703e0 	mov	x0, x23
  2030d8:	2a0303fa 	mov	w26, w3
  2030dc:	927df097 	and	x23, x4, #0xfffffffffffffff8
  2030e0:	17ffffae 	b	202f98 <_vsnprintf+0x988>
  for (s = str; *s && maxsize--; ++s);
  2030e4:	b90093ff 	str	wzr, [sp, #144]
  2030e8:	17fffe22 	b	202970 <_vsnprintf+0x360>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  2030ec:	37f80cba 	tbnz	w26, #31, 203280 <_vsnprintf+0xc70>
  2030f0:	91002ee3 	add	x3, x23, #0xb
  2030f4:	aa1703e0 	mov	x0, x23
  2030f8:	927df077 	and	x23, x3, #0xfffffffffffffff8
  2030fc:	b9400005 	ldr	w5, [x0]
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
  203100:	710000bf 	cmp	w5, #0x0
  203104:	5a85a4a4 	cneg	w4, w5, lt	// lt = tstop
  203108:	17fffecb 	b	202c34 <_vsnprintf+0x624>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  20310c:	37f807fa 	tbnz	w26, #31, 203208 <_vsnprintf+0xbf8>
  203110:	aa1703e0 	mov	x0, x23
  203114:	91002ee3 	add	x3, x23, #0xb
  203118:	927df077 	and	x23, x3, #0xfffffffffffffff8
  20311c:	b9400004 	ldr	w4, [x0]
  203120:	17ffff92 	b	202f68 <_vsnprintf+0x958>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  203124:	11002343 	add	w3, w26, #0x8
  203128:	7100007f 	cmp	w3, #0x0
  20312c:	540005ed 	b.le	2031e8 <_vsnprintf+0xbd8>
  203130:	91002ee4 	add	x4, x23, #0xb
  203134:	aa1703e0 	mov	x0, x23
  203138:	2a0303fa 	mov	w26, w3
  20313c:	927df097 	and	x23, x4, #0xfffffffffffffff8
  203140:	17ffff82 	b	202f48 <_vsnprintf+0x938>
            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
  203144:	11002343 	add	w3, w26, #0x8
  203148:	7100007f 	cmp	w3, #0x0
  20314c:	5400092d 	b.le	203270 <_vsnprintf+0xc60>
  203150:	91003ee4 	add	x4, x23, #0xf
  203154:	aa1703e0 	mov	x0, x23
  203158:	2a0303fa 	mov	w26, w3
  20315c:	927df097 	and	x23, x4, #0xfffffffffffffff8
  203160:	17ffffcb 	b	20308c <_vsnprintf+0xa7c>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  203164:	11002343 	add	w3, w26, #0x8
  203168:	7100007f 	cmp	w3, #0x0
  20316c:	540009ad 	b.le	2032a0 <_vsnprintf+0xc90>
  203170:	91002ee4 	add	x4, x23, #0xb
  203174:	aa1703e0 	mov	x0, x23
  203178:	2a0303fa 	mov	w26, w3
  20317c:	927df097 	and	x23, x4, #0xfffffffffffffff8
  203180:	17ffff79 	b	202f64 <_vsnprintf+0x954>
            const long value = va_arg(va, long);
  203184:	11002343 	add	w3, w26, #0x8
  203188:	7100007f 	cmp	w3, #0x0
  20318c:	5400036d 	b.le	2031f8 <_vsnprintf+0xbe8>
  203190:	91003ee4 	add	x4, x23, #0xf
  203194:	aa1703e0 	mov	x0, x23
  203198:	2a0303fa 	mov	w26, w3
  20319c:	927df097 	and	x23, x4, #0xfffffffffffffff8
  2031a0:	17ffffad 	b	203054 <_vsnprintf+0xa44>
            const long long value = va_arg(va, long long);
  2031a4:	f94047e0 	ldr	x0, [sp, #136]
  2031a8:	8b3ac000 	add	x0, x0, w26, sxtw
  2031ac:	2a0303fa 	mov	w26, w3
  2031b0:	17ffff7a 	b	202f98 <_vsnprintf+0x988>
          while (l++ < width) {
  2031b4:	b94093e1 	ldr	w1, [sp, #144]
  2031b8:	11000421 	add	w1, w1, #0x1
  2031bc:	b90093e1 	str	w1, [sp, #144]
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  2031c0:	35ffbee0 	cbnz	w0, 20299c <_vsnprintf+0x38c>
  2031c4:	17fffd34 	b	202694 <_vsnprintf+0x84>
          while (l++ < width) {
  2031c8:	52800040 	mov	w0, #0x2                   	// #2
  2031cc:	b90083e0 	str	w0, [sp, #128]
        out((char)va_arg(va, int), buffer, idx++, maxlen);
  2031d0:	36ffc9fa 	tbz	w26, #31, 202b0c <_vsnprintf+0x4fc>
  2031d4:	17fffed0 	b	202d14 <_vsnprintf+0x704>
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
  2031d8:	f94047e0 	ldr	x0, [sp, #136]
  2031dc:	8b3ac000 	add	x0, x0, w26, sxtw
  2031e0:	2a0303fa 	mov	w26, w3
  2031e4:	17ffff7b 	b	202fd0 <_vsnprintf+0x9c0>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  2031e8:	f94047e0 	ldr	x0, [sp, #136]
  2031ec:	8b3ac000 	add	x0, x0, w26, sxtw
  2031f0:	2a0303fa 	mov	w26, w3
  2031f4:	17ffff55 	b	202f48 <_vsnprintf+0x938>
            const long value = va_arg(va, long);
  2031f8:	f94047e0 	ldr	x0, [sp, #136]
  2031fc:	8b3ac000 	add	x0, x0, w26, sxtw
  203200:	2a0303fa 	mov	w26, w3
  203204:	17ffff94 	b	203054 <_vsnprintf+0xa44>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  203208:	11002343 	add	w3, w26, #0x8
  20320c:	7100007f 	cmp	w3, #0x0
  203210:	5400050d 	b.le	2032b0 <_vsnprintf+0xca0>
  203214:	aa1703e0 	mov	x0, x23
  203218:	91002ee4 	add	x4, x23, #0xb
  20321c:	927df097 	and	x23, x4, #0xfffffffffffffff8
  203220:	2a0303fa 	mov	w26, w3
  203224:	b9400004 	ldr	w4, [x0]
  203228:	17ffff50 	b	202f68 <_vsnprintf+0x958>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  20322c:	11002343 	add	w3, w26, #0x8
  203230:	7100007f 	cmp	w3, #0x0
  203234:	5400048d 	b.le	2032c4 <_vsnprintf+0xcb4>
  203238:	91002ee4 	add	x4, x23, #0xb
  20323c:	aa1703e0 	mov	x0, x23
  203240:	2a0303fa 	mov	w26, w3
  203244:	927df097 	and	x23, x4, #0xfffffffffffffff8
  203248:	17fffe77 	b	202c24 <_vsnprintf+0x614>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  20324c:	11002343 	add	w3, w26, #0x8
  203250:	7100007f 	cmp	w3, #0x0
  203254:	5400040d 	b.le	2032d4 <_vsnprintf+0xcc4>
  203258:	aa1703e0 	mov	x0, x23
  20325c:	91002ee4 	add	x4, x23, #0xb
  203260:	927df097 	and	x23, x4, #0xfffffffffffffff8
  203264:	2a0303fa 	mov	w26, w3
  203268:	79400004 	ldrh	w4, [x0]
  20326c:	17ffff3f 	b	202f68 <_vsnprintf+0x958>
            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
  203270:	f94047e0 	ldr	x0, [sp, #136]
  203274:	8b3ac000 	add	x0, x0, w26, sxtw
  203278:	2a0303fa 	mov	w26, w3
  20327c:	17ffff84 	b	20308c <_vsnprintf+0xa7c>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  203280:	11002343 	add	w3, w26, #0x8
  203284:	7100007f 	cmp	w3, #0x0
  203288:	5400030d 	b.le	2032e8 <_vsnprintf+0xcd8>
  20328c:	91002ee4 	add	x4, x23, #0xb
  203290:	aa1703e0 	mov	x0, x23
  203294:	2a0303fa 	mov	w26, w3
  203298:	927df097 	and	x23, x4, #0xfffffffffffffff8
  20329c:	17ffff98 	b	2030fc <_vsnprintf+0xaec>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  2032a0:	f94047e0 	ldr	x0, [sp, #136]
  2032a4:	8b3ac000 	add	x0, x0, w26, sxtw
  2032a8:	2a0303fa 	mov	w26, w3
  2032ac:	17ffff2e 	b	202f64 <_vsnprintf+0x954>
  2032b0:	f94047e0 	ldr	x0, [sp, #136]
  2032b4:	8b3ac000 	add	x0, x0, w26, sxtw
  2032b8:	2a0303fa 	mov	w26, w3
  2032bc:	b9400004 	ldr	w4, [x0]
  2032c0:	17ffff2a 	b	202f68 <_vsnprintf+0x958>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  2032c4:	f94047e0 	ldr	x0, [sp, #136]
  2032c8:	8b3ac000 	add	x0, x0, w26, sxtw
  2032cc:	2a0303fa 	mov	w26, w3
  2032d0:	17fffe55 	b	202c24 <_vsnprintf+0x614>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  2032d4:	f94047e0 	ldr	x0, [sp, #136]
  2032d8:	8b3ac000 	add	x0, x0, w26, sxtw
  2032dc:	2a0303fa 	mov	w26, w3
  2032e0:	79400004 	ldrh	w4, [x0]
  2032e4:	17ffff21 	b	202f68 <_vsnprintf+0x958>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  2032e8:	f94047e0 	ldr	x0, [sp, #136]
  2032ec:	8b3ac000 	add	x0, x0, w26, sxtw
  2032f0:	2a0303fa 	mov	w26, w3
  2032f4:	17ffff82 	b	2030fc <_vsnprintf+0xaec>
  2032f8:	2a0103e6 	mov	w6, w1
  2032fc:	d2800142 	mov	x2, #0xa                   	// #10
  203300:	17fffeb8 	b	202de0 <_vsnprintf+0x7d0>
  203304:	d503201f 	nop
  203308:	d503201f 	nop
  20330c:	d503201f 	nop

0000000000203310 <sddf_printf_>:


///////////////////////////////////////////////////////////////////////////////

int sddf_printf_(const char* format, ...)
{
  203310:	a9ae7bfd 	stp	x29, x30, [sp, #-288]!
  va_list va;
  va_start(va, format);
  203314:	12800fe9 	mov	w9, #0xffffff80            	// #-128
  203318:	128006ea 	mov	w10, #0xffffffc8            	// #-56
{
  20331c:	910003fd 	mov	x29, sp
  va_start(va, format);
  203320:	910383eb 	add	x11, sp, #0xe0
  203324:	910483e8 	add	x8, sp, #0x120
  203328:	a90423e8 	stp	x8, x8, [sp, #64]
{
  20332c:	aa0003e8 	mov	x8, x0
  char buffer[1];
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  203330:	d0ffffe0 	adrp	x0, 201000 <notified+0x100>
  203334:	91394000 	add	x0, x0, #0xe50
  va_start(va, format);
  203338:	f9002beb 	str	x11, [sp, #80]
  20333c:	290b27ea 	stp	w10, w9, [sp, #88]
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  203340:	a94437ec 	ldp	x12, x13, [sp, #64]
  203344:	a90137ec 	stp	x12, x13, [sp, #16]
  203348:	a9452fea 	ldp	x10, x11, [sp, #80]
  20334c:	a9022fea 	stp	x10, x11, [sp, #32]
{
  203350:	3d801be0 	str	q0, [sp, #96]
  203354:	3d801fe1 	str	q1, [sp, #112]
  203358:	3d8023e2 	str	q2, [sp, #128]
  20335c:	3d8027e3 	str	q3, [sp, #144]
  203360:	3d802be4 	str	q4, [sp, #160]
  203364:	3d802fe5 	str	q5, [sp, #176]
  203368:	3d8033e6 	str	q6, [sp, #192]
  20336c:	3d8037e7 	str	q7, [sp, #208]
  203370:	a90e8be1 	stp	x1, x2, [sp, #232]
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  203374:	9100e3e1 	add	x1, sp, #0x38
  203378:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
{
  20337c:	a90f93e3 	stp	x3, x4, [sp, #248]
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  203380:	910043e4 	add	x4, sp, #0x10
  203384:	aa0803e3 	mov	x3, x8
{
  203388:	a9109be5 	stp	x5, x6, [sp, #264]
  20338c:	f9008fe7 	str	x7, [sp, #280]
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  203390:	97fffca0 	bl	202610 <_vsnprintf>
  va_end(va);
  return ret;
}
  203394:	a8d27bfd 	ldp	x29, x30, [sp], #288
  203398:	d65f03c0 	ret
  20339c:	d503201f 	nop

00000000002033a0 <sddf_sprintf_>:


int sddf_sprintf_(char* buffer, const char* format, ...)
{
  2033a0:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
  va_list va;
  va_start(va, format);
  2033a4:	12800fe9 	mov	w9, #0xffffff80            	// #-128
  2033a8:	128005ea 	mov	w10, #0xffffffd0            	// #-48
{
  2033ac:	910003fd 	mov	x29, sp
  va_start(va, format);
  2033b0:	910343e8 	add	x8, sp, #0xd0
  2033b4:	910403eb 	add	x11, sp, #0x100
  2033b8:	a9032feb 	stp	x11, x11, [sp, #48]
  2033bc:	f90023e8 	str	x8, [sp, #64]
{
  2033c0:	aa0103e8 	mov	x8, x1
  va_start(va, format);
  2033c4:	290927ea 	stp	w10, w9, [sp, #72]
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
  2033c8:	aa0003e1 	mov	x1, x0
  2033cc:	a94337ec 	ldp	x12, x13, [sp, #48]
  2033d0:	d0ffffe0 	adrp	x0, 201000 <notified+0x100>
  2033d4:	a9442fea 	ldp	x10, x11, [sp, #64]
  2033d8:	9125c000 	add	x0, x0, #0x970
  2033dc:	a90137ec 	stp	x12, x13, [sp, #16]
  2033e0:	a9022fea 	stp	x10, x11, [sp, #32]
{
  2033e4:	3d8017e0 	str	q0, [sp, #80]
  2033e8:	3d801be1 	str	q1, [sp, #96]
  2033ec:	3d801fe2 	str	q2, [sp, #112]
  2033f0:	3d8023e3 	str	q3, [sp, #128]
  2033f4:	3d8027e4 	str	q4, [sp, #144]
  2033f8:	3d802be5 	str	q5, [sp, #160]
  2033fc:	3d802fe6 	str	q6, [sp, #176]
  203400:	3d8033e7 	str	q7, [sp, #192]
  203404:	a90d0fe2 	stp	x2, x3, [sp, #208]
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
  203408:	aa0803e3 	mov	x3, x8
  20340c:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
{
  203410:	a90e17e4 	stp	x4, x5, [sp, #224]
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
  203414:	910043e4 	add	x4, sp, #0x10
{
  203418:	a90f1fe6 	stp	x6, x7, [sp, #240]
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
  20341c:	97fffc7d 	bl	202610 <_vsnprintf>
  va_end(va);
  return ret;
}
  203420:	a8d07bfd 	ldp	x29, x30, [sp], #256
  203424:	d65f03c0 	ret
  203428:	d503201f 	nop
  20342c:	d503201f 	nop

0000000000203430 <sddf_snprintf_>:


int sddf_snprintf_(char* buffer, size_t count, const char* format, ...)
{
  203430:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
  va_list va;
  va_start(va, format);
  203434:	128004e8 	mov	w8, #0xffffffd8            	// #-40
  203438:	12800fea 	mov	w10, #0xffffff80            	// #-128
{
  20343c:	910003fd 	mov	x29, sp
  va_start(va, format);
  203440:	910343e9 	add	x9, sp, #0xd0
  203444:	910403eb 	add	x11, sp, #0x100
  203448:	a9032feb 	stp	x11, x11, [sp, #48]
  20344c:	f90023e9 	str	x9, [sp, #64]
{
  203450:	aa0103e9 	mov	x9, x1
  va_start(va, format);
  203454:	29092be8 	stp	w8, w10, [sp, #72]
{
  203458:	aa0203e8 	mov	x8, x2
  const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
  20345c:	a94337ec 	ldp	x12, x13, [sp, #48]
  203460:	aa0003e1 	mov	x1, x0
  203464:	a9442fea 	ldp	x10, x11, [sp, #64]
  203468:	aa0903e2 	mov	x2, x9
  20346c:	d0ffffe0 	adrp	x0, 201000 <notified+0x100>
  203470:	9125c000 	add	x0, x0, #0x970
  203474:	a90137ec 	stp	x12, x13, [sp, #16]
  203478:	a9022fea 	stp	x10, x11, [sp, #32]
{
  20347c:	3d8017e0 	str	q0, [sp, #80]
  203480:	3d801be1 	str	q1, [sp, #96]
  203484:	3d801fe2 	str	q2, [sp, #112]
  203488:	3d8023e3 	str	q3, [sp, #128]
  20348c:	3d8027e4 	str	q4, [sp, #144]
  203490:	3d802be5 	str	q5, [sp, #160]
  203494:	3d802fe6 	str	q6, [sp, #176]
  203498:	3d8033e7 	str	q7, [sp, #192]
  20349c:	a90d93e3 	stp	x3, x4, [sp, #216]
  const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
  2034a0:	910043e4 	add	x4, sp, #0x10
  2034a4:	aa0803e3 	mov	x3, x8
{
  2034a8:	a90e9be5 	stp	x5, x6, [sp, #232]
  2034ac:	f9007fe7 	str	x7, [sp, #248]
  const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
  2034b0:	97fffc58 	bl	202610 <_vsnprintf>
  va_end(va);
  return ret;
}
  2034b4:	a8d07bfd 	ldp	x29, x30, [sp], #256
  2034b8:	d65f03c0 	ret
  2034bc:	d503201f 	nop

00000000002034c0 <sddf_vprintf_>:


int sddf_vprintf_(const char* format, va_list va)
{
  2034c0:	aa0103e5 	mov	x5, x1
  2034c4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  char buffer[1];
  return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  2034c8:	aa0003e3 	mov	x3, x0
{
  2034cc:	910003fd 	mov	x29, sp
  return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  2034d0:	a9401ca6 	ldp	x6, x7, [x5]
  2034d4:	f9000be6 	str	x6, [sp, #16]
  2034d8:	910043e4 	add	x4, sp, #0x10
  2034dc:	9100e3e1 	add	x1, sp, #0x38
  2034e0:	f94008a6 	ldr	x6, [x5, #16]
  2034e4:	f9000fe7 	str	x7, [sp, #24]
  2034e8:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
  2034ec:	d0ffffe0 	adrp	x0, 201000 <notified+0x100>
  2034f0:	f9400ca5 	ldr	x5, [x5, #24]
  2034f4:	91394000 	add	x0, x0, #0xe50
  2034f8:	a90217e6 	stp	x6, x5, [sp, #32]
  2034fc:	97fffc45 	bl	202610 <_vsnprintf>
}
  203500:	a8c47bfd 	ldp	x29, x30, [sp], #64
  203504:	d65f03c0 	ret
  203508:	d503201f 	nop
  20350c:	d503201f 	nop

0000000000203510 <sddf_vsnprintf_>:


int sddf_vsnprintf_(char* buffer, size_t count, const char* format, va_list va)
{
  203510:	aa0303e5 	mov	x5, x3
  203514:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  203518:	aa0103e4 	mov	x4, x1
  20351c:	910003fd 	mov	x29, sp
  return _vsnprintf(_out_buffer, buffer, count, format, va);
  203520:	a9401ca8 	ldp	x8, x7, [x5]
  203524:	aa0003e1 	mov	x1, x0
  203528:	a94114a6 	ldp	x6, x5, [x5, #16]
  20352c:	aa0203e3 	mov	x3, x2
  203530:	d0ffffe0 	adrp	x0, 201000 <notified+0x100>
  203534:	9125c000 	add	x0, x0, #0x970
  203538:	aa0403e2 	mov	x2, x4
  20353c:	910043e4 	add	x4, sp, #0x10
  203540:	a9011fe8 	stp	x8, x7, [sp, #16]
  203544:	a90217e6 	stp	x6, x5, [sp, #32]
  203548:	97fffc32 	bl	202610 <_vsnprintf>
}
  20354c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  203550:	d65f03c0 	ret
  203554:	d503201f 	nop
  203558:	d503201f 	nop
  20355c:	d503201f 	nop

0000000000203560 <sddf_fctprintf>:


int sddf_fctprintf(void (*out)(char character, void* arg), void* arg, const char* format, ...)
{
  203560:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  va_list va;
  va_start(va, format);
  203564:	12800feb 	mov	w11, #0xffffff80            	// #-128
  203568:	128004e9 	mov	w9, #0xffffffd8            	// #-40
{
  20356c:	910003fd 	mov	x29, sp
  va_start(va, format);
  203570:	910383ea 	add	x10, sp, #0xe0
  203574:	910443e8 	add	x8, sp, #0x110
  203578:	a90423e8 	stp	x8, x8, [sp, #64]
{
  20357c:	aa0203e8 	mov	x8, x2
  const out_fct_wrap_type out_fct_wrap = { out, arg };
  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
  203580:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
  va_start(va, format);
  203584:	f9002bea 	str	x10, [sp, #80]
{
  203588:	aa0003ea 	mov	x10, x0
  va_start(va, format);
  20358c:	290b2fe9 	stp	w9, w11, [sp, #88]
{
  203590:	aa0103e9 	mov	x9, x1
  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
  203594:	a9443fee 	ldp	x14, x15, [sp, #64]
  203598:	9100c3e1 	add	x1, sp, #0x30
  20359c:	a94537ec 	ldp	x12, x13, [sp, #80]
  2035a0:	d0ffffe0 	adrp	x0, 201000 <notified+0x100>
  2035a4:	91398000 	add	x0, x0, #0xe60
  2035a8:	a9013fee 	stp	x14, x15, [sp, #16]
  2035ac:	a90237ec 	stp	x12, x13, [sp, #32]
  const out_fct_wrap_type out_fct_wrap = { out, arg };
  2035b0:	a90327ea 	stp	x10, x9, [sp, #48]
{
  2035b4:	3d801be0 	str	q0, [sp, #96]
  2035b8:	3d801fe1 	str	q1, [sp, #112]
  2035bc:	3d8023e2 	str	q2, [sp, #128]
  2035c0:	3d8027e3 	str	q3, [sp, #144]
  2035c4:	3d802be4 	str	q4, [sp, #160]
  2035c8:	3d802fe5 	str	q5, [sp, #176]
  2035cc:	3d8033e6 	str	q6, [sp, #192]
  2035d0:	3d8037e7 	str	q7, [sp, #208]
  2035d4:	a90e93e3 	stp	x3, x4, [sp, #232]
  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
  2035d8:	910043e4 	add	x4, sp, #0x10
  2035dc:	aa0803e3 	mov	x3, x8
{
  2035e0:	a90f9be5 	stp	x5, x6, [sp, #248]
  2035e4:	f90087e7 	str	x7, [sp, #264]
  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
  2035e8:	97fffc0a 	bl	202610 <_vsnprintf>
  va_end(va);
  return ret;
}
  2035ec:	a8d17bfd 	ldp	x29, x30, [sp], #272
  2035f0:	d65f03c0 	ret
	...

0000000000203600 <_assert_fail>:
 */

#include <sddf/util/printf.h>

void _assert_fail(const char  *assertion, const char  *file, unsigned int line, const char  *function)
{
  203600:	2a0203e5 	mov	w5, w2
  203604:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  203608:	aa0103e4 	mov	x4, x1
  20360c:	910003fd 	mov	x29, sp
    sddf_dprintf("Failed assertion '%s' at %s:%u in function %s\n", assertion, file, line, function);
  203610:	aa0003e1 	mov	x1, x0
  203614:	aa0403e2 	mov	x2, x4
  203618:	aa0303e4 	mov	x4, x3
  20361c:	90000000 	adrp	x0, 203000 <_vsnprintf+0x9f0>
  203620:	91392000 	add	x0, x0, #0xe48
  203624:	2a0503e3 	mov	w3, w5
  203628:	97ffff3a 	bl	203310 <sddf_printf_>
    __builtin_trap();
  20362c:	d4207d00 	brk	#0x3e8

0000000000203630 <_sddf_putchar>:

static char string_buffer[MAX_STRING_LENGTH + 1];
static uint32_t local_tail;

void _sddf_putchar(char character)
{
  203630:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    string_buffer[local_tail] = character;
  203634:	d0000001 	adrp	x1, 205000 <tx_descriptors+0x60>
  203638:	91210021 	add	x1, x1, #0x840
{
  20363c:	910003fd 	mov	x29, sp
  203640:	f9000bf3 	str	x19, [sp, #16]
    string_buffer[local_tail] = character;
  203644:	d0000013 	adrp	x19, 205000 <tx_descriptors+0x60>
  203648:	b9483263 	ldr	w3, [x19, #2096]
{
  20364c:	12001c00 	and	w0, w0, #0xff
    local_tail++;
  203650:	11000462 	add	w2, w3, #0x1
  203654:	b9083262 	str	w2, [x19, #2096]

    if (character == FLUSH_CHAR || local_tail == MAX_STRING_LENGTH) {
  203658:	7140045f 	cmp	w2, #0x1, lsl #12
    string_buffer[local_tail] = character;
  20365c:	38234820 	strb	w0, [x1, w3, uxtw]
    if (character == FLUSH_CHAR || local_tail == MAX_STRING_LENGTH) {
  203660:	7a4a1804 	ccmp	w0, #0xa, #0x4, ne	// ne = any
  203664:	540000a1 	b.ne	203678 <_sddf_putchar+0x48>  // b.any
        string_buffer[local_tail] = '\0';
        microkit_dbg_puts(string_buffer);
  203668:	aa0103e0 	mov	x0, x1
        string_buffer[local_tail] = '\0';
  20366c:	3822483f 	strb	wzr, [x1, w2, uxtw]
        microkit_dbg_puts(string_buffer);
  203670:	97fff85c 	bl	2017e0 <microkit_dbg_puts>
        local_tail = 0;
  203674:	b908327f 	str	wzr, [x19, #2096]
    }
  203678:	f9400bf3 	ldr	x19, [sp, #16]
  20367c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  203680:	d65f03c0 	ret
  203684:	00000000 	udf	#0

0000000000203688 <__FUNCTION__.4>:
  203688:	705f7872 69766f72 00006564 00000000     rx_provide......

0000000000203698 <__FUNCTION__.3>:
  203698:	705f7874 69766f72 00006564 00000000     tx_provide......

00000000002036a8 <__FUNCTION__.7>:
  2036a8:	74696e69 00000000                       init....

00000000002036b0 <__FUNCTION__.5>:
  2036b0:	5f687465 75746573 00000070 00000000     eth_setup.......

00000000002036c0 <__FUNCTION__.1>:
  2036c0:	725f7872 72757465 0000006e 00000000     rx_return.......

00000000002036d0 <__FUNCTION__.0>:
  2036d0:	725f7874 72757465 0000006e 00000000     tx_return.......
  2036e0:	ff9f00e0 ff9fff9f ff9fff9f ff9fff9f     ................
  2036f0:	ff9fff9f ff9fff9f ff9fff9f ff9fff9f     ................
  203700:	ff9fff9f ff9fff9f ff9fff9f ff9fff9f     ................
  203710:	ff9fff9f ff9fff9f ff9fff9f ff9fff9f     ................
  203720:	00ab0093 ff9f0093 ff9fff9f ff9fff9f     ................
  203730:	ff9fff9f ff9fff9f ff9fff9f ff9fff9f     ................
  203740:	ff9fff9f 0184ff9f ff9fff9f ff9fff9f     ................
  203750:	ff9fff9f ff9fff9f 0184ff9f 018400bd     ................
  203760:	00ab0093 00000093 00000000 00000000     ................

0000000000203770 <pow10.0>:
  203770:	00000000 3ff00000 00000000 40240000     .......?......$@
  203780:	00000000 40590000 00000000 408f4000     ......Y@.....@.@
  203790:	00000000 40c38800 00000000 40f86a00     .......@.....j.@
  2037a0:	00000000 412e8480 00000000 416312d0     .......A......cA
  2037b0:	00000000 4197d784 00000000 41cdcd65     .......A....e..A
