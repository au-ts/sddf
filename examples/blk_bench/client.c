/*
 * Copyright 2024, UNSW
 * SPDX-License-Identifier: BSD-2-Clause
 */

#include <microkit.h>
#include <sddf/util/printf.h>
#include <sddf/util/util.h>
#include <sddf/util/string.h>
#include <sddf/blk/queue.h>
#include <sddf/blk/storage_info.h>
#include <sddf/serial/queue.h>
#include <serial_config.h>

/*
 * Add benchmarking specific functions for controlling PMU.
 */
//#include <sddf/benchmark/sel4bench.h>

/*
 * This header is generated by the build system, it contains the data we want
 * to write to the block device
 */
#include "basic_data.h"
//#include "sddf/util/fence.h"

#define LOG_CLIENT(...) do{ sddf_printf("CLIENT|INFO: "); sddf_printf(__VA_ARGS__); }while(0)
#define LOG_CLIENT_ERR(...) do{ sddf_printf("CLIENT|ERROR: "); sddf_printf(__VA_ARGS__); }while(0)

#define QUEUE_SIZE 128
#define VIRT_CH 0
#define SERIAL_TX_CH 1
#define START_PMU 2
#define STOP_PMU 3
#define BENCH_RUN_CH 4


char *serial_tx_data;
serial_queue_t *serial_tx_queue;
serial_queue_handle_t serial_tx_queue_handle;

blk_storage_info_t *blk_storage_info;
uintptr_t blk_request;
uintptr_t blk_response;
uintptr_t blk_data;

static blk_queue_handle_t blk_queue;

enum run_benchmark_state {
    START_BENCHMARK,
    THROUGHPUT_RANDOM_READ,
    THROUGHPUT_WRITE,
    LATENCY_READ,
    LATENCY_WRITE,
};

enum test_basic_state {
    START,
    WRITE,
    READ,
    FINISH,
};


enum test_basic_state test_basic_state = START;
enum run_benchmark_state run_benchmark_state = START_BENCHMARK;
bool virtualiser_replied = false;

bool run_benchmark() {
    switch(run_benchmark_state) {
        case START_BENCHMARK:
            /* make sure the driver is working properly */
            if (!virtualiser_replied) {
                LOG_CLIENT("run_benchmark: START state,verifying if a simple read succeeds...\n");
                //int err = blk_enqueue_req(&blk_queue, BLK_REQ_WRITE, 0, 0, 2, 0);
                //int err = blk_enqueue_req(&blk_queue, BLK_REQ_READ, blk_data_paddr, 0, 2, request_id);
                int err = blk_enqueue_req(&blk_queue, BLK_REQ_READ, 0x10000, 0, 2, 0);
                assert(!err);
                microkit_notify(VIRT_CH);
            } else {
                blk_resp_status_t status = -1;
                uint16_t count = -1;
                uint32_t id = -1;
                int err = blk_dequeue_resp(&blk_queue, &status, &count, &id);
                assert(!err);
                assert(status == BLK_RESP_OK);
                assert(count == 2);
                assert(id == 0);
                LOG_CLIENT("run_benchmark: simple read successful.\n");
                run_benchmark_state = THROUGHPUT_RANDOM_READ;
                // TODO schedule the first benchmark now
                // run_benchmark_state();
            }
            break;
        case THROUGHPUT_RANDOM_READ:
            /* Perform QUEUE_SIZE random READs, from 4KiB write size up to 128MiB (x8 at each step) */
            // XXX can "simulate" random reads, by interleaving reads at 2 distant offsets (see Cheng's sdmmc_rust branch)
            break;
        case THROUGHPUT_WRITE:
            /* Perform QUEUE_SIZE WRITEs, from 4KiB write size up to 128MiB (x8 at each step) */
            break;
        case LATENCY_READ:
            // Perform QUEUE_SIZE random reads, only measure latency of each read
            // XXX to verify: will latency differ with request read size? or will it be constant
            // XXX if varies, maybe can be merged into THROUGHPUT_RANDOM_READ
            break;
        case LATENCY_WRITE:
            // Per
            // Returns true, as this is the final benchmark. System will sit idle afterwards
            return true;
            break;
        default:
            LOG_CLIENT_ERR("internal error, invalid state\n");
            assert(false);
    }
    return false;
}

void init(void)
{
    serial_cli_queue_init_sys(microkit_name, NULL, NULL, NULL, &serial_tx_queue_handle, serial_tx_queue, serial_tx_data);
    serial_putchar_init(SERIAL_TX_CH, &serial_tx_queue_handle);

    LOG_CLIENT("starting.\n");
    blk_queue_init(&blk_queue, (blk_req_queue_t *)blk_request, (blk_resp_queue_t *)blk_response, QUEUE_SIZE);

    /* Want to print out configuration information, so wait until the config is ready. */
    while (!blk_storage_is_ready(blk_storage_info));
    LOG_CLIENT("device config ready\n");

    LOG_CLIENT("device size: 0x%lx bytes\n", blk_storage_info->capacity * BLK_TRANSFER_SIZE);
}

void notified(microkit_channel ch)
{
    switch (ch) {
        case VIRT_CH:
            // Virtualiser replied, handle appropriately
            virtualiser_replied = true;
            run_benchmark();
            break;
        case SERIAL_TX_CH:
            // Nothing to do
            break;
        case BENCH_RUN_CH:
            // TODO: Start the required benchmark
            // Spin in case blk_driver not ready yet
            virtualiser_replied = false;
            LOG_CLIENT("client notified to start bench.");
            while (!blk_storage_is_ready(blk_storage_info));
            run_benchmark();
            break;
        default:
            LOG_CLIENT_ERR("received notification on unexpected channel: %u\n", ch);
            break;
    }
}
