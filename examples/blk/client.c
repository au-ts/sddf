/*
 * Copyright 2024, UNSW
 * SPDX-License-Identifier: BSD-2-Clause
 */

#include <microkit.h>
#include <sddf/util/printf.h>
#include <sddf/util/util.h>
#include <sddf/util/string.h>
#include <sddf/blk/queue.h>
#include <sddf/blk/storage_info.h>
#include <sddf/blk/config.h>
#include <sddf/serial/queue.h>
#include <sddf/serial/config.h>

/*
 * This header is generated by the build system, it contains the data we want
 * to write to the block device
 */
#include "basic_data.h"

#define LOG_CLIENT(...) do{ sddf_printf("CLIENT|INFO: "); sddf_printf(__VA_ARGS__); }while(0)
#define LOG_CLIENT_ERR(...) do{ sddf_printf("CLIENT|ERROR: "); sddf_printf(__VA_ARGS__); }while(0)

__attribute__((__section__(".blk_client_config"))) blk_client_config_t blk_config;
__attribute__((__section__(".serial_client_config"))) serial_client_config_t serial_config;

static serial_queue_handle_t serial_tx_queue_handle;

static blk_queue_handle_t blk_queue;

/* Use the start of the partition for testing. */
#define REQUEST_BLK_NUMBER 0
#define REQUEST_NUM_BLOCKS 2

enum test_basic_state {
    STATE_START,
    STATE_ENQUEUE_READ,
    STATE_CHECK_READ,
    STATE_FINISH,
};

enum test_basic_state test_basic_state = STATE_START;

bool test_basic()
{
    switch (test_basic_state) {
    case STATE_START: {
        LOG_CLIENT("basic: STATE_START state\n");
        // We assume that the data fits into two blocks
        assert(basic_data_len <= BLK_TRANSFER_SIZE * 2);

        // Copy our testing data into the block data region
        char *data_dest = (char *)blk_config.data.vaddr;
        sddf_memcpy(data_dest, basic_data, basic_data_len);

        int err = blk_enqueue_req(&blk_queue, BLK_REQ_WRITE, 0, REQUEST_BLK_NUMBER, REQUEST_NUM_BLOCKS, 0);
        assert(!err);

        test_basic_state = STATE_ENQUEUE_READ;

        break;
    }
    case STATE_ENQUEUE_READ: {
        LOG_CLIENT("basic: STATE_ENQUEUE_READ state\n");
        /* Check that our previous write was successful */
        blk_resp_status_t status = -1;
        uint16_t count = -1;
        uint32_t id = -1;
        int err = blk_dequeue_resp(&blk_queue, &status, &count, &id);
        assert(!err);
        assert(status == BLK_RESP_OK);
        assert(count == REQUEST_NUM_BLOCKS);
        assert(id == 0);

        /* We do the read at a different offset into the data region from the previous request */
        uintptr_t offset = REQUEST_NUM_BLOCKS * BLK_TRANSFER_SIZE;
        err = blk_enqueue_req(&blk_queue, BLK_REQ_READ, offset, REQUEST_BLK_NUMBER, REQUEST_NUM_BLOCKS, 0);
        assert(!err);

        test_basic_state = STATE_CHECK_READ;

        break;
    }
    case STATE_CHECK_READ: {
        LOG_CLIENT("basic: STATE_CHECK_READ state\n");
        blk_resp_status_t status = -1;
        uint16_t count = -1;
        uint32_t id = -1;
        int err = blk_dequeue_resp(&blk_queue, &status, &count, &id);
        assert(!err);
        assert(status == BLK_RESP_OK);
        assert(count == REQUEST_NUM_BLOCKS);
        assert(id == 0);

        // Check that the read went okay
        char *read_data = (char *)(blk_config.data.vaddr + (REQUEST_NUM_BLOCKS * BLK_TRANSFER_SIZE));
        for (int i = 0; i < basic_data_len; i++) {
            if (read_data[i] != basic_data[i]) {
                LOG_CLIENT_ERR("basic: mismatch in bytes at position %d\n", i);
            }
        }

        for (int i = 0; i < BLK_TRANSFER_SIZE; i += 90) {
            for (int j = 0; j < 90; j++) {
                sddf_printf("%c", read_data[i + j]);
            }
        }
        sddf_printf("\n");

        LOG_CLIENT("basic: successfully finished!\n");

        test_basic_state = STATE_FINISH;

        return true;
    }
    default:
        LOG_CLIENT_ERR("internal error, invalid state\n");
        assert(false);
    }

    return false;
}

void init(void)
{
    assert(serial_config_check_magic(&serial_config));
    serial_queue_init(&serial_tx_queue_handle, serial_config.tx.queue.vaddr, serial_config.tx.data.size,
                      serial_config.tx.data.vaddr);
    serial_putchar_init(serial_config.tx.id, &serial_tx_queue_handle);

    LOG_CLIENT("starting\n");

    assert(blk_config_check_magic(&blk_config));
    LOG_CLIENT("config check\n");
    blk_queue_init(&blk_queue, blk_config.virt.req_queue.vaddr, blk_config.virt.resp_queue.vaddr,
                   blk_config.virt.num_buffers);
    LOG_CLIENT("queue init\n");

    /* Want to print out the storage info, so spin until the it is ready. */
    blk_storage_info_t *storage_info = blk_config.virt.storage_info.vaddr;
    while (!blk_storage_is_ready(storage_info));
    LOG_CLIENT("device config ready\n");
    LOG_CLIENT("device size: 0x%lx bytes\n", storage_info->capacity * BLK_TRANSFER_SIZE);

    /* Before proceeding, check that the offset into the device we will
     * do I/O on is sane. */
    assert(REQUEST_BLK_NUMBER < storage_info->capacity - REQUEST_NUM_BLOCKS);

    test_basic();
    microkit_notify(blk_config.virt.id);
}

void notified(microkit_channel ch)
{
    assert(ch == blk_config.virt.id || ch == serial_config.tx.id);

    if (ch == blk_config.virt.id && !test_basic()) {
        microkit_notify(blk_config.virt.id);
    }
}
